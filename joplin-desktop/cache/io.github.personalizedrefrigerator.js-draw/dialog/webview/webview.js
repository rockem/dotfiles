(() => {
  // node_modules/js-draw/dist/bundledStyles.js
  var jsdrawStyles = (() => {
    (() => {
      if (typeof document < "u" && typeof document.createElement == "function") {
        let o = document.createElement("style");
        o.textContent = '\uFEFF:root .insert-image-widget-dropdown-content.insert-image-widget-dropdown-content.insert-image-widget-dropdown-content>div>div{padding:5px}:root .insert-image-widget-dropdown-content.insert-image-widget-dropdown-content.insert-image-widget-dropdown-content>div{min-height:0}:root .insert-image-widget-dropdown-content.insert-image-widget-dropdown-content.insert-image-widget-dropdown-content img{max-width:100%;max-height:100%;display:block;margin-left:auto;margin-right:auto}:root .insert-image-widget-dropdown-content.insert-image-widget-dropdown-content.insert-image-widget-dropdown-content .insert-image-image-status-view{display:flex;justify-content:space-between;padding-bottom:0}:root .insert-image-widget-dropdown-content.insert-image-widget-dropdown-content.insert-image-widget-dropdown-content .action-button-row{margin-top:4px;display:flex;flex-direction:row;justify-content:flex-end;padding-bottom:0;margin-bottom:0}:root .insert-image-widget-dropdown-content.insert-image-widget-dropdown-content.insert-image-widget-dropdown-content .action-button-row>button{flex-grow:1;text-align:end;max-width:50%;min-width:min(100%,40px)}.toolbar-overflow-widget-overflow-list{display:flex;flex-direction:column;flex-wrap:wrap;justify-content:center}.toolbar-overflow-widget-overflow-list>.toolbar-toolContainer>.toolbar-button{height:var(--toolbar-button-height)}.toolbar-overflow-widget.horizontal .toolbar-overflow-widget-overflow-list{flex-direction:row}.toolbar-overflow-widget.horizontal>.toolbar-dropdown{max-width:100%;left:15px;right:15px;margin-left:0 !important;translate:none !important;padding:4px}:root .toolbar--pen-tool-toggle-buttons.toolbar--pen-tool-toggle-buttons{display:flex;flex-wrap:wrap;justify-content:stretch;padding-top:0;padding-bottom:5px;gap:5px;direction:ltr}:root .toolbar--pen-tool-toggle-buttons.toolbar--pen-tool-toggle-buttons>*{flex-grow:1;text-align:start;width:min-content}:root .toolbar--pen-tool-toggle-buttons.toolbar--pen-tool-toggle-buttons>*>.icon{margin-inline-start:6px;margin-inline-end:10px}:root .toolbar--pen-tool-toggle-buttons.toolbar--pen-tool-toggle-buttons>:nth-child(2){text-align:center}:root .toolbar--pen-tool-toggle-buttons.toolbar--pen-tool-toggle-buttons>:nth-child(3){direction:rtl}.toolbar-zoomLevelEditor{display:flex;flex-direction:row;align-items:center}.toolbar-zoomLevelEditor .zoomDisplay{flex-grow:1}.toolbar-zoomLevelEditor button{min-width:48px}.selection-format-menu.disabled{opacity:.5}.toolbar-document-properties-widget button.about-button{width:100%;text-align:end}.toolbar-document-properties-widget>*{--align-items-to-x: 120px}.toolbar-document-properties-widget .js-draw-size-input-row.js-draw-size-input-row{display:flex}.toolbar-document-properties-widget .js-draw-size-input-row.js-draw-size-input-row.size-input-row--automatic-size{display:none}.toolbar-thicknessSliderContainer{display:flex;flex-direction:row}.toolbar-thicknessSliderContainer input{flex-grow:1}.toolbar-element .clr-field *{cursor:pointer}.toolbar-element .clr-field button{width:1.2em;height:1.2em;top:50%;left:0;border-radius:50%;margin-left:0;margin-right:0}.toolbar-element .clr-field input{opacity:0}.color-input-container{display:inline-flex;flex-direction:row}.color-input-container .coloris_input{height:calc(100% - 6px)}.color-input-container.picker-open .clr-field{pointer-events:none}:root .color-input-container>button.pipetteButton{width:30px;height:30px;padding:0;display:inline-flex}.color-input-container>.color-input-wrapper{display:flex;justify-content:stretch}.color-input-container .pipetteButton>svg{width:100%}.color-input-container .pipetteButton .pickColorInstructions{display:none;font-size:1em;position:absolute;margin-left:30px;background-color:var(--background-color-1);border-radius:30px;padding:4px;opacity:0;transition:.2s ease opacity}@media(prefers-reduced-motion: reduce){.color-input-container .pipetteButton .pickColorInstructions{transition:none}}.color-input-container .pipetteButton.active{background-color:var(--selection-background-color);--icon-color: var(--selection-foreground-color)}.color-input-container .pipetteButton.active .pickColorInstructions{display:block;opacity:.8}.tool-dropdown-separator{--border-color: rgba(100, 100, 100, 0.2);--border-color: color-mix(in srgb, var(--foreground-color-1), rgba(0, 0, 0, 0) 80%);border-top:1px solid var(--border-color);padding-left:2px;margin-top:10px;margin-bottom:10px}.toolbar-element .toolbar--file-input-container{display:flex}.toolbar-element .toolbar--file-input-container.-loading{opacity:.8}.toolbar-element .toolbar--file-input-container>input.file-input{opacity:0;width:0;min-width:0 !important;max-width:0;height:0;overflow:hidden;padding:0;margin:0}.toolbar-element .toolbar--file-input-container>label{display:block;flex-grow:1;padding:0 !important;padding-bottom:5px;--active-border-color: rgba(100, 100, 100, 0.5);--active-border-color: color-mix(in srgb, var(--foreground-color-1), transparent)}.toolbar-element .toolbar--file-input-container>label .cancel-button{padding-left:3px;padding-right:3px}.toolbar-element .toolbar--file-input-container>label>.toolbar--file-input-description{background-color:var(--background-color-3);color:var(--foreground-color-3);border:1px dashed var(--active-border-color);padding:10px;margin-top:10px;display:flex;flex-direction:column;align-items:center;text-align:center;--action-color: var(--primary-action-foreground-color);--icon-color: var(--action-color)}.toolbar-element .toolbar--file-input-container>label>.toolbar--file-input-description>span{white-space:pre-wrap}.toolbar-element .toolbar--file-input-container>label>.toolbar--file-input-description>span>b{color:var(--action-color);cursor:pointer}.toolbar-element .toolbar--file-input-container>label>.toolbar--file-input-description>.icon{width:min(50vw,42px);height:min(50vw,42px);margin-bottom:8px;display:block}.toolbar-element .toolbar--file-input-container>label:active,.toolbar-element .toolbar--file-input-container>label:hover,.toolbar-element .toolbar--file-input-container>label.drag-target{--active-border-color: var(--foreground-color-1)}.toolbar-element .toolbar--file-input-container>label.drag-target>.toolbar--file-input-description{border-width:2px}.toolbar-grid-selector{position:relative}.toolbar-grid-selector>div{display:flex;flex-direction:row;max-width:350px;flex-wrap:wrap;--button-size: 48px}.toolbar-grid-selector .choice-button{display:flex;flex-direction:column-reverse;box-sizing:border-box;cursor:pointer;flex-shrink:1;margin:2px}.toolbar-grid-selector .choice-button.focus-visible{outline:2px solid var(--foreground-color-1)}.toolbar-grid-selector .choice-button input{opacity:0;height:0}.toolbar-grid-selector .choice-button label{display:flex;flex-direction:column;box-sizing:border-box;width:var(--button-size);height:var(--button-size);font-size:.7rem;align-items:center;justify-content:center;padding:4px;user-select:none;-webkit-user-select:none}.toolbar-grid-selector .choice-button .icon{flex-grow:1;flex-shrink:1;width:100%}.toolbar-grid-selector .choice-button.checked{background-color:var(--selection-background-color);color:var(--selection-foreground-color);--icon-color: var(--selection-foreground-color)}:root .toolbar-snapped-scroll-list.toolbar-snapped-scroll-list.toolbar-snapped-scroll-list{height:min(140px,50vh);position:relative;display:flex;align-items:center}:root .toolbar-snapped-scroll-list.toolbar-snapped-scroll-list.toolbar-snapped-scroll-list>.scroller{display:flex;flex-direction:column;overflow-y:auto;scroll-snap-type:y mandatory;height:100%;width:100%;flex-grow:1}:root .toolbar-snapped-scroll-list.toolbar-snapped-scroll-list.toolbar-snapped-scroll-list>.scroller>.item{height:100%;width:100%;flex-shrink:0;display:flex;justify-content:center;align-items:center;scroll-snap-align:start;scroll-snap-stop:always;box-sizing:border-box}:root .toolbar-snapped-scroll-list.toolbar-snapped-scroll-list.toolbar-snapped-scroll-list.-empty{display:none}:root .toolbar-snapped-scroll-list.toolbar-snapped-scroll-list.toolbar-snapped-scroll-list>.page-markers{overflow:hidden;display:flex;flex-direction:column;align-items:center;max-height:100%;min-height:0}:root .toolbar-snapped-scroll-list.toolbar-snapped-scroll-list.toolbar-snapped-scroll-list>.page-markers.-one-element{visibility:hidden}:root .toolbar-snapped-scroll-list.toolbar-snapped-scroll-list.toolbar-snapped-scroll-list>.page-markers>.marker{padding:2px;opacity:.1;cursor:pointer;left:0;transition:left .2s ease}:root .toolbar-snapped-scroll-list.toolbar-snapped-scroll-list.toolbar-snapped-scroll-list>.page-markers>.marker>.content{background-color:var(--foreground-color-1);border-radius:2px;padding:2px}:root .toolbar-snapped-scroll-list.toolbar-snapped-scroll-list.toolbar-snapped-scroll-list>.page-markers>.marker.-active{position:relative;left:2px;opacity:.2}.toolbar-button-grid{display:grid;grid-template-columns:repeat(var(--column-count), 1fr);justify-items:center;--button-size: 30px}.toolbar-button-grid>.button{font-size:1em;width:min-content}.toolbar-button-grid>.button>.icon{max-width:var(--button-size);max-height:var(--button-size);width:48px;height:48px}.toolbar-button-grid>.button>label{display:block;font-weight:normal}.toolbar-root{background-color:var(--background-color-1);--icon-color: var(--foreground-color-1);--toolbar-button-height: min(20vh, 60px);flex-wrap:wrap;box-sizing:border-box;width:100%;display:flex;flex-direction:row;justify-content:center}.toolbar-element{z-index:1;font-family:system-ui,-apple-system,sans-serif}.toolbar-element details>summary{cursor:pointer}.toolbar-element>.toolbar-toolContainer>.toolbar-button,.toolbar-element>.toolbar-toolContainer>*>button,.toolbar-element>.toolbar-buttonGroup>button,.toolbar-element>.toolbar-button{white-space:pre;height:var(--toolbar-button-height)}.toolbar-dropdown .toolbar-button>.toolbar-icon{max-width:50px;width:100%}.toolbar-button.disabled{filter:sepia(0.2);opacity:.45;cursor:unset}.toolbar-button,.toolbar-element button{cursor:pointer;text-align:center;border-radius:6px;border:none;box-shadow:0px 0px 2px var(--shadow-color);user-select:none;-webkit-user-select:none;transition:background-color .15s ease,box-shadow .25s ease,opacity .2s ease}.toolbar-button,.toolbar-buttonGroup>button,.toolbar-toolContainer>*>button,.toolbar-root>button{display:flex;flex-direction:column;align-items:center;justify-content:center;padding-left:3px;padding-right:3px;min-width:40px;max-width:105px;width:min-content;font-size:1em}.toolbar-button>label{cursor:inherit;user-select:none;-webkit-user-select:none}.toolbar-root>.toolbar-toolContainer>.toolbar-button>label.long-label{font-size:.75em}.toolbar-dropdown>.toolbar-toolContainer>button,.toolbar-dropdown>.toolbar-toolContainer>.toolbar-button{width:6em}.toolbar-button:not(.disabled):hover,.toolbar-root button:not(:disabled):hover{box-shadow:0px 2px 4px var(--shadow-color)}.toolbar-root button:disabled{cursor:inherit;opacity:.5}.toolbar-root .toolbar-icon{flex-shrink:1;user-select:none;width:100%;min-width:20px;min-height:20px}.toolbar-toolContainer.selected>.toolbar-button{background-color:var(--selection-background-color);color:var(--selection-foreground-color);--icon-color: var(--selection-foreground-color)}.toolbar-toolContainer:not(.selected):not(.dropdownShowable)>.toolbar-button>.toolbar-showHideDropdownIcon{display:none}.toolbar-toolContainer>.toolbar-button>.toolbar-showHideDropdownIcon{height:15px;transition:transform .25s ease}.toolbar-toolContainer.dropdownVisible>.toolbar-button>.toolbar-showHideDropdownIcon{transform:rotate(180deg)}.toolbar-dropdown.hidden,.toolbar-toolContainer:not(.selected):not(.dropdownShowable)>.toolbar-dropdown:not(.hiding){display:none}.toolbar-dropdown{position:absolute;padding:15px;padding-top:5px;display:flex;flex-wrap:wrap;flex-direction:column;max-height:80vh;max-width:fit-content;z-index:2;background-color:var(--background-color-1);box-shadow:0px 3px 3px var(--shadow-color)}@keyframes dropdown-transition-in{0%{opacity:0;transform:scale(1, 0)}100%{opacity:1;transform:scale(1, 1)}}@keyframes dropdown-transition-out{0%{opacity:1;transform:scale(1, 1)}100%{opacity:0;transform:scale(1, 0)}}.toolbar-dropdown{transform-origin:top left;--dropdown-show-animation: dropdown-transition-in;--dropdown-hide-animation: dropdown-transition-out}@media(prefers-reduced-motion: reduce){.toolbar-dropdown{--dropdown-show-animation: none;--dropdown-hide-animation: none}.toolbar-dropdown.hiding{display:none}.toolbar-toolContainer>.toolbar-button>.toolbar-showHideDropdownIcon{transition:none}:root .toolbar-button,.toolbar-root button{transition:none}}.toolbar-buttonGroup{display:flex;flex-direction:row;justify-content:center}.toolbar-element .toolbar--toggle-button{color:var(--foreground-color-1);font-weight:normal}.toolbar-element .toolbar--toggle-button[aria-checked=true]{background:var(--selection-background-color);color:var(--selection-foreground-color)}.toolbar-element .toolbar--toggle-button>.icon{width:25px;height:25px;margin:0 5px}.toolbar-element .toolbar--toggle-button>*{vertical-align:middle}.toolbar-closeColorPickerOverlay{display:none;position:fixed;top:0;left:0;bottom:0;right:0;touch-action:none;background-color:var(--background-color-1);opacity:.3;z-index:2}.toolbar-spacedList>*{padding-bottom:5px;padding-top:5px}.toolbar-indentedList{padding-left:10px}@media print{.toolbar-element{display:none}}@keyframes rehide-label{0%{opacity:.8}80%{opacity:.8}100%{opacity:.1}}@keyframes show-label-delayed{0%{opacity:0}80%{opacity:0}100%{opacity:.8}}@keyframes show-label-now{0%{opacity:0}5%{opacity:0}100%{opacity:.8}}@keyframes keep-label-hidden{0%{opacity:0}100%{opacity:0}}@keyframes toolbar--edgemenu-transition-in{from{transform:translate(0, 100%)}to{transform:translate(0, 0)}}@keyframes toolbar--edgemenu-transition-in-reduce-motion{from{opacity:0}to{opacity:1}}@keyframes toolbar--edgemenu-transition-out{to{transform:translate(0, 100%)}}@keyframes toolbar--edgemenu-transition-out-reduce-motion{from{opacity:1}to{opacity:0}}@keyframes toolbar--edgemenu-container-transition-in{from{overflow-y:hidden}to{overflow-y:hidden}}@keyframes toolbar--edgemenu-container-transition-out{from{overflow-y:hidden}to{overflow-y:hidden}}.toolbar-edge-toolbar{--toolbar-button-height: min(20vh, 48px);--toolbar-button-size: var(--toolbar-button-height);--label-hover-offset-size: calc(14px + var(--toolbar-button-height));box-sizing:border-box;flex-direction:row;justify-content:space-around;--button-label-hover-offset-y: var(--label-hover-offset-size);--button-label-hover-offset-x: 0}@media screen and (min-width: 540px){.toolbar-edge-toolbar{flex-wrap:nowrap}.toolbar-edge-toolbar>.toolbar-action-row{max-width:50vw;flex-grow:0;flex-shrink:0}}@media screen and (max-width: 700px){.toolbar-edge-toolbar.one-row>*>.toolbar-toolContainer.label-inline{font-size:.9em}.toolbar-edge-toolbar.one-row>*>.toolbar-toolContainer.label-inline>.toolbar-button{width:var(--toolbar-button-size)}.toolbar-edge-toolbar.one-row>*>.toolbar-toolContainer.label-inline>.toolbar-button label{opacity:0;animation:.2s linear hide-initially}@keyframes hide-initially{from{opacity:0}to{opacity:0}}.toolbar-edge-toolbar.one-row>*>.toolbar-toolContainer.label-inline>.toolbar-button:not(.no-long-press-or-hover):not(.has-long-press-or-hover):hover:not(:focus-visible)>label,.toolbar-edge-toolbar.one-row>*>.toolbar-toolContainer.label-inline>.toolbar-button:not(.no-long-press-or-hover):not(.has-long-press-or-hover):active>label{opacity:.8;animation:1s ease show-label-delayed}.toolbar-edge-toolbar.one-row>*>.toolbar-toolContainer.label-inline>.toolbar-button.has-long-press-or-hover>label{opacity:.8}.toolbar-edge-toolbar.one-row>*>.toolbar-toolContainer.label-inline>.toolbar-button:focus-visible>label,.toolbar-edge-toolbar.one-row>*>.toolbar-toolContainer.label-inline>.toolbar-button.focus-visible>label{animation:1.5s ease rehide-label;opacity:0}.toolbar-edge-toolbar.one-row>*>.toolbar-toolContainer.label-inline>.toolbar-button:has(:focus-visible)>label{animation:1.5s ease rehide-label;opacity:0}.toolbar-edge-toolbar.one-row>*>.toolbar-toolContainer.label-inline>.toolbar-button>label{opacity:0;position:absolute;margin-top:var(--button-label-hover-offset-y);margin-left:var(--button-label-hover-offset-x);z-index:1;pointer-events:none;background-color:var(--background-color-1);color:var(--foreground-color-1);border-radius:25px;padding:10px;transition:.3s ease opacity,.2s ease margin-top}}@media screen and (max-width: 700px)and (prefers-reduced-motion: reduce){.toolbar-edge-toolbar.one-row>*>.toolbar-toolContainer.label-inline>.toolbar-button>label{transition:none}}@media screen and (max-width: 700px){.toolbar-edge-toolbar.one-row>*>.toolbar-toolContainer.label-inline>.toolbar-button>.toolbar-icon.toolbar-icon{margin-left:0;margin-right:0}}.toolbar-edge-toolbar>div.toolbar-element{flex-direction:row;display:flex;flex-grow:1;justify-content:center;background-color:var(--background-color-2);color:var(--foreground-color-2);--icon-color: var(--foreground-color-2);--extra-left-right-padding: 0px}.toolbar-edge-toolbar>div.toolbar-element::-webkit-scrollbar{width:3px;height:3px}.toolbar-edge-toolbar>div.toolbar-element::-webkit-scrollbar-thumb{background-color:var(--shadow-color)}.toolbar-edge-toolbar>div.toolbar-element.toolbar-tool-row{overflow-x:auto;overflow-y:hidden;flex-grow:100}.toolbar-edge-toolbar>div.toolbar-element.toolbar-action-row{z-index:2;background-color:var(--background-color-3);color:var(--foreground-color-3);--icon-color: var(--foreground-color-3)}.toolbar-edge-toolbar>div.toolbar-element.has-scroll{justify-content:start;position:relative;--button-label-hover-offset-y: 0;--button-label-hover-offset-x: calc(0px - var(--label-hover-offset-size))}.toolbar-edge-toolbar>div.toolbar-element.has-scroll>:nth-child(1){--button-label-hover-offset-x: var(--label-hover-offset-size)}.toolbar-edge-toolbar .toolbar-toolContainer.selected>.toolbar-button{background-color:var(--selection-background-color);color:var(--selection-foreground-color);--icon-color: var(--selection-foreground-color)}.toolbar-edge-toolbar .toolbar-button{box-sizing:border-box;background-color:rgba(0,0,0,0)}.toolbar-edge-toolbar .toolbar-button .toolbar-showHideDropdownIcon{flex-shrink:.01;height:12px}.toolbar-edge-toolbar .toolbar-toolContainer{order:1}.toolbar-edge-toolbar .toolbar-toolContainer.label-inline{flex-grow:1;display:flex;--button-flex-direction: row}.toolbar-edge-toolbar .toolbar-toolContainer.label-inline.label-left{justify-content:end;--button-flex-direction: row-reverse;order:100}.toolbar-edge-toolbar .toolbar-toolContainer.label-inline.label-left>.toolbar-button>.toolbar-icon{margin-left:7px;margin-right:0}.toolbar-edge-toolbar .toolbar-toolContainer.label-inline.label-right{order:-1}.toolbar-edge-toolbar .toolbar-toolContainer.label-inline>.toolbar-button{width:auto;flex-direction:var(--button-flex-direction)}.toolbar-edge-toolbar .toolbar-toolContainer.label-inline>.toolbar-button>.toolbar-icon{height:100%;margin-right:7px;margin-left:0;width:22px}.toolbar-edge-toolbar .toolbar-toolContainer:not(.no-icon):not(.label-inline) .toolbar-button{width:calc(var(--toolbar-button-size) + var(--extra-left-right-padding));height:var(--toolbar-button-size)}.toolbar-edge-toolbar .toolbar-toolContainer:not(.no-icon):not(.label-inline) .toolbar-button:not(.no-long-press-or-hover):not(.has-long-press-or-hover):hover:not(:focus-visible)>label,.toolbar-edge-toolbar .toolbar-toolContainer:not(.no-icon):not(.label-inline) .toolbar-button:not(.no-long-press-or-hover):not(.has-long-press-or-hover):active>label{opacity:.8;animation:1s ease show-label-delayed}.toolbar-edge-toolbar .toolbar-toolContainer:not(.no-icon):not(.label-inline) .toolbar-button.has-long-press-or-hover>label{opacity:.8}.toolbar-edge-toolbar .toolbar-toolContainer:not(.no-icon):not(.label-inline) .toolbar-button:focus-visible>label,.toolbar-edge-toolbar .toolbar-toolContainer:not(.no-icon):not(.label-inline) .toolbar-button.focus-visible>label{animation:1.5s ease rehide-label;opacity:0}.toolbar-edge-toolbar .toolbar-toolContainer:not(.no-icon):not(.label-inline) .toolbar-button:has(:focus-visible)>label{animation:1.5s ease rehide-label;opacity:0}.toolbar-edge-toolbar .toolbar-toolContainer:not(.no-icon):not(.label-inline) .toolbar-button>label{opacity:0;position:absolute;margin-top:var(--button-label-hover-offset-y);margin-left:var(--button-label-hover-offset-x);z-index:1;pointer-events:none;background-color:var(--background-color-1);color:var(--foreground-color-1);border-radius:25px;padding:10px;transition:.3s ease opacity,.2s ease margin-top}@media(prefers-reduced-motion: reduce){.toolbar-edge-toolbar .toolbar-toolContainer:not(.no-icon):not(.label-inline) .toolbar-button>label{transition:none}}.toolbar-edge-toolbar .toolbar-toolContainer:not(.no-icon):not(.label-inline).dropdownVisible>.toolbar-button>label{opacity:.8;animation:1.5s ease rehide-label .3s,1s ease keep-label-hidden 1.8s infinite}.toolbar-edge-toolbar>div>.toolbar-toolContainer:not(.selected):not(.dropdownShowable)>.toolbar-button>.toolbar-showHideDropdownIcon{display:block;visibility:hidden}.toolbar-edge-toolbar .toolbar-toolContainer>.toolbar-button{margin:0;border-radius:0;padding:8px;box-shadow:none}.toolbar-edge-toolbar .toolbar-toolContainer>.toolbar-button.has-dropdown{padding-left:8px;padding-right:8px;padding-top:8px;padding-bottom:0px}.imageEditorContainer.pipette--color-selection-in-progress .toolbar-edgemenu-container{height:0;background-color:rgba(0,0,0,0);opacity:.9}.imageEditorContainer.pipette--color-selection-in-progress .toolbar-edgemenu-container .toolbar-edgemenu{position:absolute}.toolbar-edgemenu-container{background-color:var(--background-color-transparent);transition:.15s ease-in-out height,.15s ease-in-out background-color,.2s ease-in-out opacity;position:absolute;width:var(--editor-current-width-px);height:var(--editor-current-height-px);box-sizing:border-box;display:flex;flex-direction:column-reverse;align-items:center;z-index:2}@media(prefers-reduced-motion: reduce){.toolbar-edgemenu-container{transition:.15s ease-in-out background-color,.2s ease-in-out opacity}}.toolbar-edgemenu-container.dropdown-below-edge{overflow-y:hidden}.toolbar-edgemenu-container button{font-size:1.2em;box-shadow:none;border:none;padding:10px;transition:.2s ease box-shadow;font-weight:bold;color:var(--primary-action-foreground-color)}.toolbar-edgemenu-container button:not(:disabled):hover{box-shadow:0 0px 2px var(--shadow-color)}.toolbar-edgemenu-container button:disabled{opacity:.5;font-weight:unset;cursor:unset;color:var(--foreground-color-1)}.toolbar-edgemenu-container .toolbar-grid-selector .choice-button{--button-label-hover-offset-y: var(--button-size)}.toolbar-edgemenu-container .toolbar-grid-selector .choice-button:not(.no-long-press-or-hover):not(.has-long-press-or-hover):hover:not(:focus-visible)>label>.button-label-text,.toolbar-edgemenu-container .toolbar-grid-selector .choice-button:not(.no-long-press-or-hover):not(.has-long-press-or-hover):active>label>.button-label-text{opacity:.8;animation:1s ease show-label-delayed}.toolbar-edgemenu-container .toolbar-grid-selector .choice-button.has-long-press-or-hover>label>.button-label-text{opacity:.8}.toolbar-edgemenu-container .toolbar-grid-selector .choice-button:focus-visible>label>.button-label-text,.toolbar-edgemenu-container .toolbar-grid-selector .choice-button.focus-visible>label>.button-label-text{animation:1.5s ease rehide-label;opacity:0}.toolbar-edgemenu-container .toolbar-grid-selector .choice-button:has(:focus-visible)>label>.button-label-text{animation:1.5s ease rehide-label;opacity:0}.toolbar-edgemenu-container .toolbar-grid-selector .choice-button>label>.button-label-text{opacity:0;position:absolute;margin-top:var(--button-label-hover-offset-y);margin-left:var(--button-label-hover-offset-x);z-index:1;pointer-events:none;background-color:var(--background-color-1);color:var(--foreground-color-1);border-radius:25px;padding:10px;transition:.3s ease opacity,.2s ease margin-top}@media(prefers-reduced-motion: reduce){.toolbar-edgemenu-container .toolbar-grid-selector .choice-button>label>.button-label-text{transition:none}}.toolbar-edgemenu-container .toolbar-button-grid button{--button-label-hover-offset-y: 0}.toolbar-edgemenu-container .toolbar-button-grid button:not(.no-long-press-or-hover):not(.has-long-press-or-hover):hover:not(:focus-visible)>label,.toolbar-edgemenu-container .toolbar-button-grid button:not(.no-long-press-or-hover):not(.has-long-press-or-hover):active>label{opacity:.8;animation:1s ease show-label-delayed}.toolbar-edgemenu-container .toolbar-button-grid button.has-long-press-or-hover>label{opacity:.8}.toolbar-edgemenu-container .toolbar-button-grid button:focus-visible>label,.toolbar-edgemenu-container .toolbar-button-grid button.focus-visible>label{animation:1.5s ease rehide-label;opacity:0}.toolbar-edgemenu-container .toolbar-button-grid button:has(:focus-visible)>label{animation:1.5s ease rehide-label;opacity:0}.toolbar-edgemenu-container .toolbar-button-grid button>label{opacity:0;position:absolute;margin-top:var(--button-label-hover-offset-y);margin-left:var(--button-label-hover-offset-x);z-index:1;pointer-events:none;background-color:var(--background-color-1);color:var(--foreground-color-1);border-radius:25px;padding:10px;transition:.3s ease opacity,.2s ease margin-top}@media(prefers-reduced-motion: reduce){.toolbar-edgemenu-container .toolbar-button-grid button>label{transition:none}}.toolbar-edgemenu-container .toolbar-help-overlay-button{align-items:last baseline}.toolbar-edgemenu-container .toolbar-edgemenu{--toolbar-button-height: 48px;touch-action:none;user-select:none;-webkit-user-select:none;background-color:var(--background-color-2);color:var(--foreground-color-2);--icon-color: var(--foreground-color-2);box-shadow:0px 0px 1px var(--shadow-color);padding-left:10px;padding-right:10px;width:min(400px,100vw);box-sizing:border-box;border-top-left-radius:30px;border-top-right-radius:30px;transition:transform .1s ease,padding-bottom .1s ease}.toolbar-edgemenu-container .toolbar-edgemenu input,.toolbar-edgemenu-container .toolbar-edgemenu textarea{user-select:auto;-webkit-user-select:auto}.toolbar-edgemenu-container .toolbar-edgemenu .toolbar-toolContainer{display:inline-block}.toolbar-edgemenu-container .toolbar-edgemenu button{background-color:rgba(0,0,0,0)}.toolbar-edgemenu-container .toolbar-edgemenu>button.drag-elem{height:40px;display:block;cursor:ns-resize;position:relative;margin-top:-15px;margin-bottom:10px;width:100%;border:none;box-shadow:none;background:rgba(0,0,0,0)}.toolbar-edgemenu-container .toolbar-edgemenu>button.drag-elem::before{content:"";background-color:var(--icon-color);opacity:.2;display:block;position:relative;top:10px;height:5px;border-radius:5px;width:min(80%,40px);margin-left:auto;margin-right:auto}.toolbar-edgemenu-container .toolbar-edgemenu .toolbar-toolContainer{display:block}.toolbar-edgemenu-container .toolbar-edgemenu .toolbar-toolContainer .toolbar-button{flex-direction:row;max-width:unset;width:100%;box-sizing:border-box;justify-content:flex-start;box-shadow:none;padding:2px}.toolbar-edgemenu-container .toolbar-edgemenu .toolbar-toolContainer .toolbar-button>.toolbar-icon{width:25px;height:25px;padding:13px;margin-right:15px}.toolbar-edgemenu-container .toolbar-edgemenu .toolbar-toolContainer .toolbar-button label,.toolbar-edgemenu-container .toolbar-edgemenu .toolbar-toolContainer .toolbar-button>label.long-label{font-size:1em}.toolbar-edgemenu-container .toolbar-edgemenu .toolbar-nonbutton-controls-main-list{padding-left:10px;padding-right:10px}.toolbar-edgemenu-container .toolbar-edgemenu .toolbar-spacedList{box-sizing:border-box;--align-items-to-x: 105px}.toolbar-edgemenu-container .toolbar-edgemenu .toolbar-spacedList>div{display:flex;align-items:center;margin-top:5px;min-height:35px}.toolbar-edgemenu-container .toolbar-edgemenu .toolbar-spacedList>div:first-child{margin-top:0}.toolbar-edgemenu-container .toolbar-edgemenu .toolbar-spacedList>div>label{padding-right:35px;min-width:var(--align-items-to-x);flex-shrink:1;box-sizing:border-box}.toolbar-edgemenu-container .toolbar-edgemenu .toolbar-spacedList>div>input[type=checkbox]{width:20px;height:20px;margin-left:0}.toolbar-edgemenu-container .toolbar-edgemenu .toolbar-spacedList>div>input:not([type=checkbox]){flex-grow:1;min-width:48px;flex-shrink:1}.toolbar-dropdown-toolbar button,.toolbar-dropdown-toolbar .toolbar-button{background-color:var(--background-color-2);color:var(--foreground-color-2);--icon-color: var(--foreground-color-2)}.toolbar-dropdown-toolbar,.toolbar-dropdown-toolbar .toolbar-dropdown{background-color:var(--background-color-3);color:var(--foreground-color-3)}.toolbar-dropdown-toolbar .toolbar-spacedList>div>label{padding-right:10px;min-width:50px}.toolbar-dropdown-toolbar .clr-field button{width:100%;height:100%;top:50%;left:0;border-radius:5px}.toolbar-dropdown-toolbar .toolbar-grid-selector>div{--button-size: 57px}.toolbar-dropdown-toolbar .toolbar-dropdown>div>.toolbar-toolContainer{display:inline-block}.toolbar-help-overlay{width:100%;height:100%;max-width:none;max-height:none;border:none;margin:0;padding:0;z-index:5;touch-action:none;overflow:hidden;color:#fff;--icon-color: white;background-color:rgba(0,0,0,0);display:flex;flex-direction:column;transition:.3s ease transform}.toolbar-help-overlay::backdrop{background-color:rgba(0,0,0,.8);backdrop-filter:blur(1px);-webkit-backdrop-filter:blur(1px)}.toolbar-help-overlay,.toolbar-help-overlay::backdrop{animation:.25s ease transition-in}@keyframes transition-in{0%{opacity:0}100%{opacity:1}}@keyframes transition-out{0%{opacity:1}100%{opacity:0}}.toolbar-help-overlay.-hiding,.toolbar-help-overlay.-hiding::backdrop{animation:.25s ease transition-out;opacity:0}.toolbar-help-overlay.-dragging{transition:none}@media(prefers-reduced-motion: reduce){.toolbar-help-overlay{transition:none}}@media screen and (min-width: 800px){.toolbar-help-overlay>.navigation-buttons{order:1;margin-top:auto}}.toolbar-help-overlay .with-text-shadow,.toolbar-help-overlay .help-page-container>.label,.toolbar-help-overlay button{text-shadow:0 0 3px rgba(20,20,20,.9);filter:drop-shadow(0px 0px 2px rgba(0, 0, 0, 0.5))}.toolbar-help-overlay button:not(:disabled){cursor:pointer}.toolbar-help-overlay button{background:rgba(0,0,0,0);border:none;color:var(--help-overlay-foreground);border-radius:15px}.toolbar-help-overlay .close-button{align-self:flex-start;width:48px;height:48px;z-index:1}.toolbar-help-overlay .close-button>svg{width:100%}.toolbar-help-overlay .navigation-content{flex-grow:1;display:flex}.toolbar-help-overlay .help-page-container{display:flex;align-items:center;flex-grow:1;touch-action:none}.toolbar-help-overlay .help-page-container>.label{flex-grow:1;text-align:center;font-size:18.5pt;margin-left:15px;margin-right:15px;margin-top:0px;z-index:1;transition:.5s ease margin-top}.toolbar-help-overlay .help-page-container>.label.-large-space-below{margin-top:0;margin-bottom:auto}.toolbar-help-overlay .help-page-container>.label.-small-space-above{margin-top:40px;margin-bottom:auto}.toolbar-help-overlay .help-page-container>.label.-large-space-above{margin-top:auto;margin-bottom:10px}@media(prefers-reduced-motion: reduce){.toolbar-help-overlay .help-page-container>.label{transition:none}}.toolbar-help-overlay .help-page-container>.cloned-element-container{position:absolute;z-index:0;user-select:none;-webkit-user-select:none;border-radius:10px;opacity:.01;background-color:rgba(100,100,100,.01);box-shadow:none;transition:.5s ease opacity,.5s ease background-color}.toolbar-help-overlay .help-page-container>.cloned-element-container *{pointer-events:none !important}.toolbar-help-overlay .help-page-container>.cloned-element-container>*{margin:0;opacity:.01 !important;transition:.3s ease opacity !important}.toolbar-help-overlay .help-page-container>.cloned-element-container:not(.-clickable) *{cursor:unset !important}.toolbar-help-overlay .help-page-container>.cloned-element-container.-clickable,.toolbar-help-overlay .help-page-container>.cloned-element-container.-background{z-index:1;touch-action:none}.toolbar-help-overlay .help-page-container>.cloned-element-container.-clickable{cursor:pointer;z-index:2}.toolbar-help-overlay .help-page-container>.cloned-element-container.-clickable.has-long-press-or-hover{opacity:.5 !important}.toolbar-help-overlay .help-page-container>.cloned-element-container.-clickable.has-long-press-or-hover,.toolbar-help-overlay .help-page-container>.cloned-element-container.-active{background-color:var(--background-color-1)}.toolbar-help-overlay .help-page-container>.cloned-element-container.-active{opacity:1;background-color:var(--background-color-1);box-shadow:0 0 3px rgba(100,100,100,.5)}.toolbar-help-overlay .help-page-container>.cloned-element-container.-active>*{opacity:1 !important}.toolbar-help-overlay .navigation-buttons{display:flex;flex-direction:row;justify-content:space-between;direction:ltr}.toolbar-help-overlay .navigation-buttons>button:disabled{opacity:.5}.toolbar-help-overlay .navigation-buttons>.next,.toolbar-help-overlay .navigation-buttons>.previous{font-size:1em;padding:10px;transition:.2s ease font-size;z-index:3}@media(prefers-reduced-motion: reduce){.toolbar-help-overlay .navigation-buttons>.next,.toolbar-help-overlay .navigation-buttons>.previous{transition:none}}.toolbar-help-overlay .navigation-buttons:not(.-has-previous)>.next:not(:disabled){animation:.5s ease highlight-button .5s}@keyframes highlight-button{0%{transform:scale(1)}50%{transform:scale(1.2)}55%{transform:scale(1.2) rotate(2deg)}65%{transform:scale(1.2) rotate(-2deg)}100%{transform:scale(1)}}@media(prefers-reduced-motion: reduce){.toolbar-help-overlay .navigation-buttons:not(.-has-previous)>.next:not(:disabled){animation:none}}.toolbar-help-overlay .navigation-buttons>.next::after{content:"\u276F";margin-left:3px}.toolbar-help-overlay .navigation-buttons>.previous::before{content:"\u276E";margin-right:3px}.toolbar-help-overlay .navigation-buttons.-has-next>.next{font-size:1.4em}.toolbar-help-overlay .navigation-buttons.-has-previous>.previous{font-size:1.4em}.toolbar-help-overlay .navigation-buttons.-highlight-next>.next,.toolbar-help-overlay .navigation-buttons.-highlight-previous>.previous{font-weight:bold;font-size:1.4em}.toolbar-help-overlay .navigation-buttons.-highlight-next>.next,.toolbar-help-overlay .navigation-buttons.-highlight-previous>.previous,.toolbar-help-overlay .navigation-buttons .next:hover,.toolbar-help-overlay .navigation-buttons .previous:hover{background-color:rgba(200,200,200,.1)}.toolbar-help-overlay .navigation-help{margin-top:1em;font-size:.7em}.toolbar-element .toolbar-help-overlay-button{height:0;position:relative;display:flex;justify-content:end}.toolbar-element .toolbar-help-overlay-button>.button{margin:0;padding:5px;padding-top:0;padding-bottom:0;box-shadow:none;text-align:center;opacity:.5}.toolbar-element .toolbar-help-overlay-button>.button>.icon{width:1.18em;height:1.18em;transition:.2s ease filter}.toolbar-element .toolbar-help-overlay-button>.button:focus-visible>.icon,.toolbar-element .toolbar-help-overlay-button>.button:hover>.icon{filter:drop-shadow(0px 0px 1px var(--shadow-color))}.ScrollbarTool-overlay{width:0;height:0;overflow:visible;opacity:.2;pointer-events:none;--fade-out-animation: 1s ease 0s fade-out;--scrollbar-size: 3px}@media(prefers-reduced-motion: reduce){.ScrollbarTool-overlay{--fade-out-animation: none !important}}@keyframes fade-out{from{opacity:.2}to{opacity:0}}.ScrollbarTool-overlay:not(.just-updated){animation:var(--fade-out-animation);opacity:0}.ScrollbarTool-overlay .vertical-scrollbar,.ScrollbarTool-overlay .horizontal-scrollbar{width:var(--scrollbar-size);height:var(--scrollbar-size);min-width:var(--scrollbar-size);min-height:var(--scrollbar-size);background-color:var(--foreground-color-1);border-radius:var(--scrollbar-size);position:absolute}.ScrollbarTool-overlay .vertical-scrollbar.represents-no-scroll,.ScrollbarTool-overlay .horizontal-scrollbar.represents-no-scroll{animation:var(--fade-out-animation);opacity:0}.ScrollbarTool-overlay:not(.scrollbar-left) .vertical-scrollbar{margin-left:calc(var(--editor-current-display-width-px) - var(--scrollbar-size))}.ScrollbarTool-overlay:not(.scrollbar-top) .horizontal-scrollbar{margin-top:calc(var(--editor-current-display-height-px) - var(--scrollbar-size))}.clipboard-error-dialog details>summary{cursor:pointer}.clipboard-error-dialog details[open]{margin-bottom:12px}.clipboard-error-dialog textarea{width:100%;box-sizing:border-box}.selection-tool-selection-background{background-color:var(--selection-background-color);opacity:.5;overflow:visible}.selection-tool-handle{position:absolute;box-sizing:border-box;display:flex;align-items:center;justify-content:center;--max-size: 17px}.selection-tool-handle .selection-tool-content{border:1px solid var(--foreground-color-1);background:var(--background-color-1);box-sizing:border-box;max-width:var(--max-size);max-height:var(--max-size);width:100%;height:100%;display:flex;justify-content:center;align-items:center;padding:3px}.selection-tool-handle .selection-tool-content .icon{width:100%;height:100%}.selection-tool-handle.selection-tool-circle .selection-tool-content{border-radius:100%}.selection-tool-handle.selection-tool-rotate{--max-size: 28px;cursor:grab}.selection-tool-handle.selection-tool-resize-x{cursor:ew-resize}.selection-tool-handle.selection-tool-resize-y{cursor:ns-resize}.selection-tool-handle.selection-tool-resize-xy{cursor:nwse-resize}.selection-tool-rotated-near-perpendicular .selection-tool-handle.selection-tool-resize-x{cursor:ns-resize}.selection-tool-rotated-near-perpendicular .selection-tool-handle.selection-tool-resize-y{cursor:ew-resize}.selection-tool-rotated-near-perpendicular .selection-tool-handle.selection-tool-resize-xy{cursor:nesw-resize}.selection-tool-selection-menu>button{max-height:var(--vertical-offset);background-color:var(--background-color-1);width:24px;height:24px;padding:6px;font-size:14px;user-select:none;-webkit-user-select:none;color:var(--foreground-color-1);border:.5px solid var(--foreground-color-1);border-radius:3px;opacity:.8;transition:.2s ease opacity}.selection-tool-selection-menu>button:hover,.selection-tool-selection-menu>button:focus-visible{background-color:var(--background-color-2);color:var(--foreground-color-2);cursor:pointer;opacity:1}.selection-tool-selection-menu>button>.icon{width:100%;height:100%}.overlay.handleOverlay{touch-action:none;direction:ltr}.overlay.handleOverlay,.overlay.handleOverlay .selection-tool-selection-outer-container{height:0;overflow:visible}.overlay.handleOverlay .selection-tool-selection-inner-container{width:var(--editor-current-display-width-px);height:var(--editor-current-display-height-px);overflow:hidden;pointer-events:none}.overlay.handleOverlay .selection-tool-selection-inner-container>*{pointer-events:all}.overlay.handleOverlay .selection-tool-selection-inner-container.-empty{opacity:0;display:none}.overlay.handleOverlay .selection-tool-selection-inner-container.-hide-handles .selection-tool-handle{display:none}@keyframes selection-duplicated-animation{0%{scale:1 1}50%{scale:1.02 1.02}100%{scale:1 1}}@media(prefers-reduced-motion: reduce){@keyframes selection-duplicated-animation{}}.find-tool-overlay{order:-1;position:absolute}.js-draw-sound-ui-toggle{width:0px;height:0px;overflow:hidden;user-select:none;-webkit-user-select:none}.js-draw-sound-ui-toggle button{margin-top:1px}.js-draw-sound-ui-toggle:focus-within,.js-draw-sound-ui-toggle.sound-ui-tool-enabled{overflow:visible;z-index:5}.js-draw-sound-ui-toggle:not(:focus-within):not(:hover).sound-ui-tool-enabled{opacity:.5}@keyframes show-popup-menu-animation{from{opacity:0}to{opacity:1}}.editor-popup-menu{width:100%;height:100%;background-color:rgba(0,0,0,0);border:none;animation:var(--hide-menu-animation-timeout) ease show-popup-menu-animation;opacity:1;transition:var(--hide-menu-animation-timeout) ease opacity;overflow:hidden}.editor-popup-menu.-hide{opacity:0}.editor-popup-menu>.content{position:absolute;left:var(--anchor-x);top:var(--anchor-y);display:flex;flex-direction:column;overflow:clip;border-radius:6px;box-shadow:0px 0px 2px var(--shadow-color);background-color:var(--background-color-1)}.editor-popup-menu::backdrop{background:rgba(0,0,0,0)}.editor-popup-menu-option{display:flex;justify-content:start;cursor:pointer;padding:5px;padding-top:6px;padding-bottom:6px;background-color:rgba(0,0,0,0);color:var(--foreground-color-1);--icon-color: currentColor;border:none;font-size:1em}.editor-popup-menu-option:hover,.editor-popup-menu-option:focus-visible{background-color:var(--background-color-2);color:var(--foreground-color-2)}.editor-popup-menu-option>:first-child{width:1em;height:1em;flex-shrink:0;align-self:center;margin-inline-start:0em;margin-inline-end:.32em}.about-dialog-content>.scroll{white-space:pre-wrap;font-family:monospace}.about-dialog-content>.scroll>details>summary{cursor:pointer}.about-dialog-content>.scroll>h2,.about-dialog-content>.scroll>details>summary{margin-top:15px;font-size:1.2em;font-weight:bold}.about-dialog-content>.scroll>h2 a,.about-dialog-content>.scroll>details>summary a{color:var(--foreground-color-1);text-decoration:underline}@keyframes fade-in{from{opacity:0}to{opacity:1}}.message-dialog-container dialog{display:flex}.message-dialog-container dialog.-closing{opacity:0}.message-dialog-container dialog.-closing::backdrop{opacity:0}.message-dialog-container dialog,.message-dialog-container dialog::backdrop{transition:opacity .2s ease;animation:fade-in .2s ease}.message-dialog-content{display:flex;flex-direction:column;flex-grow:1}.message-dialog-content>.close{display:block;margin-left:auto;margin-right:auto}.message-dialog-content>.scroll{flex-grow:1;flex-shrink:1;overflow-y:auto;margin-left:20px;margin-right:20px;padding-bottom:20px}.dialog-container>dialog{background-color:var(--background-color-1);color:var(--foreground-color-1);border:none;outline:none;box-shadow:0 0 2px var(--shadow-color);border-radius:8px;max-height:90vh;width:min(100%,500px);box-sizing:border-box}.dialog-container>dialog::backdrop{backdrop-filter:blur(5px);-webkit-backdrop-filter:blur(5px);background-color:var(--background-color-transparent)}#clr-picker{--clr-slider-size: 30px}#clr-picker #clr-color-area,#clr-picker .clr_hue{touch-action:none}#clr-picker .clr-alpha{margin-top:15px;margin-bottom:15px}#clr-picker.clr-picker input[type=range]::-moz-range-thumb{width:var(--clr-slider-size);height:var(--clr-slider-size)}#clr-picker.clr-picker input[type=range]::-webkit-slider-thumb{width:var(--clr-slider-size);height:var(--clr-slider-size)}#clr-picker.clr-picker input[type=range]::-webkit-slider-runnable-track{height:var(--clr-slider-size)}#clr-picker.clr-picker input[type=range]::-moz-range-track{height:var(--clr-slider-size)}.imageEditorContainer{--background-color-1: white;--foreground-color-1: black;--background-color-2: #f5f5f5;--foreground-color-2: #2c303a;--background-color-3: #e5e5e5;--foreground-color-3: #1c202a;--selection-background-color: #cbdaf1;--selection-foreground-color: #2c303a;--background-color-transparent: rgba(105, 100, 100, 0.5);--shadow-color: rgba(0, 0, 0, 0.5);--primary-action-foreground-color: #15b}@media(prefers-color-scheme: dark){.imageEditorContainer{--background-color-1: #151515;--foreground-color-1: white;--background-color-2: #222;--foreground-color-2: #efefef;--background-color-3: #272627;--foreground-color-3: #eee;--selection-background-color: #607;--selection-foreground-color: white;--shadow-color: rgba(250, 250, 250, 0.5);--background-color-transparent: rgba(50, 50, 50, 0.5);--primary-action-foreground-color: #7ae}}.imageEditorContainer{--icon-color: var(--foreground-color-1)}.imageEditorContainer{color:var(--foreground-color-1);font-family:system-ui,-apple-system,sans-serif;background-color:var(--background-color-1);width:100%;height:400px;min-height:220px;min-width:100px;writing-mode:horizontal-tb;box-sizing:border-box;display:flex;flex-direction:column-reverse}.imageEditorContainer input{accent-color:var(--primary-action-foreground-color)}.imageEditorContainer .imageEditorRenderArea{display:grid;grid-template-columns:1fr;flex-grow:2;flex-shrink:1;min-height:100px;min-width:0;width:100%;height:100%}.imageEditorContainer .imageEditorRenderArea canvas{grid-row:1/1;grid-column:1/1;touch-action:none;box-sizing:border-box;width:100%;height:100%;min-width:0;max-width:inherit;min-height:0px;max-height:inherit;user-select:none;-webkit-user-select:none;-webkit-user-drag:none}.imageEditorContainer .loadingMessage{position:fixed;text-align:center;font-size:2em;text-shadow:0px 0px 1px var(--background-color-1);bottom:0;left:0;right:0}.imageEditorContainer .accessibilityAnnouncement{opacity:0;width:0;height:0;overflow:hidden;pointer-events:none;user-select:none;-webkit-user-select:none}.imageEditorContainer .textRendererOutputContainer{width:.001px;height:.001px;overflow:hidden;-webkit-user-select:none;user-select:none}.imageEditorContainer .textRendererOutputContainer:focus-within{overflow:visible;z-index:5}.imageEditorContainer .anchored-element-overlay{overflow:visible;height:0}.imageEditorContainer .anchored-element-overlay>.content-wrapper{width:var(--editor-current-display-width-px);height:var(--editor-current-display-height-px);overflow:hidden;position:relative;pointer-events:none}.imageEditorContainer .anchored-element-overlay>.content-wrapper>.content{position:absolute;left:var(--position-x);top:var(--position-y);transform:scale(var(--scale)) rotate(var(--rotation));transform-origin:left top;margin:0;pointer-events:all}@media print{.imageEditorContainer .loadingMessage{display:none}.imageEditorContainer .imageEditorRenderArea canvas{width:100%;height:initial}}', document.head.appendChild(o);
      }
    })();
    (() => {
      if (typeof document < "u" && typeof document.createElement == "function") {
        let o = document.createElement("style");
        o.textContent = '.clr-picker{display:none;flex-wrap:wrap;position:absolute;width:200px;z-index:1000;border-radius:10px;background-color:#fff;justify-content:flex-end;direction:ltr;box-shadow:0 0 5px rgba(0, 0, 0, 0.05),0 5px 20px rgba(0, 0, 0, 0.1);-moz-user-select:none;-webkit-user-select:none;user-select:none}.clr-picker.clr-open,.clr-picker[data-inline=true]{display:flex}.clr-picker[data-inline=true]{position:relative}.clr-gradient{position:relative;width:100%;height:100px;margin-bottom:15px;border-radius:3px 3px 0 0;background-image:linear-gradient(rgba(0, 0, 0, 0), #000),linear-gradient(90deg, #fff, currentColor);cursor:pointer}.clr-marker{position:absolute;width:12px;height:12px;margin:-6px 0 0 -6px;border:1px solid #fff;border-radius:50%;background-color:currentColor;cursor:pointer}.clr-picker input[type=range]::-webkit-slider-runnable-track{width:100%;height:16px}.clr-picker input[type=range]::-webkit-slider-thumb{width:16px;height:16px;-webkit-appearance:none}.clr-picker input[type=range]::-moz-range-track{width:100%;height:16px;border:0}.clr-picker input[type=range]::-moz-range-thumb{width:16px;height:16px;border:0}.clr-hue{background-image:linear-gradient(to right, #f00 0%, #ff0 16.66%, #0f0 33.33%, #0ff 50%, #00f 66.66%, #f0f 83.33%, #f00 100%)}.clr-hue,.clr-alpha{position:relative;width:calc(100% - 40px);height:8px;margin:5px 20px;border-radius:4px}.clr-alpha span{display:block;height:100%;width:100%;border-radius:inherit;background-image:linear-gradient(90deg, rgba(0, 0, 0, 0), currentColor)}.clr-hue input,.clr-alpha input{position:absolute;width:calc(100% + 32px);height:16px;left:-16px;top:-4px;margin:0;background-color:transparent;opacity:0;cursor:pointer;appearance:none;-webkit-appearance:none}.clr-hue div,.clr-alpha div{position:absolute;width:16px;height:16px;left:0;top:50%;margin-left:-8px;transform:translateY(-50%);border:2px solid #fff;border-radius:50%;background-color:currentColor;box-shadow:0 0 1px #888;pointer-events:none}.clr-alpha div:before{content:"";position:absolute;height:100%;width:100%;left:0;top:0;border-radius:50%;background-color:currentColor}.clr-format{display:none;order:1;width:calc(100% - 40px);margin:0 20px 20px}.clr-segmented{display:flex;position:relative;width:100%;margin:0;padding:0;border:1px solid #ddd;border-radius:15px;box-sizing:border-box;color:#999;font-size:12px}.clr-segmented input,.clr-segmented legend{position:absolute;width:100%;height:100%;margin:0;padding:0;border:0;left:0;top:0;opacity:0;pointer-events:none}.clr-segmented label{flex-grow:1;margin:0;padding:4px 0;font-size:inherit;font-weight:normal;line-height:initial;text-align:center;cursor:pointer}.clr-segmented label:first-of-type{border-radius:10px 0 0 10px}.clr-segmented label:last-of-type{border-radius:0 10px 10px 0}.clr-segmented input:checked+label{color:#fff;background-color:#666}.clr-swatches{order:2;width:calc(100% - 32px);margin:0 16px}.clr-swatches div{display:flex;flex-wrap:wrap;padding-bottom:12px;justify-content:center}.clr-swatches button{position:relative;width:20px;height:20px;margin:0 4px 6px 4px;padding:0;border:0;border-radius:50%;color:inherit;text-indent:-1000px;white-space:nowrap;overflow:hidden;cursor:pointer}.clr-swatches button:after{content:"";display:block;position:absolute;width:100%;height:100%;left:0;top:0;border-radius:inherit;background-color:currentColor;box-shadow:inset 0 0 0 1px rgba(0, 0, 0, 0.1)}input.clr-color{order:1;width:calc(100% - 80px);height:32px;margin:15px 20px 20px auto;padding:0 10px;border:1px solid #ddd;border-radius:16px;color:#444;background-color:#fff;font-family:sans-serif;font-size:14px;text-align:center;box-shadow:none}input.clr-color:focus{outline:none;border:1px solid #1e90ff}.clr-close,.clr-clear{display:none;order:2;height:24px;margin:0 20px 20px;padding:0 20px;border:0;border-radius:12px;color:#fff;background-color:#666;font-family:inherit;font-size:12px;font-weight:400;cursor:pointer}.clr-close{display:block;margin:0 20px 20px auto}.clr-preview{position:relative;width:32px;height:32px;margin:15px 0 20px 20px;border-radius:50%;overflow:hidden}.clr-preview:before,.clr-preview:after{content:"";position:absolute;height:100%;width:100%;left:0;top:0;border:1px solid #fff;border-radius:50%}.clr-preview:after{border:0;background-color:currentColor;box-shadow:inset 0 0 0 1px rgba(0, 0, 0, 0.1)}.clr-preview button{position:absolute;width:100%;height:100%;z-index:1;margin:0;padding:0;border:0;border-radius:50%;outline-offset:-2px;background-color:transparent;text-indent:-9999px;cursor:pointer;overflow:hidden}.clr-marker,.clr-hue div,.clr-alpha div,.clr-color{box-sizing:border-box}.clr-field{display:inline-block;position:relative;color:transparent}.clr-field input{margin:0;direction:ltr}.clr-field.clr-rtl input{text-align:right}.clr-field button{position:absolute;width:30px;height:100%;right:0;top:50%;transform:translateY(-50%);margin:0;padding:0;border:0;color:inherit;text-indent:-1000px;white-space:nowrap;overflow:hidden;pointer-events:none}.clr-field.clr-rtl button{right:auto;left:0}.clr-field button:after{content:"";display:block;position:absolute;width:100%;height:100%;left:0;top:0;border-radius:inherit;background-color:currentColor;box-shadow:inset 0 0 1px rgba(0, 0, 0, 0.5)}.clr-alpha,.clr-alpha div,.clr-swatches button,.clr-preview:before,.clr-field button{background-image:repeating-linear-gradient(45deg, #aaa 25%, transparent 25%, transparent 75%, #aaa 75%, #aaa),repeating-linear-gradient(45deg, #aaa 25%, #fff 25%, #fff 75%, #aaa 75%, #aaa);background-position:0 0,4px 4px;background-size:8px 8px}.clr-marker:focus{outline:none}.clr-keyboard-nav .clr-marker:focus,.clr-keyboard-nav .clr-hue input:focus+div,.clr-keyboard-nav .clr-alpha input:focus+div,.clr-keyboard-nav .clr-segmented input:focus+label{outline:none;box-shadow:0 0 0 2px #1e90ff,0 0 2px 2px #fff}.clr-picker[data-alpha=false] .clr-alpha{display:none}.clr-picker[data-minimal=true]{padding-top:16px}.clr-picker[data-minimal=true] .clr-gradient,.clr-picker[data-minimal=true] .clr-hue,.clr-picker[data-minimal=true] .clr-alpha,.clr-picker[data-minimal=true] .clr-color,.clr-picker[data-minimal=true] .clr-preview{display:none}.clr-dark{background-color:#444}.clr-dark .clr-segmented{border-color:#777}.clr-dark .clr-swatches button:after{box-shadow:inset 0 0 0 1px rgba(255, 255, 255, 0.3)}.clr-dark input.clr-color{color:#fff;border-color:#777;background-color:#555}.clr-dark input.clr-color:focus{border-color:#1e90ff}.clr-dark .clr-preview:after{box-shadow:inset 0 0 0 1px rgba(255, 255, 255, 0.5)}.clr-dark .clr-alpha,.clr-dark .clr-alpha div,.clr-dark .clr-swatches button,.clr-dark .clr-preview:before{background-image:repeating-linear-gradient(45deg, #666 25%, transparent 25%, transparent 75%, #888 75%, #888),repeating-linear-gradient(45deg, #888 25%, #444 25%, #444 75%, #888 75%, #888)}.clr-picker.clr-polaroid{border-radius:6px;box-shadow:0 0 5px rgba(0, 0, 0, 0.1),0 5px 30px rgba(0, 0, 0, 0.2)}.clr-picker.clr-polaroid:before{content:"";display:block;position:absolute;width:16px;height:10px;left:20px;top:-10px;border:solid transparent;border-width:0 8px 10px 8px;border-bottom-color:currentColor;box-sizing:border-box;color:#fff;filter:drop-shadow(0 -4px 3px rgba(0, 0, 0, 0.1));pointer-events:none}.clr-picker.clr-polaroid.clr-dark:before{color:#444}.clr-picker.clr-polaroid.clr-left:before{left:auto;right:20px}.clr-picker.clr-polaroid.clr-top:before{top:auto;bottom:-10px;transform:rotateZ(180deg)}.clr-polaroid .clr-gradient{width:calc(100% - 20px);height:120px;margin:10px;border-radius:3px}.clr-polaroid .clr-hue,.clr-polaroid .clr-alpha{width:calc(100% - 30px);height:10px;margin:6px 15px;border-radius:5px}.clr-polaroid .clr-hue div,.clr-polaroid .clr-alpha div{box-shadow:0 0 5px rgba(0, 0, 0, 0.2)}.clr-polaroid .clr-format{width:calc(100% - 20px);margin:0 10px 15px}.clr-polaroid .clr-swatches{width:calc(100% - 12px);margin:0 6px}.clr-polaroid .clr-swatches div{padding-bottom:10px}.clr-polaroid .clr-swatches button{width:22px;height:22px}.clr-polaroid input.clr-color{width:calc(100% - 60px);margin:10px 10px 15px auto}.clr-polaroid .clr-clear{margin:0 10px 15px 10px}.clr-polaroid .clr-close{margin:0 10px 15px auto}.clr-polaroid .clr-preview{margin:10px 0 15px 10px}.clr-picker.clr-large{width:275px}.clr-large .clr-gradient{height:150px}.clr-large .clr-swatches button{width:22px;height:22px}.clr-picker.clr-pill{width:380px;padding-left:180px;box-sizing:border-box}.clr-pill .clr-gradient{position:absolute;width:180px;height:100%;left:0;top:0;margin-bottom:0;border-radius:3px 0 0 3px}.clr-pill .clr-hue{margin-top:20px}', document.head.appendChild(o);
      }
    })();
  })();

  // src/localization.ts
  var defaultStrings = {
    insertDrawing: "Insert Drawing",
    insertDrawingInNewWindow: "Insert drawing in new window",
    restoreFromAutosave: "Restore from autosaved drawing",
    deleteAutosave: "Delete all autosaved drawings",
    noSuchAutosaveExists: "No autosave exists",
    discardChanges: "Discard changes",
    defaultImageTitle: "Freehand Drawing",
    edit: "Edit",
    close: "Close",
    saveAndClose: "Save and close",
    overwriteExisting: "Overwrite existing",
    saveAsNewDrawing: "Save as a new drawing",
    clickBelowToContinue: "Done! Click below to continue.",
    discardUnsavedChanges: "Discard unsaved changes?",
    resumeEditing: "Resume editing",
    saveAndResumeEditing: "Save and resume editing",
    saveChanges: "Save changes",
    exitInstructions: "All changes saved! Click below to exit.",
    settingsPaneDescription: "Settings for the Freehand Drawing image editor.",
    setting__disableFullScreen: "Dialog mode",
    setting__disableFullScreenDescription: "Enabling this setting causes the editor to only partially fill the Joplin window.",
    setting__autosaveIntervalSettingLabel: "Autosave interval (minutes)",
    setting__autosaveIntervalSettingDescription: 'Adjusts how often a backup copy of the current drawing is created. The most recent autosave can be restored by searching for ":restore autosave" in the command palette (ctrl+shift+p or cmd+shift+p on MacOS) and clicking "Restore from autosaved drawing". If this setting is set to zero, autosaves are created every two minutes.',
    setting__themeLabel: "Theme",
    setting__toolbarTypeLabel: "Toolbar type",
    setting__toolbarTypeDescription: "This setting switches between possible toolbar user interfaces for the image editor.",
    setting__keyboardShortcuts: "Keyboard shortcuts",
    toolbarTypeDefault: "Default",
    toolbarTypeSidebar: "Sidebar",
    toolbarTypeDropdown: "Dropdown",
    styleMatchJoplin: "Match Joplin",
    styleJsDrawLight: "Light",
    styleJsDrawDark: "Dark",
    images: "Images",
    pdfs: "PDFs",
    allFiles: "All Files",
    loadLargePdf: (pageCount) => `A selected file is a large PDF (${pageCount} pages). Loading it may take some time and increase the size of the current drawing. Continue?`,
    notAnEditableImage: (resourceId, resourceType) => `Resource ${resourceId} is not an editable image. Unable to edit resource of type ${resourceType}.`
  };
  var localizations = {
    de: {
      insertDrawing: "Zeichnung einf\xFCgen",
      insertDrawingInNewWindow: "Zeichnung in neuem Fenster einf\xFCgen",
      restoreFromAutosave: "Automatische Sicherung wiederherstellen",
      deleteAutosave: "Alle automatischen Sicherungen l\xF6schen",
      noSuchAutosaveExists: "Keine automatischen Sicherungen vorhanden",
      discardChanges: "\xC4nderungen verwerfen",
      defaultImageTitle: "Freihand-Zeichnen",
      edit: "Bearbeiten",
      close: "Schlie\xDFen",
      saveAndClose: "Speichern und Schlie\xDFen",
      overwriteExisting: "Existierende Zeichnung \xFCberschreiben",
      saveAsNewDrawing: "Als neue Zeichnung speichern",
      clickBelowToContinue: "Fertig! Unten klicken, um fortzufahen.",
      discardUnsavedChanges: "Ungespeicherte \xC4nderungen verwerfen?",
      resumeEditing: "Weiter bearbeiten",
      saveAndResumeEditing: "Speichern und weiter bearbeiten",
      saveChanges: "\xC4nderungen speichern",
      exitInstructions: "Alle \xC4nderungen gespeichert! Unten klicken, um das Fenster zu schlie\xDFen.",
      settingsPaneDescription: "Einstellungen f\xFCr Freihand-Zeichnen.",
      setting__disableFullScreen: "Dialogmodus",
      setting__disableFullScreenDescription: "Wenn diese Einstellung aktiviert ist, f\xFCllt der Editor das Joplin-Fenster nur teilweise aus.",
      setting__autosaveIntervalSettingLabel: "Intervall f\xFCr die automatische Speicherung (Minuten)",
      setting__autosaveIntervalSettingDescription: "Legt fest, wie oft eine Sicherungskopie der aktuellen Zeichnung erstellt wird. Die letzte automatische Speicherung kann wiederhergestellt werden, indem du in der Befehlspalette (Strg+Umschalt+P oder Cmd+Umschalt+P unter MacOS) nach \u201E:restore autosave\u201C suchst und auf \u201EAutomatische Sicherung wiederherstellen\u201C klickst. Wenn diese Einstellung auf Null gesetzt ist, werden alle zwei Minuten automatische Speichervorg\xE4nge durchgef\xFChrt.",
      setting__themeLabel: "Design",
      setting__toolbarTypeLabel: "Toolbar-Typ",
      setting__toolbarTypeDescription: "Diese Einstellung wechselt zwischen den m\xF6glichen Benutzeroberfl\xE4chen der Symbolleiste f\xFCr den Bildeditor.",
      setting__keyboardShortcuts: "Tastaturk\xFCrzel",
      toolbarTypeDefault: "Standard",
      toolbarTypeSidebar: "Sidebar",
      toolbarTypeDropdown: "Dropdown-Men\xFC",
      styleMatchJoplin: "wie Joplin",
      styleJsDrawLight: "Hell",
      styleJsDrawDark: "Dunkel",
      images: "Bilder",
      pdfs: "PDFs",
      allFiles: "Alle Dateien",
      loadLargePdf: (pageCount) => `Die ausgew\xE4hlte Datei ist eine gro\xDFe PDF-Datei (mit ${pageCount} Seiten). Das Laden kann einige Zeit dauern und die Gr\xF6\xDFe der aktuellen Zeichnung erh\xF6hen. Fortfahren?`,
      notAnEditableImage: (resourceId, resourceType) => `Die Ressource ${resourceId} ist kein bearbeitbares Bild. Ressource vom Typ ${resourceType} kann nicht bearbeitet werden.`
    },
    en: defaultStrings,
    es: {
      insertDrawing: "A\xF1ada dibujo",
      restoreFromAutosave: "Resturar al autoguardado",
      deleteAutosave: "Borrar el autoguardado",
      noSuchAutosaveExists: "No autoguardado existe",
      discardChanges: "Descartar cambios",
      defaultImageTitle: "Dibujo",
      edit: "Editar",
      close: "Cerrar",
      saveAndClose: "Guardar y cerrar",
      overwriteExisting: "Sobrescribir existente",
      saveAsNewDrawing: "Guardar como dibujo nuevo",
      clickBelowToContinue: "Guardado. Ponga \xABok\xBB para continuar.",
      discardUnsavedChanges: "\xBFDescartar cambios no guardados?",
      resumeEditing: "Continuar editando",
      saveAndResumeEditing: "Guardar y continuar editando"
    },
    hr: {
      insertDrawing: "Umetni crte\u017E",
      insertDrawingInNewWindow: "Umetni crte\u017E u novom prozoru",
      restoreFromAutosave: "Obnovi iz automatski spremljenog crte\u017Ea",
      deleteAutosave: "Izbri\u0161i sve automatski spremljene crte\u017Ee",
      noSuchAutosaveExists: "Ne postoji automatski spremljeni crte\u017E",
      discardChanges: "Odbaci promjene",
      defaultImageTitle: "Prostoru\u010Dni crte\u017E",
      edit: "Uredi",
      close: "Zatvori",
      saveAndClose: "Spremi i zatvori",
      overwriteExisting: "Prepi\u0161i postoje\u0107e",
      saveAsNewDrawing: "Spremi kao novi crte\u017E",
      clickBelowToContinue: "Gotovo! Klikni dolje za nastavak.",
      discardUnsavedChanges: "Odbaciti nespremljene promjene?",
      resumeEditing: "Nastavi ure\u0111ivati",
      saveAndResumeEditing: "Spremi i nastavi ure\u0111ivati",
      saveChanges: "Spremi promjene",
      exitInstructions: "Sve promjene su spremljene! Klikni dolje za izlaz.",
      settingsPaneDescription: "Postavke ure\u0111iva\u010Da crte\u017Ea.",
      setting__disableFullScreen: "Modus dijaloga",
      setting__disableFullScreenDescription: "Uklju\u010Divanjem ove postavke \u0107e ure\u0111iva\u010D ispuniti samo dio Joplinovog prozora.",
      setting__autosaveIntervalSettingLabel: "Interval automatskog spremanja (minute)",
      setting__autosaveIntervalSettingDescription: "Prilago\u0111ava u\u010Destalost stvaranja sigurnosnih kopija trenuta\u010Dnog crte\u017Ea. Najnoviji automatski spremljeni crte\u017E se mo\u017Ee obnoviti pretra\u017Eivanjem \u201E:restore autosave\u201D u paleti naredbi (ctrl+shift+p ili cmd+shift+p na MacOS-u) i klikom na \u201EObnovi iz automatski spremljenog crte\u017Ea\u201D. Ako je ova postavka postavljena na nulu, automatska spremanja se izvode svake dvije minute.",
      setting__themeLabel: "Tema",
      setting__toolbarTypeLabel: "Vrsta alatne trake",
      setting__toolbarTypeDescription: "Ova postavka omogu\u0107uje prebacivanje izme\u0111u mogu\u0107ih korisni\u010Dkih su\u010Delja alatnih traka za ure\u0111iva\u010D slika.",
      setting__keyboardShortcuts: "Tipkovni pre\u010Daci",
      toolbarTypeDefault: "Zadano",
      toolbarTypeSidebar: "Bo\u010Dna traka",
      toolbarTypeDropdown: "Padaju\u0107i izbornik",
      styleMatchJoplin: "Uskladi s Joplinom",
      styleJsDrawLight: "Svijetla",
      styleJsDrawDark: "Tamna",
      images: "Slike",
      pdfs: "PDF-ovi",
      allFiles: "Sve datoteke",
      loadLargePdf: (pageCount) => `Jedna odabrana datoteka je veliki PDF (${pageCount} stranica). U\u010Ditavanje mo\u017Ee potrajati i pove\u0107ati veli\u010Dinu trenuta\u010Dnog crte\u017Ea. \u017Deli\u0161 li nastaviti?`,
      notAnEditableImage: (resourceId, resourceType) => `Resurs ${resourceId} nije slika koja se mo\u017Ee ure\u0111ivati. Nije mogu\u0107e urediti resurs vrste ${resourceType}.`
    },
    ro: {
      insertDrawing: "Insereaz\u0103 un desen",
      insertDrawingInNewWindow: "Insereaz\u0103 un desen \xEEntr-o fereastr\u0103 nou\u0103",
      restoreFromAutosave: "Restaureaz\u0103 dintr-un desen salvat automat",
      deleteAutosave: "\u0218terge toate desenele salvate automat",
      noSuchAutosaveExists: "Nicio salvare automat\u0103 nu exist\u0103",
      discardChanges: "Anuleaz\u0103 modific\u0103rile",
      defaultImageTitle: "Desen liber",
      edit: "Editeaz\u0103",
      close: "\xCEnchide",
      saveAndClose: "Salveaz\u0103 \u0219i \xEEnchide",
      overwriteExisting: "Suprascrie existent",
      saveAsNewDrawing: "Salveaz\u0103 ca desen nou",
      clickBelowToContinue: "Gata! F\u0103 clic mai jos pentru a continua.",
      discardUnsavedChanges: "Anulezi modific\u0103rile nesalvate?",
      resumeEditing: "Continu\u0103 editarea",
      saveAndResumeEditing: "Salveaz\u0103 \u0219i continu\u0103 editarea",
      saveChanges: "Salveaz\u0103 modific\u0103rile",
      exitInstructions: "Toate modific\u0103rile au fost salvate! F\u0103 clic mai jos pentru a ie\u0219i.",
      settingsPaneDescription: "Set\u0103ri pentru editorul de imagine liber.",
      setting__disableFullScreen: "Mod dialog",
      setting__disableFullScreenDescription: "Activarea acestei op\u021Biuni face ca editorul s\u0103 acopere doar par\u021Bial fereastra Joplin.",
      setting__autosaveIntervalSettingLabel: "Interval salvare automat\u0103 (minute)",
      setting__autosaveIntervalSettingDescription: 'Ajusteaz\u0103 c\xE2t de des se face o copie de siguran\u021B\u0103 a desenului curent. Cea mai recent\u0103 versiune salvat\u0103 automat poate fi restaurat\u0103 c\u0103ut\xE2nd dup\u0103 ":restore autosave" \xEEn paleta de comenzi (Ctrl+Shift+P sau Cmd+Shift+P pe MacOS) \u0219i f\u0103c\xE2nd clic pe \u201ERestaureaz\u0103 dintr-un desen salvat automat\u201D. Dac\u0103 acest\u0103 setare este 0, salv\u0103rile automate sunt create la fiecare 2 minute.',
      setting__themeLabel: "Tem\u0103",
      setting__toolbarTypeLabel: "Tip bar\u0103 de instrumente",
      setting__toolbarTypeDescription: "Aceast\u0103 setare comut\u0103 \xEEntre posibilele interfe\u021Be pentru editorul de imagine.",
      setting__keyboardShortcuts: "Scurt\u0103turi de la tastatur\u0103",
      toolbarTypeDefault: "Implicit",
      toolbarTypeSidebar: "Bar\u0103 lateral\u0103",
      toolbarTypeDropdown: "Casete derulante",
      styleMatchJoplin: "La fel ca Joplin",
      styleJsDrawLight: "Luminoas\u0103",
      styleJsDrawDark: "\xCEntunecat\u0103",
      images: "Imagini",
      pdfs: "PDF-uri",
      allFiles: "Toate fi\u0219ierele",
      loadLargePdf: (pageCount) => `Un fi\u0219ier PDF selectat este un fi\u0219ier mare (${pageCount} de pagini). \xCEnc\u0103rcarea lui ar putea dura ceva timp \u0219i s\u0103 creasc\u0103 dimensiunea desenului curent. Continui?`,
      notAnEditableImage: (resourceId, resourceType) => `Resursa ${resourceId} nu este o imagine editabil\u0103. Nu se poate edita resursa de tipul ${resourceType}.`
    },
    sk: {
      insertDrawing: "Vlo\u017Ei\u0165 kresbu",
      insertDrawingInNewWindow: "Vlo\u017Ei\u0165 kresbu do nov\xE9ho okna",
      restoreFromAutosave: "Obnovi\u0165 z automaticky ulo\u017Eenej kresby",
      deleteAutosave: "Vymaza\u0165 v\u0161etky automaticky ulo\u017Een\xE9 kresby",
      noSuchAutosaveExists: "Neexistuj\xFA \u017Eiadne automaticky ulo\u017Een\xE9",
      discardChanges: "Zru\u0161i\u0165 zmeny",
      defaultImageTitle: "Kresba vo\u013Enou rukou",
      edit: "Upravi\u0165",
      close: "Zavrie\u0165",
      saveAndClose: "Ulo\u017Ei\u0165 a zavrie\u0165",
      overwriteExisting: "Prep\xEDsa\u0165 existuj\xFAcu",
      saveAsNewDrawing: "Ulo\u017Ei\u0165 ako nov\xFA kresbu",
      clickBelowToContinue: "Hotovo! Kliknite ni\u017E\u0161ie pre pokra\u010Dovanie.",
      discardUnsavedChanges: "Zru\u0161i\u0165 neulo\u017Een\xE9 zmeny?",
      resumeEditing: "Pokra\u010Dova\u0165 v \xFAprave",
      saveAndResumeEditing: "Ulo\u017Ei\u0165 a pokra\u010Dova\u0165 v \xFAprav\xE1ch",
      saveChanges: "Ulo\u017Ei\u0165 zmeny",
      exitInstructions: "V\u0161etky zmeny boli ulo\u017Een\xE9! Kliknite ni\u017E\u0161ie pre ukon\u010Denie.",
      settingsPaneDescription: "Nastavenia pre grafick\xFD editor Kresba vo\u013Enou rukou.",
      setting__disableFullScreen: "Dial\xF3gov\xFD re\u017Eim",
      setting__disableFullScreenDescription: "Aktiv\xE1cia tohto nastavenia sp\xF4sob\xED, \u017Ee editor vypln\xED okno Joplin len \u010Diasto\u010Dne.",
      setting__autosaveIntervalSettingLabel: "Interval automatick\xE9ho ukladania (v min\xFAtach)",
      setting__autosaveIntervalSettingDescription: "Nastav\xED, ako \u010Dasto sa vytv\xE1ra z\xE1lo\u017En\xE1 k\xF3pia aktu\xE1lnej kresby. Posledn\xE9 automatick\xE9 ulo\u017Eenie je mo\u017En\xE9 obnovi\u0165 vyh\u013Eadan\xEDm \u201E:restore autosave\u201C v palete pr\xEDkazov (ctrl+shift+p alebo cmd+shift+p v syst\xE9me MacOS) a kliknut\xEDm na \u201EObnovi\u0165 z automaticky ulo\u017Eenej kresby\u201C. Ak je toto nastavenie nastaven\xE9 na nulu, automatick\xE9 ulo\u017Eenia sa vytv\xE1raj\xFA ka\u017Ed\xE9 dve min\xFAty.",
      setting__themeLabel: "T\xE9ma",
      setting__toolbarTypeLabel: "Typ panela n\xE1strojov",
      setting__toolbarTypeDescription: "Toto nastavenie prep\xEDna medzi mo\u017En\xFDmi pou\u017E\xEDvate\u013Esk\xFDmi rozhraniami panela n\xE1strojov pre grafick\xFD editor.",
      setting__keyboardShortcuts: "Kl\xE1vesov\xE9 skratky",
      toolbarTypeDefault: "Predvolen\xE9",
      toolbarTypeSidebar: "Bo\u010Dn\xFD panel",
      toolbarTypeDropdown: "Rozba\u013Eovacie menu",
      styleMatchJoplin: "Rovnak\xE1 ako Joplin",
      styleJsDrawLight: "Svetl\xE1",
      styleJsDrawDark: "Tmav\xE1",
      images: "Obr\xE1zky",
      pdfs: "PDF s\xFAbory",
      allFiles: "V\u0161etky s\xFAbory",
      loadLargePdf: (pageCount) => `Vybran\xFD s\xFAbor je ve\u013Ek\xFD PDF s\xFAbor (${pageCount} str\xE1n). Jeho na\u010D\xEDtanie m\xF4\u017Ee trva\u0165 nejak\xFD \u010Das a zv\xFD\u0161i\u0165 ve\u013Ekos\u0165 aktu\xE1lnej kresby. Pokra\u010Dova\u0165?`,
      notAnEditableImage: (resourceId, resourceType) => `Zdroj ${resourceId} nie je upravite\u013En\xFD obr\xE1zok. Nie je mo\u017En\xE9 upravi\u0165 zdroj typu ${resourceType}.`
    }
  };
  var localization;
  var supportedLanguages = [];
  var setLocaleInternal = (supportedLocales) => {
    const languages = [...supportedLocales];
    for (let language of supportedLocales) {
      language = language.replace("_", "-");
      const localeSep = language.indexOf("-");
      if (localeSep !== -1) {
        languages.push(language.substring(0, localeSep));
      }
    }
    for (const locale of languages) {
      if (locale in localizations) {
        localization = localizations[locale];
        break;
      }
    }
    supportedLanguages = languages;
  };
  var localizationSet = false;
  var setLocale = (supportedLocales) => {
    if (typeof supportedLocales === "string") {
      supportedLocales = [supportedLocales];
    }
    setLocaleInternal(supportedLocales);
    localizationSet = true;
  };
  setLocale(navigator.languages);
  var getLocales = () => {
    return [...supportedLanguages];
  };
  var localization_default = new Proxy(defaultStrings, {
    get(_target, prop) {
      if (!localizationSet) {
        console.warn(
          "Accessing language data without a localization set. The default Electron locale will be used."
        );
      }
      const propAsKey = prop;
      return localization?.[propAsKey] ?? defaultStrings[propAsKey];
    }
  });

  // src/dialog/webview/setUpLocalization.ts
  var getLocaleInfo = () => {
    const localeInfoFromElement = document.querySelector(
      "input#default-locale-data"
    )?.value;
    return localeInfoFromElement;
  };
  (() => {
    let localeInfo = getLocaleInfo();
    if (!localeInfo) {
      console.warn("Locale information not found");
      localeInfo = "unknown";
    }
    setLocale([localeInfo, ...navigator.languages]);
  })();

  // src/util/htmlUtil.ts
  var escapeHtml = (html) => {
    return html.replace(/[&]/g, "&amp;").replace(/[<]/g, "&lt;").replace(/[>]/g, "&gt;").replace(/["]/g, "&quot;").replace(/[']/g, "&#39;");
  };

  // src/dialog/webview/svgElementToString.ts
  var svgElementToString = (element) => {
    const svgText = ["<svg"];
    for (const attr of element.getAttributeNames()) {
      svgText.push(` ${attr}="${escapeHtml(element.getAttribute(attr))}"`);
    }
    svgText.push(">");
    svgText.push(element.innerHTML);
    svgText.push("</svg>");
    return svgText.join("");
  };
  var svgElementToString_default = svgElementToString;

  // src/dialog/webview/startAutosaveLoop.ts
  var startAutosaveLoop = async (editor, delayBetweenInMS, postMessage) => {
    while (true) {
      await new Promise((resolve) => {
        setTimeout(resolve, delayBetweenInMS);
      });
      const savedImage = await editor.toSVGAsync();
      await postMessage({
        type: "autosaveSVG" /* AutosaveSVG */,
        data: svgElementToString_default(savedImage)
      });
    }
  };
  var startAutosaveLoop_default = startAutosaveLoop;

  // node_modules/js-draw/dist/mjs/commands/Command.mjs
  var Command = class _Command {
    // Called when the command is being deleted
    onDrop(_editor) {
    }
    /** @deprecated Use {@link uniteCommands} */
    static union(a, b) {
      return new class extends _Command {
        apply(editor) {
          a.apply(editor);
          b.apply(editor);
        }
        unapply(editor) {
          b.unapply(editor);
          a.unapply(editor);
        }
        description(editor, localizationTable) {
          const aDescription = a.description(editor, localizationTable);
          const bDescription = b.description(editor, localizationTable);
          if (aDescription === bDescription) {
            return aDescription;
          }
          return `${aDescription}, ${bDescription}`;
        }
      }();
    }
  };
  Command.empty = new class extends Command {
    description(_editor, _localizationTable) {
      return "";
    }
    apply(_editor) {
    }
    unapply(_editor) {
    }
  }();
  var Command_default = Command;

  // node_modules/@js-draw/math/dist/mjs/Vec3.mjs
  var defaultEqlTolerance = 1e-10;
  var Vec3Impl = class {
    constructor(x, y, z) {
      this.x = x;
      this.y = y;
      this.z = z;
    }
    get xy() {
      return {
        x: this.x,
        y: this.y
      };
    }
    /** Returns this' `idx`th component. For example, `Vec3.of(1, 2, 3).at(1)  2`. */
    at(idx) {
      if (idx === 0)
        return this.x;
      if (idx === 1)
        return this.y;
      if (idx === 2)
        return this.z;
      throw new Error(`${idx} out of bounds!`);
    }
    length() {
      return this.magnitude();
    }
    magnitude() {
      return Math.sqrt(this.magnitudeSquared());
    }
    magnitudeSquared() {
      return this.x * this.x + this.y * this.y + this.z * this.z;
    }
    squareDistanceTo(p) {
      const dx = this.x - p.x;
      const dy = this.y - p.y;
      const dz = this.z - p.z;
      return dx * dx + dy * dy + dz * dz;
    }
    distanceTo(p) {
      return Math.sqrt(this.squareDistanceTo(p));
    }
    maximumEntryMagnitude() {
      return Math.max(Math.abs(this.x), Math.max(Math.abs(this.y), Math.abs(this.z)));
    }
    angle() {
      return Math.atan2(this.y, this.x);
    }
    normalized() {
      const norm = this.magnitude();
      return Vec3.of(this.x / norm, this.y / norm, this.z / norm);
    }
    normalizedOrZero() {
      if (this.eq(Vec3.zero)) {
        return Vec3.zero;
      }
      return this.normalized();
    }
    times(c) {
      return Vec3.of(this.x * c, this.y * c, this.z * c);
    }
    plus(v) {
      return Vec3.of(this.x + v.x, this.y + v.y, this.z + v.z);
    }
    minus(v) {
      return Vec3.of(this.x - v.x, this.y - v.y, this.z - v.z);
    }
    dot(other) {
      return this.x * other.x + this.y * other.y + this.z * other.z;
    }
    cross(other) {
      return Vec3.of(this.y * other.z - other.y * this.z, other.x * this.z - this.x * other.z, this.x * other.y - other.x * this.y);
    }
    scale(other) {
      if (typeof other === "number") {
        return this.times(other);
      }
      return Vec3.of(this.x * other.x, this.y * other.y, this.z * other.z);
    }
    orthog() {
      if (this.dot(Vec3.unitX) === 0 && this.dot(Vec3.unitY) === 0) {
        return this.dot(Vec3.unitX) === 0 ? Vec3.unitX : this.cross(Vec3.unitX).normalized();
      }
      return this.cross(Vec3.unitZ.times(-1)).normalized();
    }
    extend(distance, direction) {
      return this.plus(direction.normalized().times(distance));
    }
    lerp(target, fractionTo) {
      return this.times(1 - fractionTo).plus(target.times(fractionTo));
    }
    zip(other, zip) {
      return Vec3.of(zip(other.x, this.x), zip(other.y, this.y), zip(other.z, this.z));
    }
    map(fn) {
      return Vec3.of(fn(this.x, 0), fn(this.y, 1), fn(this.z, 2));
    }
    asArray() {
      return [this.x, this.y, this.z];
    }
    eq(other, fuzz = defaultEqlTolerance) {
      return Math.abs(other.x - this.x) <= fuzz && Math.abs(other.y - this.y) <= fuzz && Math.abs(other.z - this.z) <= fuzz;
    }
    toString() {
      return `Vec(${this.x}, ${this.y}, ${this.z})`;
    }
  };
  var Vec2Impl = class {
    constructor(x, y) {
      this.x = x;
      this.y = y;
    }
    get z() {
      return 0;
    }
    get xy() {
      return {
        x: this.x,
        y: this.y
      };
    }
    at(idx) {
      if (idx === 0)
        return this.x;
      if (idx === 1)
        return this.y;
      if (idx === 2)
        return 0;
      throw new Error(`${idx} out of bounds!`);
    }
    length() {
      return this.magnitude();
    }
    magnitude() {
      return Math.sqrt(this.x * this.x + this.y * this.y);
    }
    magnitudeSquared() {
      return this.x * this.x + this.y * this.y;
    }
    squareDistanceTo(p) {
      const dx = this.x - p.x;
      const dy = this.y - p.y;
      return dx * dx + dy * dy + p.z * p.z;
    }
    distanceTo(p) {
      return Math.sqrt(this.squareDistanceTo(p));
    }
    maximumEntryMagnitude() {
      return Math.max(Math.abs(this.x), Math.abs(this.y));
    }
    angle() {
      return Math.atan2(this.y, this.x);
    }
    normalized() {
      const norm = this.magnitude();
      return Vec2.of(this.x / norm, this.y / norm);
    }
    normalizedOrZero() {
      if (this.eq(Vec3.zero)) {
        return Vec3.zero;
      }
      return this.normalized();
    }
    times(c) {
      return Vec2.of(this.x * c, this.y * c);
    }
    plus(v) {
      return Vec3.of(this.x + v.x, this.y + v.y, v.z);
    }
    minus(v) {
      return Vec3.of(this.x - v.x, this.y - v.y, -v.z);
    }
    dot(other) {
      return this.x * other.x + this.y * other.y;
    }
    cross(other) {
      return Vec3.of(this.y * other.z, -this.x * other.z, this.x * other.y - other.x * this.y);
    }
    scale(other) {
      if (typeof other === "number") {
        return this.times(other);
      }
      return Vec2.of(this.x * other.x, this.y * other.y);
    }
    orthog() {
      if (this.dot(Vec3.unitX) === 0 && this.dot(Vec3.unitY) === 0) {
        return this.dot(Vec3.unitX) === 0 ? Vec3.unitX : this.cross(Vec3.unitX).normalized();
      }
      return this.cross(Vec3.unitZ.times(-1)).normalized();
    }
    extend(distance, direction) {
      return this.plus(direction.normalized().times(distance));
    }
    lerp(target, fractionTo) {
      return this.times(1 - fractionTo).plus(target.times(fractionTo));
    }
    zip(other, zip) {
      return Vec3.of(zip(other.x, this.x), zip(other.y, this.y), zip(other.z, 0));
    }
    map(fn) {
      return Vec3.of(fn(this.x, 0), fn(this.y, 1), fn(0, 2));
    }
    asArray() {
      return [this.x, this.y, 0];
    }
    eq(other, fuzz = defaultEqlTolerance) {
      return Math.abs(other.x - this.x) <= fuzz && Math.abs(other.y - this.y) <= fuzz && Math.abs(other.z) <= fuzz;
    }
    toString() {
      return `Vec(${this.x}, ${this.y})`;
    }
  };
  var Vec2;
  (function(Vec22) {
    Vec22.of = (x, y) => {
      return new Vec2Impl(x, y);
    };
    Vec22.ofXY = ({ x, y }) => {
      return Vec22.of(x, y);
    };
    Vec22.unitX = Vec22.of(1, 0);
    Vec22.unitY = Vec22.of(0, 1);
    Vec22.zero = Vec22.of(0, 0);
  })(Vec2 || (Vec2 = {}));
  var Vec3;
  (function(Vec32) {
    Vec32.of = (x, y, z) => {
      if (z === 0) {
        return Vec2.of(x, y);
      } else {
        return new Vec3Impl(x, y, z);
      }
    };
    Vec32.unitX = Vec2.unitX;
    Vec32.unitY = Vec2.unitY;
    Vec32.zero = Vec2.zero;
    Vec32.unitZ = Vec32.of(0, 0, 1);
  })(Vec3 || (Vec3 = {}));
  var Vec3_default = Vec3;

  // node_modules/@js-draw/math/dist/mjs/Mat33.mjs
  var Mat33 = class _Mat33 {
    /**
     * Creates a matrix from inputs in the form,
     * $$
     * \begin{bmatrix}
     *   a1 & a2 & a3 \\
     *   b1 & b2 & b3 \\
     *   c1 & c2 & c3
     * \end{bmatrix}
     * $$
     *
     * Static constructor methods are also available.
     * See {@link Mat33.scaling2D}, {@link Mat33.zRotation}, {@link Mat33.translation}, and {@link Mat33.fromCSSMatrix}.
     */
    constructor(a1, a2, a3, b1, b2, b3, c1, c2, c3) {
      this.a1 = a1;
      this.a2 = a2;
      this.a3 = a3;
      this.b1 = b1;
      this.b2 = b2;
      this.b3 = b3;
      this.c1 = c1;
      this.c2 = c2;
      this.c3 = c3;
      this.cachedInverse = void 0;
      this.rows = [Vec3_default.of(a1, a2, a3), Vec3_default.of(b1, b2, b3), Vec3_default.of(c1, c2, c3)];
    }
    /**
     * Creates a matrix from the given rows:
     * $$
     * \begin{bmatrix}
     *  \texttt{r1.x} & \texttt{r1.y} & \texttt{r1.z}\\
     *  \texttt{r2.x} & \texttt{r2.y} & \texttt{r2.z}\\
     *  \texttt{r3.x} & \texttt{r3.y} & \texttt{r3.z}\\
     * \end{bmatrix}
     * $$
     */
    static ofRows(r1, r2, r3) {
      return new _Mat33(r1.x, r1.y, r1.z, r2.x, r2.y, r2.z, r3.x, r3.y, r3.z);
    }
    /**
     * Either returns the inverse of this, or, if this matrix is singular/uninvertable,
     * returns Mat33.identity.
     *
     * This may cache the computed inverse and return the cached version instead of recomputing
     * it.
     */
    inverse() {
      return this.computeInverse() ?? _Mat33.identity;
    }
    invertable() {
      return this.computeInverse() !== null;
    }
    computeInverse() {
      if (this.cachedInverse !== void 0) {
        return this.cachedInverse;
      }
      const toIdentity = [this.rows[0], this.rows[1], this.rows[2]];
      const toResult = [Vec3_default.unitX, Vec3_default.unitY, Vec3_default.unitZ];
      for (let cursor = 0; cursor < 3; cursor++) {
        let pivot = toIdentity[cursor].at(cursor);
        const minDivideBy = 1e-10;
        if (Math.abs(pivot) < minDivideBy) {
          let swapIndex = -1;
          for (let i = 1; i <= 2; i++) {
            const otherRowIdx = (cursor + i) % 3;
            if (Math.abs(toIdentity[otherRowIdx].at(cursor)) >= minDivideBy) {
              swapIndex = otherRowIdx;
              break;
            }
          }
          if (swapIndex === -1) {
            this.cachedInverse = null;
            return null;
          }
          const tmpIdentityRow = toIdentity[cursor];
          const tmpResultRow = toResult[cursor];
          toIdentity[cursor] = toIdentity[swapIndex];
          toResult[cursor] = toResult[swapIndex];
          toIdentity[swapIndex] = tmpIdentityRow;
          toResult[swapIndex] = tmpResultRow;
          pivot = toIdentity[cursor].at(cursor);
        }
        let scale = 1 / pivot;
        toIdentity[cursor] = toIdentity[cursor].times(scale);
        toResult[cursor] = toResult[cursor].times(scale);
        const cursorToIdentityRow = toIdentity[cursor];
        const cursorToResultRow = toResult[cursor];
        for (let i = 1; i <= 2; i++) {
          const otherRowIdx = (cursor + i) % 3;
          scale = -toIdentity[otherRowIdx].at(cursor);
          toIdentity[otherRowIdx] = toIdentity[otherRowIdx].plus(cursorToIdentityRow.times(scale));
          toResult[otherRowIdx] = toResult[otherRowIdx].plus(cursorToResultRow.times(scale));
        }
      }
      const inverse = _Mat33.ofRows(toResult[0], toResult[1], toResult[2]);
      this.cachedInverse = inverse;
      return inverse;
    }
    transposed() {
      return new _Mat33(this.a1, this.b1, this.c1, this.a2, this.b2, this.c2, this.a3, this.b3, this.c3);
    }
    /**
     * [Right-multiplies](https://en.wikipedia.org/wiki/Matrix_multiplication) this by `other`.
     *
     * See also {@link transformVec3} and {@link transformVec2}.
     *
     * Example:
     * ```ts,runnable,console
     * import {Mat33, Vec2} from '@js-draw/math';
     * console.log(Mat33.identity.rightMul(Mat33.identity));
     *
     * // Create a matrix by right multiplying.
     * const scaleThenRotate =
     *   // The resultant matrix first scales by a factor of two
     *   Mat33.scaling2D(2).rightMul(
     *     // ...then rotates by pi/4 radians = 45 degrees.
     *     Mat33.zRotation(Math.PI / 4)
     *   );
     * console.log(scaleThenRotate);
     *
     * // Use scaleThenRotate to scale then rotate a vector.
     * console.log(scaleThenRotate.transformVec2(Vec2.unitX));
     * ```
     */
    rightMul(other) {
      other = other.transposed();
      const at = (row, col) => {
        return this.rows[row].dot(other.rows[col]);
      };
      return new _Mat33(at(0, 0), at(0, 1), at(0, 2), at(1, 0), at(1, 1), at(1, 2), at(2, 0), at(2, 1), at(2, 2));
    }
    /**
     * Applies this as an **affine** transformation to the given vector.
     * Returns a transformed version of `other`.
     *
     * Unlike {@link transformVec3}, this **does** translate the given vector.
     */
    transformVec2(other) {
      let intermediate = Vec3_default.of(other.x, other.y, 1);
      intermediate = this.transformVec3(intermediate);
      return Vec2.of(intermediate.x, intermediate.y);
    }
    /**
     * Applies this as a linear transformation to the given vector (doesn't translate).
     * This is the standard way of transforming vectors in .
     */
    transformVec3(other) {
      return Vec3_default.of(this.rows[0].dot(other), this.rows[1].dot(other), this.rows[2].dot(other));
    }
    /** @returns true iff this is the identity matrix. */
    isIdentity() {
      if (this === _Mat33.identity) {
        return true;
      }
      return this.eq(_Mat33.identity);
    }
    /** Returns true iff this = other  fuzz */
    eq(other, fuzz = 0) {
      for (let i = 0; i < 3; i++) {
        if (!this.rows[i].eq(other.rows[i], fuzz)) {
          return false;
        }
      }
      return true;
    }
    /**
     * Creates a human-readable representation of the matrix.
     *
     * Example:
     * ```ts,runnable,console
     * import { Mat33 } from '@js-draw/math';
     * console.log(Mat33.identity.toString());
     * ```
     */
    toString() {
      let result = "";
      const maxColumnLens = [0, 0, 0];
      for (const row of this.rows) {
        for (let i = 0; i < 3; i++) {
          maxColumnLens[i] = Math.max(maxColumnLens[0], `${row.at(i)}`.length);
        }
      }
      for (let i = 0; i < 3; i++) {
        if (i === 0) {
          result += "\u23A1 ";
        } else if (i === 1) {
          result += "\u23A2 ";
        } else {
          result += "\u23A3 ";
        }
        for (let j = 0; j < 3; j++) {
          const val = this.rows[i].at(j).toString();
          let padding = "";
          for (let i2 = val.length; i2 < maxColumnLens[j]; i2++) {
            padding += " ";
          }
          result += val + ", " + padding;
        }
        if (i === 0) {
          result += " \u23A4";
        } else if (i === 1) {
          result += " \u23A5";
        } else {
          result += " \u23A6";
        }
        result += "\n";
      }
      return result.trimEnd();
    }
    /**
     * ```
     * result[0] = top left element
     * result[1] = element at row zero, column 1
     * ...
     * ```
     *
     * Example:
     * ```ts,runnable,console
     * import { Mat33 } from '@js-draw/math';
     * console.log(
     *   new Mat33(
     *     1, 2, 3,
     *     4, 5, 6,
     *     7, 8, 9,
     *   )
     * );
     * ```
     */
    toArray() {
      return [this.a1, this.a2, this.a3, this.b1, this.b2, this.b3, this.c1, this.c2, this.c3];
    }
    /**
     * Returns a new `Mat33` where each entry is the output of the function
     * `mapping`.
     *
     * @example
     * ```
     * new Mat33(
     *  1, 2, 3,
     *  4, 5, 6,
     *  7, 8, 9,
     * ).mapEntries(component => component - 1);
     * //   0, 1, 2 
     * //    3, 4, 5 
     * //    6, 7, 8 
     * ```
     */
    mapEntries(mapping) {
      return new _Mat33(mapping(this.a1, [0, 0]), mapping(this.a2, [0, 1]), mapping(this.a3, [0, 2]), mapping(this.b1, [1, 0]), mapping(this.b2, [1, 1]), mapping(this.b3, [1, 2]), mapping(this.c1, [2, 0]), mapping(this.c2, [2, 1]), mapping(this.c3, [2, 2]));
    }
    /** Estimate the scale factor of this matrix (based on the first row). */
    getScaleFactor() {
      return Math.hypot(this.a1, this.a2);
    }
    /** Returns the `idx`-th column (`idx` is 0-indexed). */
    getColumn(idx) {
      return Vec3_default.of(this.rows[0].at(idx), this.rows[1].at(idx), this.rows[2].at(idx));
    }
    /** Returns the magnitude of the entry with the largest entry */
    maximumEntryMagnitude() {
      let greatestSoFar = Math.abs(this.a1);
      for (const entry of this.toArray()) {
        greatestSoFar = Math.max(greatestSoFar, Math.abs(entry));
      }
      return greatestSoFar;
    }
    /**
     * Constructs a 3x3 translation matrix (for translating `Vec2`s) using
     * **transformVec2**.
     *
     * Creates a matrix in the form
     * $$
     * 	\begin{pmatrix}
     * 		1 & 0 & {\tt amount.x}\\
     * 		0 & 1 & {\tt amount.y}\\
     * 		0 & 0 & 1
     * 	\end{pmatrix}
     * $$
     */
    static translation(amount) {
      return new _Mat33(1, 0, amount.x, 0, 1, amount.y, 0, 0, 1);
    }
    /**
     * Creates a matrix for rotating `Vec2`s about `center` by some number of `radians`.
     *
     * For this function, {@link Vec2}s are considered to be points in 2D space.
     *
     * For example,
     * ```ts,runnable,console
     * import { Mat33, Vec2 } from '@js-draw/math';
     *
     * const halfCircle = Math.PI; // PI radians = 180 degrees = 1/2 circle
     * const center = Vec2.of(1, 1); // The point (1,1)
     * const rotationMatrix = Mat33.zRotation(halfCircle, center);
     *
     * console.log(
     *   'Rotating (0,0) 180deg about', center, 'results in',
     *   // Rotates (0,0)
     *   rotationMatrix.transformVec2(Vec2.zero),
     * );
     * ```
     */
    static zRotation(radians, center = Vec2.zero) {
      if (radians === 0) {
        return _Mat33.identity;
      }
      const cos3 = Math.cos(radians);
      const sin3 = Math.sin(radians);
      let result = _Mat33.translation(center);
      result = result.rightMul(new _Mat33(cos3, -sin3, 0, sin3, cos3, 0, 0, 0, 1));
      return result.rightMul(_Mat33.translation(center.times(-1)));
    }
    static scaling2D(amount, center = Vec2.zero) {
      let result = _Mat33.translation(center);
      let xAmount, yAmount;
      if (typeof amount === "number") {
        xAmount = amount;
        yAmount = amount;
      } else {
        xAmount = amount.x;
        yAmount = amount.y;
      }
      result = result.rightMul(new _Mat33(xAmount, 0, 0, 0, yAmount, 0, 0, 0, 1));
      return result.rightMul(_Mat33.translation(center.times(-1)));
    }
    /**
     * **Note**: Assumes `this.c1 = this.c2 = 0` and `this.c3 = 1`.
     *
     * @see {@link fromCSSMatrix}
     */
    toCSSMatrix() {
      return `matrix(${this.a1},${this.b1},${this.a2},${this.b2},${this.a3},${this.b3})`;
    }
    /**
     * Converts a CSS-form `matrix(a, b, c, d, e, f)` to a Mat33.
     *
     * Note that such a matrix has the form,
     * ```
     *  a c e 
     *  b d f 
     *  0 0 1 
     * ```
     */
    static fromCSSMatrix(cssString) {
      if (cssString === "" || cssString === "none") {
        return _Mat33.identity;
      }
      cssString = cssString.trim().replace(/\s+/g, " ");
      const parseArguments = (argumentString) => {
        const parsed = argumentString.split(/[, \t\n]+/g).map((argString) => {
          if (argString.trim() === "") {
            return null;
          }
          let isPercentage = false;
          if (argString.endsWith("%")) {
            isPercentage = true;
            argString = argString.substring(0, argString.length - 1);
          }
          argString = argString.replace(/px$/gi, "");
          const numberExp = /^[-]?\d*(?:\.\d*)?(?:[eE][-+]?\d+)?$/i;
          if (!numberExp.exec(argString)) {
            throw new Error(`All arguments to transform functions must be numeric (state: ${JSON.stringify({
              currentArgument: argString,
              allArguments: argumentString
            })})`);
          }
          let argNumber = parseFloat(argString);
          if (isPercentage) {
            argNumber /= 100;
          }
          return argNumber;
        });
        return parsed.filter((n) => n !== null);
      };
      const keywordToAction = {
        matrix: (matrixData) => {
          if (matrixData.length !== 6) {
            throw new Error(`Invalid matrix argument: ${matrixData}. Must have length 6`);
          }
          const a = matrixData[0];
          const b = matrixData[1];
          const c = matrixData[2];
          const d = matrixData[3];
          const e = matrixData[4];
          const f = matrixData[5];
          const transform = new _Mat33(a, c, e, b, d, f, 0, 0, 1);
          return transform;
        },
        scale: (scaleArgs) => {
          let scaleX, scaleY;
          if (scaleArgs.length === 1) {
            scaleX = scaleArgs[0];
            scaleY = scaleArgs[0];
          } else if (scaleArgs.length === 2) {
            scaleX = scaleArgs[0];
            scaleY = scaleArgs[1];
          } else {
            throw new Error(`The scale() function only supports two arguments. Given: ${scaleArgs}`);
          }
          return _Mat33.scaling2D(Vec2.of(scaleX, scaleY));
        },
        translate: (translateArgs) => {
          let translateX = 0;
          let translateY = 0;
          if (translateArgs.length === 1) {
            translateX = translateArgs[0];
          } else if (translateArgs.length === 2) {
            translateX = translateArgs[0];
            translateY = translateArgs[1];
          } else {
            throw new Error(`The translate() function requires either 1 or 2 arguments. Given ${translateArgs}`);
          }
          return _Mat33.translation(Vec2.of(translateX, translateY));
        }
      };
      const partRegex = /(?:^|\W)(\w+)\s?\(([^)]*)\)/gi;
      let match;
      let matrix = null;
      while ((match = partRegex.exec(cssString)) !== null) {
        const action = match[1].toLowerCase();
        if (!(action in keywordToAction)) {
          throw new Error(`Unsupported CSS transform action: ${action}`);
        }
        const args = parseArguments(match[2]);
        const currentMatrix = keywordToAction[action](args);
        if (!matrix) {
          matrix = currentMatrix;
        } else {
          matrix = matrix.rightMul(currentMatrix);
        }
      }
      return matrix ?? _Mat33.identity;
    }
  };
  Mat33.identity = new Mat33(1, 0, 0, 0, 1, 0, 0, 0, 1);
  var Mat33_default = Mat33;

  // node_modules/@js-draw/math/dist/mjs/shapes/Abstract2DShape.mjs
  var Abstract2DShape = class _Abstract2DShape {
    /**
     * @returns the distance from `point` to this shape. If `point` is within this shape,
     * this returns the distance from `point` to the edge of this shape.
     *
     * @see {@link signedDistance}
     */
    distance(point) {
      return Math.abs(this.signedDistance(point));
    }
    /**
     * Returns `true` if and only if the given `point` is contained within this shape.
     *
     * `epsilon` is a small number used to counteract floating point error. Thus, if
     * `point` is within `epsilon` of the inside of this shape, `containsPoint` may also
     * return `true`.
     *
     * The default implementation relies on `signedDistance`.
     * Subclasses may override this method to provide a more efficient implementation.
     */
    containsPoint(point, epsilon2 = _Abstract2DShape.smallValue) {
      return this.signedDistance(point) < epsilon2;
    }
    /**
     * Returns a bounding box that **loosely** fits the content of this shape.
     *
     * The result of this call can be larger than the result of {@link getTightBoundingBox},
     * **but should not be smaller**. Thus, a call to `getLooseBoundingBox` can be significantly
     * faster than a call to {@link getTightBoundingBox} for some shapes.
     */
    getLooseBoundingBox() {
      return this.getTightBoundingBox();
    }
  };
  Abstract2DShape.smallValue = 1e-12;
  var Abstract2DShape_default = Abstract2DShape;

  // node_modules/@js-draw/math/dist/mjs/shapes/Rect2.mjs
  var Rect2 = class _Rect2 extends Abstract2DShape_default {
    constructor(x, y, w, h) {
      super();
      this.x = x;
      this.y = y;
      this.w = w;
      this.h = h;
      if (w < 0) {
        this.x += w;
        this.w = Math.abs(w);
      }
      if (h < 0) {
        this.y += h;
        this.h = Math.abs(h);
      }
      this.topLeft = Vec2.of(this.x, this.y);
      this.size = Vec2.of(this.w, this.h);
      this.area = this.w * this.h;
    }
    translatedBy(vec) {
      return new _Rect2(vec.x + this.x, vec.y + this.y, this.w, this.h);
    }
    // Returns a copy of this with the given size (but same top-left).
    resizedTo(size) {
      return new _Rect2(this.x, this.y, size.x, size.y);
    }
    containsPoint(other) {
      return this.x <= other.x && this.y <= other.y && this.x + this.w >= other.x && this.y + this.h >= other.y;
    }
    /** @returns true iff `other` is completely within this `Rect2`. */
    containsRect(other) {
      return this.x <= other.x && this.y <= other.y && this.x + this.w >= other.x + other.w && this.y + this.h >= other.y + other.h;
    }
    /**
     * @returns true iff this and `other` overlap
     */
    intersects(other) {
      const thisMinX = this.x;
      const thisMaxX = thisMinX + this.w;
      const otherMinX = other.x;
      const otherMaxX = other.x + other.w;
      if (thisMaxX < otherMinX || thisMinX > otherMaxX) {
        return false;
      }
      const thisMinY = this.y;
      const thisMaxY = thisMinY + this.h;
      const otherMinY = other.y;
      const otherMaxY = other.y + other.h;
      if (thisMaxY < otherMinY || thisMinY > otherMaxY) {
        return false;
      }
      return true;
    }
    // Returns the overlap of this and [other], or null, if no such
    //          overlap exists
    intersection(other) {
      if (!this.intersects(other)) {
        return null;
      }
      const topLeft = this.topLeft.zip(other.topLeft, Math.max);
      const bottomRight = this.bottomRight.zip(other.bottomRight, Math.min);
      return _Rect2.fromCorners(topLeft, bottomRight);
    }
    // Returns a new rectangle containing both [this] and [other].
    union(other) {
      return _Rect2.union(this, other);
    }
    // Returns a the subdivision of this into [columns] columns
    // and [rows] rows. For example,
    //	 Rect2.unitSquare.divideIntoGrid(2, 2)
    //		-> [ Rect2(0, 0, 0.5, 0.5), Rect2(0.5, 0, 0.5, 0.5), Rect2(0, 0.5, 0.5, 0.5), Rect2(0.5, 0.5, 0.5, 0.5) ]
    // The rectangles are ordered in row-major order.
    divideIntoGrid(columns, rows) {
      const result = [];
      if (columns <= 0 || rows <= 0) {
        return result;
      }
      const eachRectWidth = this.w / columns;
      const eachRectHeight = this.h / rows;
      if (eachRectWidth === 0) {
        columns = 1;
      }
      if (eachRectHeight === 0) {
        rows = 1;
      }
      for (let j = 0; j < rows; j++) {
        for (let i = 0; i < columns; i++) {
          const x = eachRectWidth * i + this.x;
          const y = eachRectHeight * j + this.y;
          result.push(new _Rect2(x, y, eachRectWidth, eachRectHeight));
        }
      }
      return result;
    }
    // Returns a rectangle containing this and [point].
    // [margin] is the minimum distance between the new point and the edge
    // of the resultant rectangle.
    grownToPoint(point, margin = 0) {
      const otherRect = new _Rect2(point.x - margin, point.y - margin, margin * 2, margin * 2);
      return this.union(otherRect);
    }
    // Returns this grown by [margin] in both the x and y directions.
    grownBy(margin) {
      if (margin === 0) {
        return this;
      }
      if (margin < 0) {
        const xMargin = -Math.min(-margin, this.w / 2);
        const yMargin = -Math.min(-margin, this.h / 2);
        return new _Rect2(this.x - xMargin, this.y - yMargin, this.w + xMargin * 2, this.h + yMargin * 2);
      }
      return new _Rect2(this.x - margin, this.y - margin, this.w + margin * 2, this.h + margin * 2);
    }
    /**
     * If this rectangle is smaller than `minSize`, returns a copy of this
     * with a larger width/height.
     *
     * If smaller than `minSize`, padding is applied on both sides.
     */
    grownToSize(minSize) {
      if (this.width >= minSize.x && this.height >= minSize.y) {
        return this;
      }
      const deltaWidth = Math.max(0, minSize.x - this.width);
      const deltaHeight = Math.max(0, minSize.y - this.height);
      return new _Rect2(this.x - deltaWidth / 2, this.y - deltaHeight / 2, this.width + deltaWidth, this.height + deltaHeight);
    }
    getClosestPointOnBoundaryTo(target) {
      const closestEdgePoints = this.getEdges().map((edge) => {
        return edge.closestPointTo(target);
      });
      let closest = null;
      let closestDist = null;
      for (const point of closestEdgePoints) {
        const dist = point.distanceTo(target);
        if (closestDist === null || dist < closestDist) {
          closest = point;
          closestDist = dist;
        }
      }
      return closest;
    }
    /**
     * Returns `true` iff all points in this rectangle are within `distance` from `point`:
     *
     * If $R$ is the set of points in this rectangle, returns `true` iff
     * $$
     * 	\forall {\bf a} \in R, \|\texttt{point} - {\bf a}\| < \texttt{radius}
     * $$
     */
    isWithinRadiusOf(radius, point) {
      if (this.maxDimension > radius) {
        return false;
      }
      const squareRadius = radius * radius;
      return this.corners.every((corner) => corner.minus(point).magnitudeSquared() < squareRadius);
    }
    get corners() {
      return [this.bottomRight, this.topRight, this.topLeft, this.bottomLeft];
    }
    get maxDimension() {
      return Math.max(this.w, this.h);
    }
    get minDimension() {
      return Math.min(this.w, this.h);
    }
    get bottomRight() {
      return this.topLeft.plus(this.size);
    }
    get topRight() {
      return this.bottomRight.plus(Vec2.of(0, -this.h));
    }
    get bottomLeft() {
      return this.topLeft.plus(Vec2.of(0, this.h));
    }
    get width() {
      return this.w;
    }
    get height() {
      return this.h;
    }
    get center() {
      return Vec2.of(this.x + this.w / 2, this.y + this.h / 2);
    }
    // Returns edges in the order
    // [ rightEdge, topEdge, leftEdge, bottomEdge ]
    getEdges() {
      const corners = this.corners;
      return [
        new LineSegment2_default(corners[0], corners[1]),
        new LineSegment2_default(corners[1], corners[2]),
        new LineSegment2_default(corners[2], corners[3]),
        new LineSegment2_default(corners[3], corners[0])
      ];
    }
    intersectsLineSegment(lineSegment) {
      const result = [];
      for (const edge of this.getEdges()) {
        const intersection = edge.intersectsLineSegment(lineSegment);
        intersection.forEach((point) => result.push(point));
      }
      return result;
    }
    signedDistance(point) {
      const closestBoundaryPoint = this.getClosestPointOnBoundaryTo(point);
      const dist = point.minus(closestBoundaryPoint).magnitude();
      if (this.containsPoint(point)) {
        return -dist;
      }
      return dist;
    }
    getTightBoundingBox() {
      return this;
    }
    // [affineTransform] is a transformation matrix that both scales and **translates**.
    // the bounding box of this' four corners after transformed by the given affine transformation.
    transformedBoundingBox(affineTransform) {
      if (affineTransform === Mat33_default.identity) {
        return this;
      }
      return _Rect2.bboxOf(this.corners.map((corner) => affineTransform.transformVec2(corner)));
    }
    /** @return true iff this is equal to `other  tolerance` */
    eq(other, tolerance = 0) {
      return this.topLeft.eq(other.topLeft, tolerance) && this.size.eq(other.size, tolerance);
    }
    toString() {
      return `Rect(point(${this.x}, ${this.y}), size(${this.w}, ${this.h}))`;
    }
    static fromCorners(corner1, corner2) {
      return new _Rect2(Math.min(corner1.x, corner2.x), Math.min(corner1.y, corner2.y), Math.abs(corner1.x - corner2.x), Math.abs(corner1.y - corner2.y));
    }
    // Returns a box that contains all points in [points] with at least [margin]
    // between each point and the edge of the box.
    static bboxOf(points, margin = 0) {
      let minX = 0;
      let minY = 0;
      let maxX = 0;
      let maxY = 0;
      let isFirst = true;
      for (const point of points) {
        if (isFirst) {
          minX = point.x;
          minY = point.y;
          maxX = point.x;
          maxY = point.y;
          isFirst = false;
        }
        minX = Math.min(minX, point.x);
        minY = Math.min(minY, point.y);
        maxX = Math.max(maxX, point.x);
        maxY = Math.max(maxY, point.y);
      }
      return _Rect2.fromCorners(Vec2.of(minX - margin, minY - margin), Vec2.of(maxX + margin, maxY + margin));
    }
    // @returns a rectangle that contains all of the given rectangles, the bounding box
    //     of the given rectangles.
    static union(...rects) {
      if (rects.length === 0) {
        return _Rect2.empty;
      }
      const firstRect = rects[0];
      let minX = firstRect.x;
      let minY = firstRect.y;
      let maxX = firstRect.x + firstRect.w;
      let maxY = firstRect.y + firstRect.h;
      for (let i = 1; i < rects.length; i++) {
        const rect = rects[i];
        minX = Math.min(minX, rect.x);
        minY = Math.min(minY, rect.y);
        maxX = Math.max(maxX, rect.x + rect.w);
        maxY = Math.max(maxY, rect.y + rect.h);
      }
      return new _Rect2(minX, minY, maxX - minX, maxY - minY);
    }
    static of(template) {
      const width = template.width ?? template.w ?? 0;
      const height = template.height ?? template.h ?? 0;
      return new _Rect2(template.x, template.y, width, height);
    }
  };
  Rect2.empty = new Rect2(0, 0, 0, 0);
  Rect2.unitSquare = new Rect2(0, 0, 1, 1);
  var Rect2_default = Rect2;

  // node_modules/@js-draw/math/dist/mjs/shapes/Parameterized2DShape.mjs
  var Parameterized2DShape = class extends Abstract2DShape_default {
    intersectsLineSegment(line) {
      return this.argIntersectsLineSegment(line).map((t2) => this.at(t2));
    }
  };
  var Parameterized2DShape_default = Parameterized2DShape;

  // node_modules/@js-draw/math/dist/mjs/shapes/LineSegment2.mjs
  var LineSegment2 = class _LineSegment2 extends Parameterized2DShape_default {
    /** Creates a new `LineSegment2` from its endpoints. */
    constructor(point1, point2) {
      super();
      this.point1 = point1;
      this.point2 = point2;
      this.bbox = Rect2_default.bboxOf([point1, point2]);
      this.direction = point2.minus(point1);
      this.length = this.direction.magnitude();
      if (this.length > 0) {
        this.direction = this.direction.times(1 / this.length);
      }
    }
    /**
     * Returns the smallest line segment that contains all points in `points`, or `null`
     * if no such line segment exists.
     *
     * @example
     * ```ts,runnable,console
     * import {LineSegment2, Vec2} from '@js-draw/math';
     * console.log(LineSegment2.ofSmallestContainingPoints([Vec2.of(1, 0), Vec2.of(0, 1)]));
     * ```
     */
    static ofSmallestContainingPoints(points) {
      if (points.length <= 1)
        return null;
      const sorted = [...points].sort((a, b) => a.x !== b.x ? a.x - b.x : a.y - b.y);
      const line = new _LineSegment2(sorted[0], sorted[sorted.length - 1]);
      for (const point of sorted) {
        if (!line.containsPoint(point)) {
          return null;
        }
      }
      return line;
    }
    // Accessors to make LineSegment2 compatible with bezier-js's
    // interface
    /** Alias for `point1`. */
    get p1() {
      return this.point1;
    }
    /** Alias for `point2`. */
    get p2() {
      return this.point2;
    }
    get center() {
      return this.point1.lerp(this.point2, 0.5);
    }
    /**
     * Gets a point a **distance** `t` along this line.
     *
     * @deprecated
     */
    get(t2) {
      return this.point1.plus(this.direction.times(t2));
    }
    /**
     * Returns a point a fraction, `t`, along this line segment.
     * Thus, `segment.at(0)` returns `segment.p1` and `segment.at(1)` returns
     * `segment.p2`.
     *
     * `t` should be in `[0, 1]`.
     */
    at(t2) {
      return this.get(t2 * this.length);
    }
    normalAt(_t) {
      return this.direction.orthog();
    }
    tangentAt(_t) {
      return this.direction;
    }
    splitAt(t2) {
      if (t2 <= 0 || t2 >= 1) {
        return [this];
      }
      return [new _LineSegment2(this.point1, this.at(t2)), new _LineSegment2(this.at(t2), this.point2)];
    }
    /**
     * Returns the intersection of this with another line segment.
     *
     * **WARNING**: The parameter value returned by this method does not range from 0 to 1 and
     *              is currently a length.
     *              This will change in a future release.
     * @deprecated
     */
    intersection(other) {
      let resultPoint, resultT;
      const small = 4e-13;
      if (Math.abs(this.direction.x) < small) {
        if (other.direction.x === 0 || this.direction.y === 0) {
          return null;
        }
        const xIntersect = this.point1.x;
        const yIntersect = (this.point1.x - other.point1.x) * other.direction.y / other.direction.x + other.point1.y;
        resultPoint = Vec2.of(xIntersect, yIntersect);
        resultT = (yIntersect - this.point1.y) / this.direction.y;
      } else {
        const numerator = (this.point1.y - other.point1.y) * this.direction.x * other.direction.x + this.direction.x * other.direction.y * other.point1.x - this.direction.y * other.direction.x * this.point1.x;
        const denominator = other.direction.y * this.direction.x - this.direction.y * other.direction.x;
        if (denominator === 0) {
          return null;
        }
        const xIntersect = numerator / denominator;
        const t1 = (xIntersect - this.point1.x) / this.direction.x;
        const yIntersect = this.point1.y + this.direction.y * t1;
        resultPoint = Vec2.of(xIntersect, yIntersect);
        resultT = (xIntersect - this.point1.x) / this.direction.x;
      }
      const resultToP1 = resultPoint.distanceTo(this.point1);
      const resultToP2 = resultPoint.distanceTo(this.point2);
      const resultToP3 = resultPoint.distanceTo(other.point1);
      const resultToP4 = resultPoint.distanceTo(other.point2);
      if (resultToP1 > this.length || resultToP2 > this.length || resultToP3 > other.length || resultToP4 > other.length) {
        return null;
      }
      return {
        point: resultPoint,
        t: resultT
      };
    }
    intersects(other) {
      return this.intersection(other) !== null;
    }
    argIntersectsLineSegment(lineSegment) {
      const intersection = this.intersection(lineSegment);
      if (intersection) {
        return [intersection.t / this.length];
      }
      return [];
    }
    /**
     * Returns the points at which this line segment intersects the
     * given line segment.
     *
     * Note that {@link intersects} returns *whether* this line segment intersects another
     * line segment. This method, by contrast, returns **the point** at which the intersection
     * occurs, if such a point exists.
     */
    intersectsLineSegment(lineSegment) {
      const intersection = this.intersection(lineSegment);
      if (intersection) {
        return [intersection.point];
      }
      return [];
    }
    // Returns the closest point on this to [target]
    closestPointTo(target) {
      return this.nearestPointTo(target).point;
    }
    nearestPointTo(target) {
      const projectedDistFromP1 = target.minus(this.p1).dot(this.direction);
      const projectedDistFromP2 = this.length - projectedDistFromP1;
      const projection = this.p1.plus(this.direction.times(projectedDistFromP1));
      if (projectedDistFromP1 > 0 && projectedDistFromP1 < this.length) {
        return { point: projection, parameterValue: projectedDistFromP1 / this.length };
      }
      if (Math.abs(projectedDistFromP2) < Math.abs(projectedDistFromP1)) {
        return { point: this.p2, parameterValue: 1 };
      } else {
        return { point: this.p1, parameterValue: 0 };
      }
    }
    /**
     * Returns the distance from this line segment to `target`.
     *
     * Because a line segment has no interior, this signed distance is equivalent to
     * the full distance between `target` and this line segment.
     */
    signedDistance(target) {
      return this.closestPointTo(target).minus(target).magnitude();
    }
    /** Returns a copy of this line segment transformed by the given `affineTransfm`. */
    transformedBy(affineTransfm) {
      return new _LineSegment2(affineTransfm.transformVec2(this.p1), affineTransfm.transformVec2(this.p2));
    }
    /** @inheritdoc */
    getTightBoundingBox() {
      return this.bbox;
    }
    toString() {
      return `LineSegment(${this.p1.toString()}, ${this.p2.toString()})`;
    }
    /**
     * Returns `true` iff this is equivalent to `other`.
     *
     * **Options**:
     * - `tolerance`: The maximum difference between endpoints. (Default: 0)
     * - `ignoreDirection`: Allow matching a version of `this` with opposite direction. (Default: `true`)
     */
    eq(other, options) {
      if (!(other instanceof _LineSegment2)) {
        return false;
      }
      const tolerance = options?.tolerance;
      const ignoreDirection = options?.ignoreDirection ?? true;
      return other.p1.eq(this.p1, tolerance) && other.p2.eq(this.p2, tolerance) || ignoreDirection && other.p1.eq(this.p2, tolerance) && other.p2.eq(this.p1, tolerance);
    }
  };
  var LineSegment2_default = LineSegment2;

  // node_modules/bezier-js/src/utils.js
  var { abs, cos, sin, acos, atan2, sqrt, pow } = Math;
  function crt(v) {
    return v < 0 ? -pow(-v, 1 / 3) : pow(v, 1 / 3);
  }
  var pi = Math.PI;
  var tau = 2 * pi;
  var quart = pi / 2;
  var epsilon = 1e-6;
  var nMax = Number.MAX_SAFE_INTEGER || 9007199254740991;
  var nMin = Number.MIN_SAFE_INTEGER || -9007199254740991;
  var ZERO = { x: 0, y: 0, z: 0 };
  var utils = {
    // Legendre-Gauss abscissae with n=24 (x_i values, defined at i=n as the roots of the nth order Legendre polynomial Pn(x))
    Tvalues: [
      -0.06405689286260563,
      0.06405689286260563,
      -0.1911188674736163,
      0.1911188674736163,
      -0.3150426796961634,
      0.3150426796961634,
      -0.4337935076260451,
      0.4337935076260451,
      -0.5454214713888396,
      0.5454214713888396,
      -0.6480936519369755,
      0.6480936519369755,
      -0.7401241915785544,
      0.7401241915785544,
      -0.820001985973903,
      0.820001985973903,
      -0.8864155270044011,
      0.8864155270044011,
      -0.9382745520027328,
      0.9382745520027328,
      -0.9747285559713095,
      0.9747285559713095,
      -0.9951872199970213,
      0.9951872199970213
    ],
    // Legendre-Gauss weights with n=24 (w_i values, defined by a function linked to in the Bezier primer article)
    Cvalues: [
      0.12793819534675216,
      0.12793819534675216,
      0.1258374563468283,
      0.1258374563468283,
      0.12167047292780339,
      0.12167047292780339,
      0.1155056680537256,
      0.1155056680537256,
      0.10744427011596563,
      0.10744427011596563,
      0.09761865210411388,
      0.09761865210411388,
      0.08619016153195327,
      0.08619016153195327,
      0.0733464814110803,
      0.0733464814110803,
      0.05929858491543678,
      0.05929858491543678,
      0.04427743881741981,
      0.04427743881741981,
      0.028531388628933663,
      0.028531388628933663,
      0.0123412297999872,
      0.0123412297999872
    ],
    arcfn: function(t2, derivativeFn) {
      const d = derivativeFn(t2);
      let l = d.x * d.x + d.y * d.y;
      if (typeof d.z !== "undefined") {
        l += d.z * d.z;
      }
      return sqrt(l);
    },
    compute: function(t2, points, _3d) {
      if (t2 === 0) {
        points[0].t = 0;
        return points[0];
      }
      const order = points.length - 1;
      if (t2 === 1) {
        points[order].t = 1;
        return points[order];
      }
      const mt = 1 - t2;
      let p = points;
      if (order === 0) {
        points[0].t = t2;
        return points[0];
      }
      if (order === 1) {
        const ret = {
          x: mt * p[0].x + t2 * p[1].x,
          y: mt * p[0].y + t2 * p[1].y,
          t: t2
        };
        if (_3d) {
          ret.z = mt * p[0].z + t2 * p[1].z;
        }
        return ret;
      }
      if (order < 4) {
        let mt2 = mt * mt, t22 = t2 * t2, a, b, c, d = 0;
        if (order === 2) {
          p = [p[0], p[1], p[2], ZERO];
          a = mt2;
          b = mt * t2 * 2;
          c = t22;
        } else if (order === 3) {
          a = mt2 * mt;
          b = mt2 * t2 * 3;
          c = mt * t22 * 3;
          d = t2 * t22;
        }
        const ret = {
          x: a * p[0].x + b * p[1].x + c * p[2].x + d * p[3].x,
          y: a * p[0].y + b * p[1].y + c * p[2].y + d * p[3].y,
          t: t2
        };
        if (_3d) {
          ret.z = a * p[0].z + b * p[1].z + c * p[2].z + d * p[3].z;
        }
        return ret;
      }
      const dCpts = JSON.parse(JSON.stringify(points));
      while (dCpts.length > 1) {
        for (let i = 0; i < dCpts.length - 1; i++) {
          dCpts[i] = {
            x: dCpts[i].x + (dCpts[i + 1].x - dCpts[i].x) * t2,
            y: dCpts[i].y + (dCpts[i + 1].y - dCpts[i].y) * t2
          };
          if (typeof dCpts[i].z !== "undefined") {
            dCpts[i] = dCpts[i].z + (dCpts[i + 1].z - dCpts[i].z) * t2;
          }
        }
        dCpts.splice(dCpts.length - 1, 1);
      }
      dCpts[0].t = t2;
      return dCpts[0];
    },
    computeWithRatios: function(t2, points, ratios, _3d) {
      const mt = 1 - t2, r = ratios, p = points;
      let f1 = r[0], f2 = r[1], f3 = r[2], f4 = r[3], d;
      f1 *= mt;
      f2 *= t2;
      if (p.length === 2) {
        d = f1 + f2;
        return {
          x: (f1 * p[0].x + f2 * p[1].x) / d,
          y: (f1 * p[0].y + f2 * p[1].y) / d,
          z: !_3d ? false : (f1 * p[0].z + f2 * p[1].z) / d,
          t: t2
        };
      }
      f1 *= mt;
      f2 *= 2 * mt;
      f3 *= t2 * t2;
      if (p.length === 3) {
        d = f1 + f2 + f3;
        return {
          x: (f1 * p[0].x + f2 * p[1].x + f3 * p[2].x) / d,
          y: (f1 * p[0].y + f2 * p[1].y + f3 * p[2].y) / d,
          z: !_3d ? false : (f1 * p[0].z + f2 * p[1].z + f3 * p[2].z) / d,
          t: t2
        };
      }
      f1 *= mt;
      f2 *= 1.5 * mt;
      f3 *= 3 * mt;
      f4 *= t2 * t2 * t2;
      if (p.length === 4) {
        d = f1 + f2 + f3 + f4;
        return {
          x: (f1 * p[0].x + f2 * p[1].x + f3 * p[2].x + f4 * p[3].x) / d,
          y: (f1 * p[0].y + f2 * p[1].y + f3 * p[2].y + f4 * p[3].y) / d,
          z: !_3d ? false : (f1 * p[0].z + f2 * p[1].z + f3 * p[2].z + f4 * p[3].z) / d,
          t: t2
        };
      }
    },
    derive: function(points, _3d) {
      const dpoints = [];
      for (let p = points, d = p.length, c = d - 1; d > 1; d--, c--) {
        const list = [];
        for (let j = 0, dpt; j < c; j++) {
          dpt = {
            x: c * (p[j + 1].x - p[j].x),
            y: c * (p[j + 1].y - p[j].y)
          };
          if (_3d) {
            dpt.z = c * (p[j + 1].z - p[j].z);
          }
          list.push(dpt);
        }
        dpoints.push(list);
        p = list;
      }
      return dpoints;
    },
    between: function(v, m, M) {
      return m <= v && v <= M || utils.approximately(v, m) || utils.approximately(v, M);
    },
    approximately: function(a, b, precision) {
      return abs(a - b) <= (precision || epsilon);
    },
    length: function(derivativeFn) {
      const z = 0.5, len = utils.Tvalues.length;
      let sum = 0;
      for (let i = 0, t2; i < len; i++) {
        t2 = z * utils.Tvalues[i] + z;
        sum += utils.Cvalues[i] * utils.arcfn(t2, derivativeFn);
      }
      return z * sum;
    },
    map: function(v, ds, de, ts, te) {
      const d1 = de - ds, d2 = te - ts, v2 = v - ds, r = v2 / d1;
      return ts + d2 * r;
    },
    lerp: function(r, v1, v2) {
      const ret = {
        x: v1.x + r * (v2.x - v1.x),
        y: v1.y + r * (v2.y - v1.y)
      };
      if (v1.z !== void 0 && v2.z !== void 0) {
        ret.z = v1.z + r * (v2.z - v1.z);
      }
      return ret;
    },
    pointToString: function(p) {
      let s = p.x + "/" + p.y;
      if (typeof p.z !== "undefined") {
        s += "/" + p.z;
      }
      return s;
    },
    pointsToString: function(points) {
      return "[" + points.map(utils.pointToString).join(", ") + "]";
    },
    copy: function(obj) {
      return JSON.parse(JSON.stringify(obj));
    },
    angle: function(o, v1, v2) {
      const dx1 = v1.x - o.x, dy1 = v1.y - o.y, dx2 = v2.x - o.x, dy2 = v2.y - o.y, cross = dx1 * dy2 - dy1 * dx2, dot = dx1 * dx2 + dy1 * dy2;
      return atan2(cross, dot);
    },
    // round as string, to avoid rounding errors
    round: function(v, d) {
      const s = "" + v;
      const pos = s.indexOf(".");
      return parseFloat(s.substring(0, pos + 1 + d));
    },
    dist: function(p1, p2) {
      const dx = p1.x - p2.x, dy = p1.y - p2.y;
      return sqrt(dx * dx + dy * dy);
    },
    closest: function(LUT, point) {
      let mdist = pow(2, 63), mpos, d;
      LUT.forEach(function(p, idx) {
        d = utils.dist(point, p);
        if (d < mdist) {
          mdist = d;
          mpos = idx;
        }
      });
      return { mdist, mpos };
    },
    abcratio: function(t2, n) {
      if (n !== 2 && n !== 3) {
        return false;
      }
      if (typeof t2 === "undefined") {
        t2 = 0.5;
      } else if (t2 === 0 || t2 === 1) {
        return t2;
      }
      const bottom = pow(t2, n) + pow(1 - t2, n), top = bottom - 1;
      return abs(top / bottom);
    },
    projectionratio: function(t2, n) {
      if (n !== 2 && n !== 3) {
        return false;
      }
      if (typeof t2 === "undefined") {
        t2 = 0.5;
      } else if (t2 === 0 || t2 === 1) {
        return t2;
      }
      const top = pow(1 - t2, n), bottom = pow(t2, n) + top;
      return top / bottom;
    },
    lli8: function(x1, y1, x2, y2, x3, y3, x4, y4) {
      const nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4), ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4), d = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
      if (d == 0) {
        return false;
      }
      return { x: nx / d, y: ny / d };
    },
    lli4: function(p1, p2, p3, p4) {
      const x1 = p1.x, y1 = p1.y, x2 = p2.x, y2 = p2.y, x3 = p3.x, y3 = p3.y, x4 = p4.x, y4 = p4.y;
      return utils.lli8(x1, y1, x2, y2, x3, y3, x4, y4);
    },
    lli: function(v1, v2) {
      return utils.lli4(v1, v1.c, v2, v2.c);
    },
    makeline: function(p1, p2) {
      return new Bezier(
        p1.x,
        p1.y,
        (p1.x + p2.x) / 2,
        (p1.y + p2.y) / 2,
        p2.x,
        p2.y
      );
    },
    findbbox: function(sections) {
      let mx = nMax, my = nMax, MX = nMin, MY = nMin;
      sections.forEach(function(s) {
        const bbox = s.bbox();
        if (mx > bbox.x.min) mx = bbox.x.min;
        if (my > bbox.y.min) my = bbox.y.min;
        if (MX < bbox.x.max) MX = bbox.x.max;
        if (MY < bbox.y.max) MY = bbox.y.max;
      });
      return {
        x: { min: mx, mid: (mx + MX) / 2, max: MX, size: MX - mx },
        y: { min: my, mid: (my + MY) / 2, max: MY, size: MY - my }
      };
    },
    shapeintersections: function(s1, bbox1, s2, bbox2, curveIntersectionThreshold) {
      if (!utils.bboxoverlap(bbox1, bbox2)) return [];
      const intersections = [];
      const a1 = [s1.startcap, s1.forward, s1.back, s1.endcap];
      const a2 = [s2.startcap, s2.forward, s2.back, s2.endcap];
      a1.forEach(function(l1) {
        if (l1.virtual) return;
        a2.forEach(function(l2) {
          if (l2.virtual) return;
          const iss = l1.intersects(l2, curveIntersectionThreshold);
          if (iss.length > 0) {
            iss.c1 = l1;
            iss.c2 = l2;
            iss.s1 = s1;
            iss.s2 = s2;
            intersections.push(iss);
          }
        });
      });
      return intersections;
    },
    makeshape: function(forward, back, curveIntersectionThreshold) {
      const bpl = back.points.length;
      const fpl = forward.points.length;
      const start = utils.makeline(back.points[bpl - 1], forward.points[0]);
      const end = utils.makeline(forward.points[fpl - 1], back.points[0]);
      const shape = {
        startcap: start,
        forward,
        back,
        endcap: end,
        bbox: utils.findbbox([start, forward, back, end])
      };
      shape.intersections = function(s2) {
        return utils.shapeintersections(
          shape,
          shape.bbox,
          s2,
          s2.bbox,
          curveIntersectionThreshold
        );
      };
      return shape;
    },
    getminmax: function(curve, d, list) {
      if (!list) return { min: 0, max: 0 };
      let min2 = nMax, max2 = nMin, t2, c;
      if (list.indexOf(0) === -1) {
        list = [0].concat(list);
      }
      if (list.indexOf(1) === -1) {
        list.push(1);
      }
      for (let i = 0, len = list.length; i < len; i++) {
        t2 = list[i];
        c = curve.get(t2);
        if (c[d] < min2) {
          min2 = c[d];
        }
        if (c[d] > max2) {
          max2 = c[d];
        }
      }
      return { min: min2, mid: (min2 + max2) / 2, max: max2, size: max2 - min2 };
    },
    align: function(points, line) {
      const tx = line.p1.x, ty = line.p1.y, a = -atan2(line.p2.y - ty, line.p2.x - tx), d = function(v) {
        return {
          x: (v.x - tx) * cos(a) - (v.y - ty) * sin(a),
          y: (v.x - tx) * sin(a) + (v.y - ty) * cos(a)
        };
      };
      return points.map(d);
    },
    roots: function(points, line) {
      line = line || { p1: { x: 0, y: 0 }, p2: { x: 1, y: 0 } };
      const order = points.length - 1;
      const aligned = utils.align(points, line);
      const reduce = function(t2) {
        return 0 <= t2 && t2 <= 1;
      };
      if (order === 2) {
        const a2 = aligned[0].y, b2 = aligned[1].y, c2 = aligned[2].y, d2 = a2 - 2 * b2 + c2;
        if (d2 !== 0) {
          const m1 = -sqrt(b2 * b2 - a2 * c2), m2 = -a2 + b2, v12 = -(m1 + m2) / d2, v2 = -(-m1 + m2) / d2;
          return [v12, v2].filter(reduce);
        } else if (b2 !== c2 && d2 === 0) {
          return [(2 * b2 - c2) / (2 * b2 - 2 * c2)].filter(reduce);
        }
        return [];
      }
      const pa = aligned[0].y, pb = aligned[1].y, pc = aligned[2].y, pd = aligned[3].y;
      let d = -pa + 3 * pb - 3 * pc + pd, a = 3 * pa - 6 * pb + 3 * pc, b = -3 * pa + 3 * pb, c = pa;
      if (utils.approximately(d, 0)) {
        if (utils.approximately(a, 0)) {
          if (utils.approximately(b, 0)) {
            return [];
          }
          return [-c / b].filter(reduce);
        }
        const q3 = sqrt(b * b - 4 * a * c), a2 = 2 * a;
        return [(q3 - b) / a2, (-b - q3) / a2].filter(reduce);
      }
      a /= d;
      b /= d;
      c /= d;
      const p = (3 * b - a * a) / 3, p3 = p / 3, q = (2 * a * a * a - 9 * a * b + 27 * c) / 27, q2 = q / 2, discriminant = q2 * q2 + p3 * p3 * p3;
      let u1, v1, x1, x2, x3;
      if (discriminant < 0) {
        const mp3 = -p / 3, mp33 = mp3 * mp3 * mp3, r = sqrt(mp33), t2 = -q / (2 * r), cosphi = t2 < -1 ? -1 : t2 > 1 ? 1 : t2, phi = acos(cosphi), crtr = crt(r), t1 = 2 * crtr;
        x1 = t1 * cos(phi / 3) - a / 3;
        x2 = t1 * cos((phi + tau) / 3) - a / 3;
        x3 = t1 * cos((phi + 2 * tau) / 3) - a / 3;
        return [x1, x2, x3].filter(reduce);
      } else if (discriminant === 0) {
        u1 = q2 < 0 ? crt(-q2) : -crt(q2);
        x1 = 2 * u1 - a / 3;
        x2 = -u1 - a / 3;
        return [x1, x2].filter(reduce);
      } else {
        const sd = sqrt(discriminant);
        u1 = crt(-q2 + sd);
        v1 = crt(q2 + sd);
        return [u1 - v1 - a / 3].filter(reduce);
      }
    },
    droots: function(p) {
      if (p.length === 3) {
        const a = p[0], b = p[1], c = p[2], d = a - 2 * b + c;
        if (d !== 0) {
          const m1 = -sqrt(b * b - a * c), m2 = -a + b, v1 = -(m1 + m2) / d, v2 = -(-m1 + m2) / d;
          return [v1, v2];
        } else if (b !== c && d === 0) {
          return [(2 * b - c) / (2 * (b - c))];
        }
        return [];
      }
      if (p.length === 2) {
        const a = p[0], b = p[1];
        if (a !== b) {
          return [a / (a - b)];
        }
        return [];
      }
      return [];
    },
    curvature: function(t2, d1, d2, _3d, kOnly) {
      let num, dnm, adk, dk, k = 0, r = 0;
      const d = utils.compute(t2, d1);
      const dd = utils.compute(t2, d2);
      const qdsum = d.x * d.x + d.y * d.y;
      if (_3d) {
        num = sqrt(
          pow(d.y * dd.z - dd.y * d.z, 2) + pow(d.z * dd.x - dd.z * d.x, 2) + pow(d.x * dd.y - dd.x * d.y, 2)
        );
        dnm = pow(qdsum + d.z * d.z, 3 / 2);
      } else {
        num = d.x * dd.y - d.y * dd.x;
        dnm = pow(qdsum, 3 / 2);
      }
      if (num === 0 || dnm === 0) {
        return { k: 0, r: 0 };
      }
      k = num / dnm;
      r = dnm / num;
      if (!kOnly) {
        const pk = utils.curvature(t2 - 1e-3, d1, d2, _3d, true).k;
        const nk = utils.curvature(t2 + 1e-3, d1, d2, _3d, true).k;
        dk = (nk - k + (k - pk)) / 2;
        adk = (abs(nk - k) + abs(k - pk)) / 2;
      }
      return { k, r, dk, adk };
    },
    inflections: function(points) {
      if (points.length < 4) return [];
      const p = utils.align(points, { p1: points[0], p2: points.slice(-1)[0] }), a = p[2].x * p[1].y, b = p[3].x * p[1].y, c = p[1].x * p[2].y, d = p[3].x * p[2].y, v1 = 18 * (-3 * a + 2 * b + 3 * c - d), v2 = 18 * (3 * a - b - 3 * c), v3 = 18 * (c - a);
      if (utils.approximately(v1, 0)) {
        if (!utils.approximately(v2, 0)) {
          let t2 = -v3 / v2;
          if (0 <= t2 && t2 <= 1) return [t2];
        }
        return [];
      }
      const d2 = 2 * v1;
      if (utils.approximately(d2, 0)) return [];
      const trm = v2 * v2 - 4 * v1 * v3;
      if (trm < 0) return [];
      const sq = Math.sqrt(trm);
      return [(sq - v2) / d2, -(v2 + sq) / d2].filter(function(r) {
        return 0 <= r && r <= 1;
      });
    },
    bboxoverlap: function(b1, b2) {
      const dims = ["x", "y"], len = dims.length;
      for (let i = 0, dim, l, t2, d; i < len; i++) {
        dim = dims[i];
        l = b1[dim].mid;
        t2 = b2[dim].mid;
        d = (b1[dim].size + b2[dim].size) / 2;
        if (abs(l - t2) >= d) return false;
      }
      return true;
    },
    expandbox: function(bbox, _bbox) {
      if (_bbox.x.min < bbox.x.min) {
        bbox.x.min = _bbox.x.min;
      }
      if (_bbox.y.min < bbox.y.min) {
        bbox.y.min = _bbox.y.min;
      }
      if (_bbox.z && _bbox.z.min < bbox.z.min) {
        bbox.z.min = _bbox.z.min;
      }
      if (_bbox.x.max > bbox.x.max) {
        bbox.x.max = _bbox.x.max;
      }
      if (_bbox.y.max > bbox.y.max) {
        bbox.y.max = _bbox.y.max;
      }
      if (_bbox.z && _bbox.z.max > bbox.z.max) {
        bbox.z.max = _bbox.z.max;
      }
      bbox.x.mid = (bbox.x.min + bbox.x.max) / 2;
      bbox.y.mid = (bbox.y.min + bbox.y.max) / 2;
      if (bbox.z) {
        bbox.z.mid = (bbox.z.min + bbox.z.max) / 2;
      }
      bbox.x.size = bbox.x.max - bbox.x.min;
      bbox.y.size = bbox.y.max - bbox.y.min;
      if (bbox.z) {
        bbox.z.size = bbox.z.max - bbox.z.min;
      }
    },
    pairiteration: function(c1, c2, curveIntersectionThreshold) {
      const c1b = c1.bbox(), c2b = c2.bbox(), r = 1e5, threshold = curveIntersectionThreshold || 0.5;
      if (c1b.x.size + c1b.y.size < threshold && c2b.x.size + c2b.y.size < threshold) {
        return [
          (r * (c1._t1 + c1._t2) / 2 | 0) / r + "/" + (r * (c2._t1 + c2._t2) / 2 | 0) / r
        ];
      }
      let cc1 = c1.split(0.5), cc2 = c2.split(0.5), pairs = [
        { left: cc1.left, right: cc2.left },
        { left: cc1.left, right: cc2.right },
        { left: cc1.right, right: cc2.right },
        { left: cc1.right, right: cc2.left }
      ];
      pairs = pairs.filter(function(pair) {
        return utils.bboxoverlap(pair.left.bbox(), pair.right.bbox());
      });
      let results = [];
      if (pairs.length === 0) return results;
      pairs.forEach(function(pair) {
        results = results.concat(
          utils.pairiteration(pair.left, pair.right, threshold)
        );
      });
      results = results.filter(function(v, i) {
        return results.indexOf(v) === i;
      });
      return results;
    },
    getccenter: function(p1, p2, p3) {
      const dx1 = p2.x - p1.x, dy1 = p2.y - p1.y, dx2 = p3.x - p2.x, dy2 = p3.y - p2.y, dx1p = dx1 * cos(quart) - dy1 * sin(quart), dy1p = dx1 * sin(quart) + dy1 * cos(quart), dx2p = dx2 * cos(quart) - dy2 * sin(quart), dy2p = dx2 * sin(quart) + dy2 * cos(quart), mx1 = (p1.x + p2.x) / 2, my1 = (p1.y + p2.y) / 2, mx2 = (p2.x + p3.x) / 2, my2 = (p2.y + p3.y) / 2, mx1n = mx1 + dx1p, my1n = my1 + dy1p, mx2n = mx2 + dx2p, my2n = my2 + dy2p, arc = utils.lli8(mx1, my1, mx1n, my1n, mx2, my2, mx2n, my2n), r = utils.dist(arc, p1);
      let s = atan2(p1.y - arc.y, p1.x - arc.x), m = atan2(p2.y - arc.y, p2.x - arc.x), e = atan2(p3.y - arc.y, p3.x - arc.x), _;
      if (s < e) {
        if (s > m || m > e) {
          s += tau;
        }
        if (s > e) {
          _ = e;
          e = s;
          s = _;
        }
      } else {
        if (e < m && m < s) {
          _ = e;
          e = s;
          s = _;
        } else {
          e += tau;
        }
      }
      arc.s = s;
      arc.e = e;
      arc.r = r;
      return arc;
    },
    numberSort: function(a, b) {
      return a - b;
    }
  };

  // node_modules/bezier-js/src/poly-bezier.js
  var PolyBezier = class _PolyBezier {
    constructor(curves) {
      this.curves = [];
      this._3d = false;
      if (!!curves) {
        this.curves = curves;
        this._3d = this.curves[0]._3d;
      }
    }
    valueOf() {
      return this.toString();
    }
    toString() {
      return "[" + this.curves.map(function(curve) {
        return utils.pointsToString(curve.points);
      }).join(", ") + "]";
    }
    addCurve(curve) {
      this.curves.push(curve);
      this._3d = this._3d || curve._3d;
    }
    length() {
      return this.curves.map(function(v) {
        return v.length();
      }).reduce(function(a, b) {
        return a + b;
      });
    }
    curve(idx) {
      return this.curves[idx];
    }
    bbox() {
      const c = this.curves;
      var bbox = c[0].bbox();
      for (var i = 1; i < c.length; i++) {
        utils.expandbox(bbox, c[i].bbox());
      }
      return bbox;
    }
    offset(d) {
      const offset = [];
      this.curves.forEach(function(v) {
        offset.push(...v.offset(d));
      });
      return new _PolyBezier(offset);
    }
  };

  // node_modules/bezier-js/src/bezier.js
  var { abs: abs2, min, max, cos: cos2, sin: sin2, acos: acos2, sqrt: sqrt2 } = Math;
  var pi2 = Math.PI;
  var Bezier = class _Bezier {
    constructor(coords) {
      let args = coords && coords.forEach ? coords : Array.from(arguments).slice();
      let coordlen = false;
      if (typeof args[0] === "object") {
        coordlen = args.length;
        const newargs = [];
        args.forEach(function(point2) {
          ["x", "y", "z"].forEach(function(d) {
            if (typeof point2[d] !== "undefined") {
              newargs.push(point2[d]);
            }
          });
        });
        args = newargs;
      }
      let higher = false;
      const len = args.length;
      if (coordlen) {
        if (coordlen > 4) {
          if (arguments.length !== 1) {
            throw new Error(
              "Only new Bezier(point[]) is accepted for 4th and higher order curves"
            );
          }
          higher = true;
        }
      } else {
        if (len !== 6 && len !== 8 && len !== 9 && len !== 12) {
          if (arguments.length !== 1) {
            throw new Error(
              "Only new Bezier(point[]) is accepted for 4th and higher order curves"
            );
          }
        }
      }
      const _3d = this._3d = !higher && (len === 9 || len === 12) || coords && coords[0] && typeof coords[0].z !== "undefined";
      const points = this.points = [];
      for (let idx = 0, step = _3d ? 3 : 2; idx < len; idx += step) {
        var point = {
          x: args[idx],
          y: args[idx + 1]
        };
        if (_3d) {
          point.z = args[idx + 2];
        }
        points.push(point);
      }
      const order = this.order = points.length - 1;
      const dims = this.dims = ["x", "y"];
      if (_3d) dims.push("z");
      this.dimlen = dims.length;
      const aligned = utils.align(points, { p1: points[0], p2: points[order] });
      const baselength = utils.dist(points[0], points[order]);
      this._linear = aligned.reduce((t2, p) => t2 + abs2(p.y), 0) < baselength / 50;
      this._lut = [];
      this._t1 = 0;
      this._t2 = 1;
      this.update();
    }
    static quadraticFromPoints(p1, p2, p3, t2) {
      if (typeof t2 === "undefined") {
        t2 = 0.5;
      }
      if (t2 === 0) {
        return new _Bezier(p2, p2, p3);
      }
      if (t2 === 1) {
        return new _Bezier(p1, p2, p2);
      }
      const abc = _Bezier.getABC(2, p1, p2, p3, t2);
      return new _Bezier(p1, abc.A, p3);
    }
    static cubicFromPoints(S, B, E, t2, d1) {
      if (typeof t2 === "undefined") {
        t2 = 0.5;
      }
      const abc = _Bezier.getABC(3, S, B, E, t2);
      if (typeof d1 === "undefined") {
        d1 = utils.dist(B, abc.C);
      }
      const d2 = d1 * (1 - t2) / t2;
      const selen = utils.dist(S, E), lx = (E.x - S.x) / selen, ly = (E.y - S.y) / selen, bx1 = d1 * lx, by1 = d1 * ly, bx2 = d2 * lx, by2 = d2 * ly;
      const e1 = { x: B.x - bx1, y: B.y - by1 }, e2 = { x: B.x + bx2, y: B.y + by2 }, A = abc.A, v1 = { x: A.x + (e1.x - A.x) / (1 - t2), y: A.y + (e1.y - A.y) / (1 - t2) }, v2 = { x: A.x + (e2.x - A.x) / t2, y: A.y + (e2.y - A.y) / t2 }, nc1 = { x: S.x + (v1.x - S.x) / t2, y: S.y + (v1.y - S.y) / t2 }, nc2 = {
        x: E.x + (v2.x - E.x) / (1 - t2),
        y: E.y + (v2.y - E.y) / (1 - t2)
      };
      return new _Bezier(S, nc1, nc2, E);
    }
    static getUtils() {
      return utils;
    }
    getUtils() {
      return _Bezier.getUtils();
    }
    static get PolyBezier() {
      return PolyBezier;
    }
    valueOf() {
      return this.toString();
    }
    toString() {
      return utils.pointsToString(this.points);
    }
    toSVG() {
      if (this._3d) return false;
      const p = this.points, x = p[0].x, y = p[0].y, s = ["M", x, y, this.order === 2 ? "Q" : "C"];
      for (let i = 1, last = p.length; i < last; i++) {
        s.push(p[i].x);
        s.push(p[i].y);
      }
      return s.join(" ");
    }
    setRatios(ratios) {
      if (ratios.length !== this.points.length) {
        throw new Error("incorrect number of ratio values");
      }
      this.ratios = ratios;
      this._lut = [];
    }
    verify() {
      const print = this.coordDigest();
      if (print !== this._print) {
        this._print = print;
        this.update();
      }
    }
    coordDigest() {
      return this.points.map(function(c, pos) {
        return "" + pos + c.x + c.y + (c.z ? c.z : 0);
      }).join("");
    }
    update() {
      this._lut = [];
      this.dpoints = utils.derive(this.points, this._3d);
      this.computedirection();
    }
    computedirection() {
      const points = this.points;
      const angle = utils.angle(points[0], points[this.order], points[1]);
      this.clockwise = angle > 0;
    }
    length() {
      return utils.length(this.derivative.bind(this));
    }
    static getABC(order = 2, S, B, E, t2 = 0.5) {
      const u = utils.projectionratio(t2, order), um = 1 - u, C = {
        x: u * S.x + um * E.x,
        y: u * S.y + um * E.y
      }, s = utils.abcratio(t2, order), A = {
        x: B.x + (B.x - C.x) / s,
        y: B.y + (B.y - C.y) / s
      };
      return { A, B, C, S, E };
    }
    getABC(t2, B) {
      B = B || this.get(t2);
      let S = this.points[0];
      let E = this.points[this.order];
      return _Bezier.getABC(this.order, S, B, E, t2);
    }
    getLUT(steps) {
      this.verify();
      steps = steps || 100;
      if (this._lut.length === steps + 1) {
        return this._lut;
      }
      this._lut = [];
      steps++;
      this._lut = [];
      for (let i = 0, p, t2; i < steps; i++) {
        t2 = i / (steps - 1);
        p = this.compute(t2);
        p.t = t2;
        this._lut.push(p);
      }
      return this._lut;
    }
    on(point, error) {
      error = error || 5;
      const lut = this.getLUT(), hits = [];
      for (let i = 0, c, t2 = 0; i < lut.length; i++) {
        c = lut[i];
        if (utils.dist(c, point) < error) {
          hits.push(c);
          t2 += i / lut.length;
        }
      }
      if (!hits.length) return false;
      return t /= hits.length;
    }
    project(point) {
      const LUT = this.getLUT(), l = LUT.length - 1, closest = utils.closest(LUT, point), mpos = closest.mpos, t1 = (mpos - 1) / l, t2 = (mpos + 1) / l, step = 0.1 / l;
      let mdist = closest.mdist, t3 = t1, ft = t3, p;
      mdist += 1;
      for (let d; t3 < t2 + step; t3 += step) {
        p = this.compute(t3);
        d = utils.dist(point, p);
        if (d < mdist) {
          mdist = d;
          ft = t3;
        }
      }
      ft = ft < 0 ? 0 : ft > 1 ? 1 : ft;
      p = this.compute(ft);
      p.t = ft;
      p.d = mdist;
      return p;
    }
    get(t2) {
      return this.compute(t2);
    }
    point(idx) {
      return this.points[idx];
    }
    compute(t2) {
      if (this.ratios) {
        return utils.computeWithRatios(t2, this.points, this.ratios, this._3d);
      }
      return utils.compute(t2, this.points, this._3d, this.ratios);
    }
    raise() {
      const p = this.points, np = [p[0]], k = p.length;
      for (let i = 1, pi3, pim; i < k; i++) {
        pi3 = p[i];
        pim = p[i - 1];
        np[i] = {
          x: (k - i) / k * pi3.x + i / k * pim.x,
          y: (k - i) / k * pi3.y + i / k * pim.y
        };
      }
      np[k] = p[k - 1];
      return new _Bezier(np);
    }
    derivative(t2) {
      return utils.compute(t2, this.dpoints[0], this._3d);
    }
    dderivative(t2) {
      return utils.compute(t2, this.dpoints[1], this._3d);
    }
    align() {
      let p = this.points;
      return new _Bezier(utils.align(p, { p1: p[0], p2: p[p.length - 1] }));
    }
    curvature(t2) {
      return utils.curvature(t2, this.dpoints[0], this.dpoints[1], this._3d);
    }
    inflections() {
      return utils.inflections(this.points);
    }
    normal(t2) {
      return this._3d ? this.__normal3(t2) : this.__normal2(t2);
    }
    __normal2(t2) {
      const d = this.derivative(t2);
      const q = sqrt2(d.x * d.x + d.y * d.y);
      return { t: t2, x: -d.y / q, y: d.x / q };
    }
    __normal3(t2) {
      const r1 = this.derivative(t2), r2 = this.derivative(t2 + 0.01), q1 = sqrt2(r1.x * r1.x + r1.y * r1.y + r1.z * r1.z), q2 = sqrt2(r2.x * r2.x + r2.y * r2.y + r2.z * r2.z);
      r1.x /= q1;
      r1.y /= q1;
      r1.z /= q1;
      r2.x /= q2;
      r2.y /= q2;
      r2.z /= q2;
      const c = {
        x: r2.y * r1.z - r2.z * r1.y,
        y: r2.z * r1.x - r2.x * r1.z,
        z: r2.x * r1.y - r2.y * r1.x
      };
      const m = sqrt2(c.x * c.x + c.y * c.y + c.z * c.z);
      c.x /= m;
      c.y /= m;
      c.z /= m;
      const R = [
        c.x * c.x,
        c.x * c.y - c.z,
        c.x * c.z + c.y,
        c.x * c.y + c.z,
        c.y * c.y,
        c.y * c.z - c.x,
        c.x * c.z - c.y,
        c.y * c.z + c.x,
        c.z * c.z
      ];
      const n = {
        t: t2,
        x: R[0] * r1.x + R[1] * r1.y + R[2] * r1.z,
        y: R[3] * r1.x + R[4] * r1.y + R[5] * r1.z,
        z: R[6] * r1.x + R[7] * r1.y + R[8] * r1.z
      };
      return n;
    }
    hull(t2) {
      let p = this.points, _p = [], q = [], idx = 0;
      q[idx++] = p[0];
      q[idx++] = p[1];
      q[idx++] = p[2];
      if (this.order === 3) {
        q[idx++] = p[3];
      }
      while (p.length > 1) {
        _p = [];
        for (let i = 0, pt, l = p.length - 1; i < l; i++) {
          pt = utils.lerp(t2, p[i], p[i + 1]);
          q[idx++] = pt;
          _p.push(pt);
        }
        p = _p;
      }
      return q;
    }
    split(t1, t2) {
      if (t1 === 0 && !!t2) {
        return this.split(t2).left;
      }
      if (t2 === 1) {
        return this.split(t1).right;
      }
      const q = this.hull(t1);
      const result = {
        left: this.order === 2 ? new _Bezier([q[0], q[3], q[5]]) : new _Bezier([q[0], q[4], q[7], q[9]]),
        right: this.order === 2 ? new _Bezier([q[5], q[4], q[2]]) : new _Bezier([q[9], q[8], q[6], q[3]]),
        span: q
      };
      result.left._t1 = utils.map(0, 0, 1, this._t1, this._t2);
      result.left._t2 = utils.map(t1, 0, 1, this._t1, this._t2);
      result.right._t1 = utils.map(t1, 0, 1, this._t1, this._t2);
      result.right._t2 = utils.map(1, 0, 1, this._t1, this._t2);
      if (!t2) {
        return result;
      }
      t2 = utils.map(t2, t1, 1, 0, 1);
      return result.right.split(t2).left;
    }
    extrema() {
      const result = {};
      let roots = [];
      this.dims.forEach(
        function(dim) {
          let mfn = function(v) {
            return v[dim];
          };
          let p = this.dpoints[0].map(mfn);
          result[dim] = utils.droots(p);
          if (this.order === 3) {
            p = this.dpoints[1].map(mfn);
            result[dim] = result[dim].concat(utils.droots(p));
          }
          result[dim] = result[dim].filter(function(t2) {
            return t2 >= 0 && t2 <= 1;
          });
          roots = roots.concat(result[dim].sort(utils.numberSort));
        }.bind(this)
      );
      result.values = roots.sort(utils.numberSort).filter(function(v, idx) {
        return roots.indexOf(v) === idx;
      });
      return result;
    }
    bbox() {
      const extrema = this.extrema(), result = {};
      this.dims.forEach(
        function(d) {
          result[d] = utils.getminmax(this, d, extrema[d]);
        }.bind(this)
      );
      return result;
    }
    overlaps(curve) {
      const lbbox = this.bbox(), tbbox = curve.bbox();
      return utils.bboxoverlap(lbbox, tbbox);
    }
    offset(t2, d) {
      if (typeof d !== "undefined") {
        const c = this.get(t2), n = this.normal(t2);
        const ret = {
          c,
          n,
          x: c.x + n.x * d,
          y: c.y + n.y * d
        };
        if (this._3d) {
          ret.z = c.z + n.z * d;
        }
        return ret;
      }
      if (this._linear) {
        const nv = this.normal(0), coords = this.points.map(function(p) {
          const ret = {
            x: p.x + t2 * nv.x,
            y: p.y + t2 * nv.y
          };
          if (p.z && nv.z) {
            ret.z = p.z + t2 * nv.z;
          }
          return ret;
        });
        return [new _Bezier(coords)];
      }
      return this.reduce().map(function(s) {
        if (s._linear) {
          return s.offset(t2)[0];
        }
        return s.scale(t2);
      });
    }
    simple() {
      if (this.order === 3) {
        const a1 = utils.angle(this.points[0], this.points[3], this.points[1]);
        const a2 = utils.angle(this.points[0], this.points[3], this.points[2]);
        if (a1 > 0 && a2 < 0 || a1 < 0 && a2 > 0) return false;
      }
      const n1 = this.normal(0);
      const n2 = this.normal(1);
      let s = n1.x * n2.x + n1.y * n2.y;
      if (this._3d) {
        s += n1.z * n2.z;
      }
      return abs2(acos2(s)) < pi2 / 3;
    }
    reduce() {
      let i, t1 = 0, t2 = 0, step = 0.01, segment, pass1 = [], pass2 = [];
      let extrema = this.extrema().values;
      if (extrema.indexOf(0) === -1) {
        extrema = [0].concat(extrema);
      }
      if (extrema.indexOf(1) === -1) {
        extrema.push(1);
      }
      for (t1 = extrema[0], i = 1; i < extrema.length; i++) {
        t2 = extrema[i];
        segment = this.split(t1, t2);
        segment._t1 = t1;
        segment._t2 = t2;
        pass1.push(segment);
        t1 = t2;
      }
      pass1.forEach(function(p1) {
        t1 = 0;
        t2 = 0;
        while (t2 <= 1) {
          for (t2 = t1 + step; t2 <= 1 + step; t2 += step) {
            segment = p1.split(t1, t2);
            if (!segment.simple()) {
              t2 -= step;
              if (abs2(t1 - t2) < step) {
                return [];
              }
              segment = p1.split(t1, t2);
              segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2);
              segment._t2 = utils.map(t2, 0, 1, p1._t1, p1._t2);
              pass2.push(segment);
              t1 = t2;
              break;
            }
          }
        }
        if (t1 < 1) {
          segment = p1.split(t1, 1);
          segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2);
          segment._t2 = p1._t2;
          pass2.push(segment);
        }
      });
      return pass2;
    }
    translate(v, d1, d2) {
      d2 = typeof d2 === "number" ? d2 : d1;
      const o = this.order;
      let d = this.points.map((_, i) => (1 - i / o) * d1 + i / o * d2);
      return new _Bezier(
        this.points.map((p, i) => ({
          x: p.x + v.x * d[i],
          y: p.y + v.y * d[i]
        }))
      );
    }
    scale(d) {
      const order = this.order;
      let distanceFn = false;
      if (typeof d === "function") {
        distanceFn = d;
      }
      if (distanceFn && order === 2) {
        return this.raise().scale(distanceFn);
      }
      const clockwise = this.clockwise;
      const points = this.points;
      if (this._linear) {
        return this.translate(
          this.normal(0),
          distanceFn ? distanceFn(0) : d,
          distanceFn ? distanceFn(1) : d
        );
      }
      const r1 = distanceFn ? distanceFn(0) : d;
      const r2 = distanceFn ? distanceFn(1) : d;
      const v = [this.offset(0, 10), this.offset(1, 10)];
      const np = [];
      const o = utils.lli4(v[0], v[0].c, v[1], v[1].c);
      if (!o) {
        throw new Error("cannot scale this curve. Try reducing it first.");
      }
      [0, 1].forEach(function(t2) {
        const p = np[t2 * order] = utils.copy(points[t2 * order]);
        p.x += (t2 ? r2 : r1) * v[t2].n.x;
        p.y += (t2 ? r2 : r1) * v[t2].n.y;
      });
      if (!distanceFn) {
        [0, 1].forEach((t2) => {
          if (order === 2 && !!t2) return;
          const p = np[t2 * order];
          const d2 = this.derivative(t2);
          const p2 = { x: p.x + d2.x, y: p.y + d2.y };
          np[t2 + 1] = utils.lli4(p, p2, o, points[t2 + 1]);
        });
        return new _Bezier(np);
      }
      [0, 1].forEach(function(t2) {
        if (order === 2 && !!t2) return;
        var p = points[t2 + 1];
        var ov = {
          x: p.x - o.x,
          y: p.y - o.y
        };
        var rc = distanceFn ? distanceFn((t2 + 1) / order) : d;
        if (distanceFn && !clockwise) rc = -rc;
        var m = sqrt2(ov.x * ov.x + ov.y * ov.y);
        ov.x /= m;
        ov.y /= m;
        np[t2 + 1] = {
          x: p.x + rc * ov.x,
          y: p.y + rc * ov.y
        };
      });
      return new _Bezier(np);
    }
    outline(d1, d2, d3, d4) {
      d2 = d2 === void 0 ? d1 : d2;
      if (this._linear) {
        const n = this.normal(0);
        const start = this.points[0];
        const end = this.points[this.points.length - 1];
        let s, mid, e;
        if (d3 === void 0) {
          d3 = d1;
          d4 = d2;
        }
        s = { x: start.x + n.x * d1, y: start.y + n.y * d1 };
        e = { x: end.x + n.x * d3, y: end.y + n.y * d3 };
        mid = { x: (s.x + e.x) / 2, y: (s.y + e.y) / 2 };
        const fline = [s, mid, e];
        s = { x: start.x - n.x * d2, y: start.y - n.y * d2 };
        e = { x: end.x - n.x * d4, y: end.y - n.y * d4 };
        mid = { x: (s.x + e.x) / 2, y: (s.y + e.y) / 2 };
        const bline = [e, mid, s];
        const ls2 = utils.makeline(bline[2], fline[0]);
        const le2 = utils.makeline(fline[2], bline[0]);
        const segments2 = [ls2, new _Bezier(fline), le2, new _Bezier(bline)];
        return new PolyBezier(segments2);
      }
      const reduced = this.reduce(), len = reduced.length, fcurves = [];
      let bcurves = [], p, alen = 0, tlen = this.length();
      const graduated = typeof d3 !== "undefined" && typeof d4 !== "undefined";
      function linearDistanceFunction(s, e, tlen2, alen2, slen) {
        return function(v) {
          const f1 = alen2 / tlen2, f2 = (alen2 + slen) / tlen2, d = e - s;
          return utils.map(v, 0, 1, s + f1 * d, s + f2 * d);
        };
      }
      reduced.forEach(function(segment) {
        const slen = segment.length();
        if (graduated) {
          fcurves.push(
            segment.scale(linearDistanceFunction(d1, d3, tlen, alen, slen))
          );
          bcurves.push(
            segment.scale(linearDistanceFunction(-d2, -d4, tlen, alen, slen))
          );
        } else {
          fcurves.push(segment.scale(d1));
          bcurves.push(segment.scale(-d2));
        }
        alen += slen;
      });
      bcurves = bcurves.map(function(s) {
        p = s.points;
        if (p[3]) {
          s.points = [p[3], p[2], p[1], p[0]];
        } else {
          s.points = [p[2], p[1], p[0]];
        }
        return s;
      }).reverse();
      const fs = fcurves[0].points[0], fe = fcurves[len - 1].points[fcurves[len - 1].points.length - 1], bs = bcurves[len - 1].points[bcurves[len - 1].points.length - 1], be = bcurves[0].points[0], ls = utils.makeline(bs, fs), le = utils.makeline(fe, be), segments = [ls].concat(fcurves).concat([le]).concat(bcurves);
      return new PolyBezier(segments);
    }
    outlineshapes(d1, d2, curveIntersectionThreshold) {
      d2 = d2 || d1;
      const outline = this.outline(d1, d2).curves;
      const shapes = [];
      for (let i = 1, len = outline.length; i < len / 2; i++) {
        const shape = utils.makeshape(
          outline[i],
          outline[len - i],
          curveIntersectionThreshold
        );
        shape.startcap.virtual = i > 1;
        shape.endcap.virtual = i < len / 2 - 1;
        shapes.push(shape);
      }
      return shapes;
    }
    intersects(curve, curveIntersectionThreshold) {
      if (!curve) return this.selfintersects(curveIntersectionThreshold);
      if (curve.p1 && curve.p2) {
        return this.lineIntersects(curve);
      }
      if (curve instanceof _Bezier) {
        curve = curve.reduce();
      }
      return this.curveintersects(
        this.reduce(),
        curve,
        curveIntersectionThreshold
      );
    }
    lineIntersects(line) {
      const mx = min(line.p1.x, line.p2.x), my = min(line.p1.y, line.p2.y), MX = max(line.p1.x, line.p2.x), MY = max(line.p1.y, line.p2.y);
      return utils.roots(this.points, line).filter((t2) => {
        var p = this.get(t2);
        return utils.between(p.x, mx, MX) && utils.between(p.y, my, MY);
      });
    }
    selfintersects(curveIntersectionThreshold) {
      const reduced = this.reduce(), len = reduced.length - 2, results = [];
      for (let i = 0, result, left, right; i < len; i++) {
        left = reduced.slice(i, i + 1);
        right = reduced.slice(i + 2);
        result = this.curveintersects(left, right, curveIntersectionThreshold);
        results.push(...result);
      }
      return results;
    }
    curveintersects(c1, c2, curveIntersectionThreshold) {
      const pairs = [];
      c1.forEach(function(l) {
        c2.forEach(function(r) {
          if (l.overlaps(r)) {
            pairs.push({ left: l, right: r });
          }
        });
      });
      let intersections = [];
      pairs.forEach(function(pair) {
        const result = utils.pairiteration(
          pair.left,
          pair.right,
          curveIntersectionThreshold
        );
        if (result.length > 0) {
          intersections = intersections.concat(result);
        }
      });
      return intersections;
    }
    arcs(errorThreshold) {
      errorThreshold = errorThreshold || 0.5;
      return this._iterate(errorThreshold, []);
    }
    _error(pc, np1, s, e) {
      const q = (e - s) / 4, c1 = this.get(s + q), c2 = this.get(e - q), ref = utils.dist(pc, np1), d1 = utils.dist(pc, c1), d2 = utils.dist(pc, c2);
      return abs2(d1 - ref) + abs2(d2 - ref);
    }
    _iterate(errorThreshold, circles) {
      let t_s = 0, t_e = 1, safety;
      do {
        safety = 0;
        t_e = 1;
        let np1 = this.get(t_s), np2, np3, arc, prev_arc;
        let curr_good = false, prev_good = false, done;
        let t_m = t_e, prev_e = 1, step = 0;
        do {
          prev_good = curr_good;
          prev_arc = arc;
          t_m = (t_s + t_e) / 2;
          step++;
          np2 = this.get(t_m);
          np3 = this.get(t_e);
          arc = utils.getccenter(np1, np2, np3);
          arc.interval = {
            start: t_s,
            end: t_e
          };
          let error = this._error(arc, np1, t_s, t_e);
          curr_good = error <= errorThreshold;
          done = prev_good && !curr_good;
          if (!done) prev_e = t_e;
          if (curr_good) {
            if (t_e >= 1) {
              arc.interval.end = prev_e = 1;
              prev_arc = arc;
              if (t_e > 1) {
                let d = {
                  x: arc.x + arc.r * cos2(arc.e),
                  y: arc.y + arc.r * sin2(arc.e)
                };
                arc.e += utils.angle({ x: arc.x, y: arc.y }, d, this.get(1));
              }
              break;
            }
            t_e = t_e + (t_e - t_s) / 2;
          } else {
            t_e = t_m;
          }
        } while (!done && safety++ < 100);
        if (safety >= 100) {
          break;
        }
        prev_arc = prev_arc ? prev_arc : arc;
        circles.push(prev_arc);
        t_s = prev_e;
      } while (t_e < 1);
      return circles;
    }
  };

  // node_modules/@js-draw/math/dist/mjs/shapes/BezierJSWrapper.mjs
  var __classPrivateFieldSet = function(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var __classPrivateFieldGet = function(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var _BezierJSWrapper_bezierJs;
  var BezierJSWrapper = class extends Parameterized2DShape_default {
    constructor(bezierJsBezier) {
      super();
      _BezierJSWrapper_bezierJs.set(this, null);
      if (bezierJsBezier) {
        __classPrivateFieldSet(this, _BezierJSWrapper_bezierJs, bezierJsBezier, "f");
      }
    }
    getBezier() {
      if (!__classPrivateFieldGet(this, _BezierJSWrapper_bezierJs, "f")) {
        __classPrivateFieldSet(this, _BezierJSWrapper_bezierJs, new Bezier(this.getPoints().map((p) => p.xy)), "f");
      }
      return __classPrivateFieldGet(this, _BezierJSWrapper_bezierJs, "f");
    }
    signedDistance(point) {
      return this.nearestPointTo(point).point.distanceTo(point);
    }
    /**
     * @returns the (more) exact distance from `point` to this.
     *
     * @see {@link approximateDistance}
     */
    distance(point) {
      return this.signedDistance(point);
    }
    /**
     * @returns the curve evaluated at `t`.
     */
    at(t2) {
      return Vec2.ofXY(this.getBezier().get(t2));
    }
    /** @returns the curve's directional derivative at `t`. */
    derivativeAt(t2) {
      return Vec2.ofXY(this.getBezier().derivative(t2));
    }
    secondDerivativeAt(t2) {
      return Vec2.ofXY(this.getBezier().dderivative(t2));
    }
    /** @returns the [normal vector](https://en.wikipedia.org/wiki/Normal_(geometry)) to this curve at `t`. */
    normal(t2) {
      return Vec2.ofXY(this.getBezier().normal(t2));
    }
    normalAt(t2) {
      return this.normal(t2);
    }
    tangentAt(t2) {
      return this.derivativeAt(t2).normalized();
    }
    getTightBoundingBox() {
      const bbox = this.getBezier().bbox();
      const width = bbox.x.max - bbox.x.min;
      const height = bbox.y.max - bbox.y.min;
      return new Rect2_default(bbox.x.min, bbox.y.min, width, height);
    }
    argIntersectsLineSegment(line) {
      const asLine = LineSegment2_default.ofSmallestContainingPoints(this.getPoints());
      if (asLine) {
        const intersection = asLine.intersectsLineSegment(line);
        return intersection.map((p) => this.nearestPointTo(p).parameterValue);
      }
      const bezier = this.getBezier();
      return bezier.intersects(line).map((t2) => {
        if (typeof t2 === "string") {
          t2 = parseFloat(t2);
        }
        const point = Vec2.ofXY(this.at(t2));
        if (point.distanceTo(line.p1) > line.length || point.distanceTo(line.p2) > line.length) {
          return null;
        }
        return t2;
      }).filter((entry) => entry !== null);
    }
    splitAt(t2) {
      if (t2 <= 0 || t2 >= 1) {
        return [this];
      }
      const bezier = this.getBezier();
      const split = bezier.split(t2);
      return [
        new BezierJSWrapperImpl(split.left.points.map((point) => Vec2.ofXY(point)), split.left),
        new BezierJSWrapperImpl(split.right.points.map((point) => Vec2.ofXY(point)), split.right)
      ];
    }
    nearestPointTo(point) {
      const sqrDistAt = (t3) => point.squareDistanceTo(this.at(t3));
      const yIntercept = sqrDistAt(0);
      let t2 = 0;
      let minSqrDist = yIntercept;
      const pointsToTest = 4;
      for (let i = 0; i < pointsToTest; i++) {
        const testT = i / (pointsToTest - 1);
        const testMinSqrDist = sqrDistAt(testT);
        if (testMinSqrDist < minSqrDist) {
          t2 = testT;
          minSqrDist = testMinSqrDist;
        }
      }
      const secondDerivativeAt = (t3) => {
        const b = this.at(t3);
        const bPrime = this.derivativeAt(t3);
        const bPrimePrime = this.secondDerivativeAt(t3);
        return 2 * bPrime.x * bPrime.x + 2 * b.x * bPrimePrime.x - 2 * point.x * bPrimePrime.x + 2 * bPrime.y * bPrime.y + 2 * b.y * bPrimePrime.y - 2 * point.y * bPrimePrime.y;
      };
      const derivativeAt = (t3) => {
        const b = this.at(t3);
        const bPrime = this.derivativeAt(t3);
        return 2 * b.x * bPrime.x - 2 * point.x * bPrime.x + 2 * b.y * bPrime.y - 2 * point.y * bPrime.y;
      };
      const iterate = () => {
        const slope = secondDerivativeAt(t2);
        if (slope === 0)
          return;
        const newT = (0 - derivativeAt(t2)) / slope + t2;
        t2 = newT;
        if (t2 > 1) {
          t2 = 1;
        } else if (t2 < 0) {
          t2 = 0;
        }
      };
      for (let i = 0; i < 12; i++) {
        iterate();
      }
      return { parameterValue: t2, point: this.at(t2) };
    }
    intersectsBezier(other) {
      const intersections = this.getBezier().intersects(other.getBezier());
      if (!intersections || intersections.length === 0) {
        return [];
      }
      const result = [];
      for (const intersection of intersections) {
        const match = /^([-0-9.eE]+)\/([-0-9.eE]+)$/.exec(intersection);
        if (!match) {
          throw new Error(`Incorrect format returned by .intersects: ${intersections} should be array of "number/number"!`);
        }
        const t2 = parseFloat(match[1]);
        result.push({
          parameterValue: t2,
          point: this.at(t2)
        });
      }
      return result;
    }
    toString() {
      return `B\xE9zier(${this.getPoints().map((point) => point.toString()).join(", ")})`;
    }
  };
  _BezierJSWrapper_bezierJs = /* @__PURE__ */ new WeakMap();
  var BezierJSWrapperImpl = class extends BezierJSWrapper {
    constructor(controlPoints, curve) {
      super(curve);
      this.controlPoints = controlPoints;
    }
    getPoints() {
      return this.controlPoints;
    }
  };
  var BezierJSWrapper_default = BezierJSWrapper;

  // node_modules/@js-draw/math/dist/mjs/shapes/CubicBezier.mjs
  var CubicBezier = class extends BezierJSWrapper_default {
    constructor(p0, p1, p2, p3) {
      super();
      this.p0 = p0;
      this.p1 = p1;
      this.p2 = p2;
      this.p3 = p3;
    }
    getPoints() {
      return [this.p0, this.p1, this.p2, this.p3];
    }
    /** Returns an overestimate of this shape's bounding box. */
    getLooseBoundingBox() {
      return Rect2_default.bboxOf([this.p0, this.p1, this.p2, this.p3]);
    }
  };
  var CubicBezier_default = CubicBezier;

  // node_modules/@js-draw/math/dist/mjs/polynomial/solveQuadratic.mjs
  var solveQuadratic = (a, b, c) => {
    if (a === 0) {
      let solution;
      if (b === 0) {
        solution = c === 0 ? 0 : NaN;
      } else {
        solution = -c / b;
      }
      return [solution, solution];
    }
    const discriminant = b * b - 4 * a * c;
    if (discriminant < 0) {
      return [NaN, NaN];
    }
    const rootDiscriminant = Math.sqrt(discriminant);
    const solution1 = (-b + rootDiscriminant) / (2 * a);
    const solution2 = (-b - rootDiscriminant) / (2 * a);
    if (solution1 > solution2) {
      return [solution1, solution2];
    } else {
      return [solution2, solution1];
    }
  };
  var solveQuadratic_default = solveQuadratic;

  // node_modules/@js-draw/math/dist/mjs/shapes/QuadraticBezier.mjs
  var QuadraticBezier = class _QuadraticBezier extends BezierJSWrapper_default {
    constructor(p0, p1, p2) {
      super();
      this.p0 = p0;
      this.p1 = p1;
      this.p2 = p2;
    }
    /**
     * Returns a component of a quadratic Bzier curve at t, where p0,p1,p2 are either all x or
     * all y components of the target curve.
     */
    static componentAt(t2, p0, p1, p2) {
      return p0 + t2 * (-2 * p0 + 2 * p1) + t2 * t2 * (p0 - 2 * p1 + p2);
    }
    static derivativeComponentAt(t2, p0, p1, p2) {
      return -2 * p0 + 2 * p1 + 2 * t2 * (p0 - 2 * p1 + p2);
    }
    static secondDerivativeComponentAt(t2, p0, p1, p2) {
      return 2 * (p0 - 2 * p1 + p2);
    }
    /**
     * @returns the curve evaluated at `t`.
     *
     * `t` should be a number in `[0, 1]`.
     */
    at(t2) {
      if (t2 === 0)
        return this.p0;
      if (t2 === 1)
        return this.p2;
      const p0 = this.p0;
      const p1 = this.p1;
      const p2 = this.p2;
      return Vec2.of(_QuadraticBezier.componentAt(t2, p0.x, p1.x, p2.x), _QuadraticBezier.componentAt(t2, p0.y, p1.y, p2.y));
    }
    derivativeAt(t2) {
      const p0 = this.p0;
      const p1 = this.p1;
      const p2 = this.p2;
      return Vec2.of(_QuadraticBezier.derivativeComponentAt(t2, p0.x, p1.x, p2.x), _QuadraticBezier.derivativeComponentAt(t2, p0.y, p1.y, p2.y));
    }
    secondDerivativeAt(t2) {
      const p0 = this.p0;
      const p1 = this.p1;
      const p2 = this.p2;
      return Vec2.of(_QuadraticBezier.secondDerivativeComponentAt(t2, p0.x, p1.x, p2.x), _QuadraticBezier.secondDerivativeComponentAt(t2, p0.y, p1.y, p2.y));
    }
    normal(t2) {
      const tangent = this.derivativeAt(t2);
      return tangent.orthog().normalized();
    }
    /** @returns an overestimate of this shape's bounding box. */
    getLooseBoundingBox() {
      return Rect2_default.bboxOf([this.p0, this.p1, this.p2]);
    }
    /**
     * @returns the *approximate* distance from `point` to this curve.
     */
    approximateDistance(point) {
      const A = this.p0.x - point.x;
      const B = -2 * this.p0.x + 2 * this.p1.x;
      const C = this.p0.x - 2 * this.p1.x + this.p2.x;
      const D = this.p0.y - point.y;
      const E = -2 * this.p0.y + 2 * this.p1.y;
      const F = this.p0.y - 2 * this.p1.y + this.p2.y;
      const a = 2 * A * B + 2 * D * E - point.x * B - point.y * E;
      const b = 2 * B * B + 2 * E * E + 2 * C * A + 2 * F * D - point.x * C - point.y * F;
      const c = 2 * E * F + 2 * B * C + 2 * C * B + 2 * F * E;
      const fDerivAtZero = a;
      const f2ndDerivAtZero = b;
      const f3rdDerivAtZero = 2 * c;
      let [min1, min2] = solveQuadratic_default(f3rdDerivAtZero / 2, f2ndDerivAtZero, fDerivAtZero);
      if (isNaN(min1)) {
        min1 = 0.25;
      }
      if (isNaN(min2)) {
        min2 = 0.75;
      }
      const at1 = this.at(min1);
      const at2 = this.at(min2);
      const sqrDist1 = at1.squareDistanceTo(point);
      const sqrDist2 = at2.squareDistanceTo(point);
      const sqrDist3 = this.at(0).squareDistanceTo(point);
      const sqrDist4 = this.at(1).squareDistanceTo(point);
      return Math.sqrt(Math.min(sqrDist1, sqrDist2, sqrDist3, sqrDist4));
    }
    getPoints() {
      return [this.p0, this.p1, this.p2];
    }
  };
  var QuadraticBezier_default = QuadraticBezier;

  // node_modules/@js-draw/math/dist/mjs/shapes/PointShape2D.mjs
  var PointShape2D = class extends Parameterized2DShape_default {
    constructor(p) {
      super();
      this.p = p;
    }
    signedDistance(point) {
      return this.p.distanceTo(point);
    }
    argIntersectsLineSegment(lineSegment, epsilon2) {
      if (lineSegment.containsPoint(this.p, epsilon2)) {
        return [0];
      }
      return [];
    }
    getTightBoundingBox() {
      return new Rect2_default(this.p.x, this.p.y, 0, 0);
    }
    at(_t) {
      return this.p;
    }
    /**
     * Returns an arbitrary unit-length vector.
     */
    normalAt(_t) {
      return Vec2.unitY;
    }
    tangentAt(_t) {
      return Vec2.unitX;
    }
    splitAt(_t) {
      return [this];
    }
    nearestPointTo(_point) {
      return {
        point: this.p,
        parameterValue: 0
      };
    }
  };
  var PointShape2D_default = PointShape2D;

  // node_modules/@js-draw/math/dist/mjs/rounding/cleanUpNumber.mjs
  var cleanUpNumber = (text) => {
    if (text.indexOf("e") > 0) {
      if (text.match(/[eE][-]\d{2,}$/)) {
        return "0";
      }
    }
    const lastChar = text.charAt(text.length - 1);
    if (lastChar === "0" || lastChar === ".") {
      text = text.replace(/([.]\d*[^0])0+$/, "$1");
      text = text.replace(/[.]0+$/, ".");
      text = text.replace(/[.]$/, "");
    }
    const firstChar = text.charAt(0);
    if (firstChar === "0" || firstChar === "-") {
      text = text.replace(/^(0+)[.]/, ".");
      text = text.replace(/^-(0+)[.]/, "-.");
      text = text.replace(/^(-?)0+$/, "$10");
    }
    if (text === "-0") {
      return "0";
    }
    return text;
  };
  var cleanUpNumber_default = cleanUpNumber;

  // node_modules/@js-draw/math/dist/mjs/rounding/toRoundedString.mjs
  var toRoundedString = (num) => {
    const fixRoundingUpExp = /^([-]?\d*\.\d{3,})0{4,}\d{1,4}$/;
    const hasRoundingDownExp = /^([-]?)(\d*)\.(\d{3,}9{4,})\d{1,4}$/;
    let text = num.toString(10);
    if (text.indexOf(".") === -1) {
      return text;
    }
    const roundingDownMatch = hasRoundingDownExp.exec(text);
    if (roundingDownMatch) {
      const negativeSign = roundingDownMatch[1];
      const postDecimalString = roundingDownMatch[3];
      const lastDigit = parseInt(postDecimalString.charAt(postDecimalString.length - 1), 10);
      const postDecimal = parseInt(postDecimalString, 10);
      const preDecimal = parseInt(roundingDownMatch[2], 10);
      const origPostDecimalString = roundingDownMatch[3];
      let newPostDecimal = (postDecimal + 10 - lastDigit).toString();
      let carry = 0;
      if (newPostDecimal.length > postDecimal.toString().length) {
        newPostDecimal = newPostDecimal.substring(1);
        carry = 1;
      }
      while (newPostDecimal.length < origPostDecimalString.length) {
        newPostDecimal = carry.toString(10) + newPostDecimal;
        carry = 0;
      }
      text = `${negativeSign + (preDecimal + carry).toString()}.${newPostDecimal}`;
    }
    text = text.replace(fixRoundingUpExp, "$1");
    return cleanUpNumber_default(text);
  };
  var toRoundedString_default = toRoundedString;

  // node_modules/@js-draw/math/dist/mjs/rounding/constants.mjs
  var numberRegex = /^([-]?)(\d*)[.](\d+)$/;

  // node_modules/@js-draw/math/dist/mjs/rounding/getLenAfterDecimal.mjs
  var getLenAfterDecimal = (numberAsString) => {
    const numberMatch = numberRegex.exec(numberAsString);
    if (!numberMatch) {
      if (numberAsString.search(/[eE]/) !== -1 || /^[a-zA-Z]+$/.exec(numberAsString)) {
        return -1;
      } else {
        return 0;
      }
    }
    const afterDecimalLen = numberMatch[3].length;
    return afterDecimalLen;
  };
  var getLenAfterDecimal_default = getLenAfterDecimal;

  // node_modules/@js-draw/math/dist/mjs/rounding/toStringOfSamePrecision.mjs
  var toStringOfSamePrecision = (num, ...references) => {
    const text = num.toString(10);
    const textMatch = numberRegex.exec(text);
    if (!textMatch) {
      return text;
    }
    let decimalPlaces = -1;
    for (const reference of references) {
      decimalPlaces = Math.max(getLenAfterDecimal_default(reference), decimalPlaces);
    }
    if (decimalPlaces === -1) {
      return toRoundedString_default(num);
    }
    let postDecimal = textMatch[3].substring(0, decimalPlaces);
    let preDecimal = textMatch[2];
    const nextDigit = textMatch[3].charAt(decimalPlaces);
    if (nextDigit !== "") {
      const asNumber = parseInt(nextDigit, 10);
      if (asNumber >= 5) {
        if (postDecimal.length > 0) {
          const leadingZeroMatch = /^(0+)(\d*)$/.exec(postDecimal);
          let leadingZeroes = "";
          let postLeading = postDecimal;
          if (leadingZeroMatch) {
            leadingZeroes = leadingZeroMatch[1];
            postLeading = leadingZeroMatch[2];
          }
          postDecimal = (parseInt(postDecimal) + 1).toString();
          if (postDecimal.length > postLeading.length && leadingZeroes.length > 0) {
            leadingZeroes = leadingZeroes.substring(1);
          }
          postDecimal = leadingZeroes + postDecimal;
        }
        if (postDecimal.length === 0 || postDecimal.length > decimalPlaces) {
          preDecimal = (parseInt(preDecimal) + 1).toString();
          postDecimal = postDecimal.substring(1);
        }
      }
    }
    const negativeSign = textMatch[1];
    return cleanUpNumber_default(`${negativeSign}${preDecimal}.${postDecimal}`);
  };
  var toStringOfSamePrecision_default = toStringOfSamePrecision;

  // node_modules/@js-draw/math/dist/mjs/utils/convexHull2Of.mjs
  var convexHull2Of = (points) => {
    if (points.length === 0) {
      return [];
    }
    const lowestPoint = points.reduce((lowest, current) => current.y < lowest.y ? current : lowest, points[0]);
    const vertices = [lowestPoint];
    let toProcess = [...points.filter((p) => !p.eq(lowestPoint))];
    let lastBaseDirection = Vec2.of(-1, 0);
    while (toProcess.length > 0) {
      const lastVertex = vertices[vertices.length - 1];
      let smallestDotProductSoFar = lastBaseDirection.dot(lowestPoint.minus(lastVertex).normalizedOrZero());
      let furthestPointSoFar = lowestPoint;
      for (const point of toProcess) {
        const currentDotProduct = lastBaseDirection.dot(point.minus(lastVertex).normalizedOrZero());
        if (currentDotProduct <= smallestDotProductSoFar) {
          furthestPointSoFar = point;
          smallestDotProductSoFar = currentDotProduct;
        }
      }
      toProcess = toProcess.filter((p) => !p.eq(furthestPointSoFar));
      const newBaseDirection = furthestPointSoFar.minus(lastVertex).normalized();
      if (Math.abs(newBaseDirection.dot(lastBaseDirection)) === 1 && vertices.length > 1) {
        vertices.pop();
      }
      if (furthestPointSoFar.eq(lowestPoint)) {
        break;
      } else {
        vertices.push(furthestPointSoFar);
        lastBaseDirection = lastVertex.minus(furthestPointSoFar).normalized();
      }
    }
    return vertices;
  };
  var convexHull2Of_default = convexHull2Of;

  // node_modules/@js-draw/math/dist/mjs/shapes/Path.mjs
  var PathCommandType;
  (function(PathCommandType2) {
    PathCommandType2[PathCommandType2["LineTo"] = 0] = "LineTo";
    PathCommandType2[PathCommandType2["MoveTo"] = 1] = "MoveTo";
    PathCommandType2[PathCommandType2["CubicBezierTo"] = 2] = "CubicBezierTo";
    PathCommandType2[PathCommandType2["QuadraticBezierTo"] = 3] = "QuadraticBezierTo";
  })(PathCommandType || (PathCommandType = {}));
  var compareCurveIndices = (a, b) => {
    const indexCompare = a.curveIndex - b.curveIndex;
    if (indexCompare === 0) {
      return a.parameterValue - b.parameterValue;
    } else {
      return indexCompare;
    }
  };
  var stepCurveIndexBy = (index, stepBy) => {
    if (index.parameterValue + stepBy > 1) {
      return { curveIndex: index.curveIndex + 1, parameterValue: index.parameterValue + stepBy - 1 };
    }
    if (index.parameterValue + stepBy < 0) {
      if (index.curveIndex === 0) {
        return { curveIndex: 0, parameterValue: 0 };
      }
      return { curveIndex: index.curveIndex - 1, parameterValue: index.parameterValue + stepBy + 1 };
    }
    return { curveIndex: index.curveIndex, parameterValue: index.parameterValue + stepBy };
  };
  var Path = class _Path {
    /**
     * Creates a new `Path` that starts at `startPoint` and is made up of the path commands,
     * `parts`.
     *
     * See also {@link fromString}
     */
    constructor(startPoint, parts) {
      this.startPoint = startPoint;
      this.cachedGeometry = null;
      this.cachedPolylineApproximation = null;
      this.cachedStringVersion = null;
      this.parts = parts;
      this.bbox = Rect2_default.bboxOf([startPoint]);
      for (const part of this.parts) {
        this.bbox = this.bbox.union(_Path.computeBBoxForSegment(startPoint, part));
      }
    }
    /**
     * Computes and returns the full bounding box for this path.
     *
     * If a slight over-estimate of a path's bounding box is sufficient, use
     * {@link bbox} instead.
     */
    getExactBBox() {
      const bboxes = [];
      for (const part of this.geometry) {
        bboxes.push(part.getTightBoundingBox());
      }
      return Rect2_default.union(...bboxes);
    }
    // Lazy-loads and returns this path's geometry
    get geometry() {
      if (this.cachedGeometry) {
        return this.cachedGeometry;
      }
      let startPoint = this.startPoint;
      const geometry = [];
      for (const part of this.parts) {
        let exhaustivenessCheck;
        switch (part.kind) {
          case PathCommandType.CubicBezierTo:
            geometry.push(new CubicBezier_default(startPoint, part.controlPoint1, part.controlPoint2, part.endPoint));
            startPoint = part.endPoint;
            break;
          case PathCommandType.QuadraticBezierTo:
            geometry.push(new QuadraticBezier_default(startPoint, part.controlPoint, part.endPoint));
            startPoint = part.endPoint;
            break;
          case PathCommandType.LineTo:
            geometry.push(new LineSegment2_default(startPoint, part.point));
            startPoint = part.point;
            break;
          case PathCommandType.MoveTo:
            geometry.push(new PointShape2D_default(part.point));
            startPoint = part.point;
            break;
          default:
            exhaustivenessCheck = part;
            return exhaustivenessCheck;
        }
      }
      this.cachedGeometry = geometry;
      return this.cachedGeometry;
    }
    /**
     * Iterates through the start/end points of each component in this path.
     *
     * If a start point is equivalent to the end point of the previous segment,
     * the point is **not** emitted twice.
     */
    *startEndPoints() {
      yield this.startPoint;
      for (const part of this.parts) {
        let exhaustivenessCheck;
        switch (part.kind) {
          case PathCommandType.CubicBezierTo:
            yield part.endPoint;
            break;
          case PathCommandType.QuadraticBezierTo:
            yield part.endPoint;
            break;
          case PathCommandType.LineTo:
            yield part.point;
            break;
          case PathCommandType.MoveTo:
            yield part.point;
            break;
          default:
            exhaustivenessCheck = part;
            return exhaustivenessCheck;
        }
      }
    }
    // Approximates this path with a group of line segments.
    polylineApproximation() {
      if (this.cachedPolylineApproximation) {
        return this.cachedPolylineApproximation;
      }
      const points = [];
      for (const part of this.parts) {
        switch (part.kind) {
          case PathCommandType.CubicBezierTo:
            points.push(part.controlPoint1, part.controlPoint2, part.endPoint);
            break;
          case PathCommandType.QuadraticBezierTo:
            points.push(part.controlPoint, part.endPoint);
            break;
          case PathCommandType.MoveTo:
          case PathCommandType.LineTo:
            points.push(part.point);
            break;
        }
      }
      const result = [];
      let prevPoint = this.startPoint;
      for (const point of points) {
        result.push(new LineSegment2_default(prevPoint, point));
        prevPoint = point;
      }
      return result;
    }
    static computeBBoxForSegment(startPoint, part) {
      const points = [startPoint];
      let exhaustivenessCheck;
      switch (part.kind) {
        case PathCommandType.MoveTo:
        case PathCommandType.LineTo:
          points.push(part.point);
          break;
        case PathCommandType.CubicBezierTo:
          points.push(part.controlPoint1, part.controlPoint2, part.endPoint);
          break;
        case PathCommandType.QuadraticBezierTo:
          points.push(part.controlPoint, part.endPoint);
          break;
        default:
          exhaustivenessCheck = part;
          return exhaustivenessCheck;
      }
      return Rect2_default.bboxOf(points);
    }
    /**
     * Returns the signed distance between `point` and a curve `strokeRadius` units
     * away from this path.
     *
     * This returns the **signed distance**, which means that points inside this shape
     * have their distance negated. For example,
     * ```ts,runnable,console
     * import {Path, Vec2} from '@js-draw/math';
     * console.log(Path.fromString('m0,0 L100,0').signedDistance(Vec2.zero, 1));
     * ```
     * would print `-1` because (0,0) is on `m0,0 L100,0` and thus one unit away from its boundary.
     *
     * **Note**: `strokeRadius = strokeWidth / 2`
     */
    signedDistance(point, strokeRadius) {
      let minDist = Infinity;
      for (const part of this.geometry) {
        const currentDist = part.signedDistance(point) - strokeRadius;
        if (currentDist < minDist) {
          minDist = currentDist;
        }
      }
      return minDist;
    }
    /**
     * Let `S` be a closed path a distance `strokeRadius` from this path.
     *
     * @returns Approximate intersections of `line` with `S` using ray marching, starting from
     * 	        both end points of `line` and each point in `additionalRaymarchStartPoints`.
     */
    raymarchIntersectionWith(line, strokeRadius, additionalRaymarchStartPoints = []) {
      if (!line.bbox.intersects(this.bbox.grownBy(strokeRadius))) {
        return [];
      }
      const lineLength = line.length;
      const partDistFunctionRecords = [];
      for (const part of this.geometry) {
        const bbox = part.getTightBoundingBox().grownBy(strokeRadius);
        if (!bbox.intersects(line.bbox)) {
          continue;
        }
        const partDist = (point) => part.signedDistance(point);
        const partSdf = (point) => partDist(point) - strokeRadius;
        if (partSdf(line.p1) > lineLength && partSdf(line.p2) > lineLength) {
          continue;
        }
        partDistFunctionRecords.push({
          part,
          distFn: partDist,
          bbox
        });
      }
      if (partDistFunctionRecords.length === 0) {
        return [];
      }
      const sdf = (point) => {
        let minDist = Infinity;
        let minDistPart = null;
        const uncheckedDistFunctions = [];
        for (const distFnRecord of partDistFunctionRecords) {
          const { part, distFn, bbox } = distFnRecord;
          if (!bbox.containsPoint(point)) {
            uncheckedDistFunctions.push(distFnRecord);
            continue;
          }
          const currentDist = distFn(point);
          if (currentDist <= minDist) {
            minDist = currentDist;
            minDistPart = part;
          }
        }
        for (const { part, distFn, bbox } of uncheckedDistFunctions) {
          if (isFinite(minDist) && !bbox.grownBy(minDist).containsPoint(point)) {
            continue;
          }
          const currentDist = distFn(point);
          if (currentDist <= minDist) {
            minDist = currentDist;
            minDistPart = part;
          }
        }
        return [minDistPart, minDist - strokeRadius];
      };
      const maxRaymarchSteps = 8;
      const startPoints = [line.p1, ...additionalRaymarchStartPoints, line.p2];
      const pointToParameter = (point) => {
        return point.minus(line.p1).dot(line.direction);
      };
      startPoints.sort((a, b) => {
        const t_a = pointToParameter(a);
        const t_b = pointToParameter(b);
        return t_a - t_b;
      });
      const result = [];
      const stoppingThreshold = strokeRadius / 1e3;
      const raymarchFrom = (startPoint, directionMultiplier, minimumLineParameter) => {
        let currentPoint = startPoint;
        let [lastPart, lastDist] = sdf(currentPoint);
        let lastParameter = pointToParameter(currentPoint);
        if (lastDist > lineLength) {
          return lastParameter;
        }
        const direction = line.direction.times(directionMultiplier);
        for (let i = 0; i < maxRaymarchSteps; i++) {
          const step = lastDist;
          currentPoint = currentPoint.plus(direction.times(step));
          lastParameter = pointToParameter(currentPoint);
          if (lastParameter <= minimumLineParameter) {
            return lastParameter;
          }
          const [currentPart, signedDist] = sdf(currentPoint);
          if (Math.abs(signedDist) > Math.abs(lastDist)) {
            return null;
          }
          lastDist = signedDist;
          lastPart = currentPart;
          if (Math.abs(lastDist) < stoppingThreshold) {
            break;
          }
        }
        const isOnLineSegment = lastParameter >= 0 && lastParameter <= lineLength;
        if (lastPart && isOnLineSegment && Math.abs(lastDist) < stoppingThreshold) {
          result.push({
            point: currentPoint,
            parameterValue: lastPart.nearestPointTo(currentPoint).parameterValue,
            curve: lastPart,
            curveIndex: this.geometry.indexOf(lastPart)
          });
          const parameterIncrease = strokeRadius / 20 / line.length;
          lastParameter += isFinite(parameterIncrease) ? parameterIncrease : 0;
        }
        return lastParameter;
      };
      let maxLineT = 0;
      for (let i = 0; i < startPoints.length; i++) {
        const startPoint = startPoints[i];
        maxLineT = Math.max(maxLineT, raymarchFrom(startPoint, 1, maxLineT) ?? maxLineT);
        maxLineT = Math.max(maxLineT, raymarchFrom(startPoint, -1, maxLineT) ?? maxLineT);
      }
      return result;
    }
    /**
     * Returns a list of intersections with this path. If `strokeRadius` is given,
     * intersections are approximated with the surface `strokeRadius` away from this.
     *
     * If `strokeRadius > 0`, the resultant `parameterValue` has no defined value.
     *
     * **Note**: `strokeRadius` is half of a stroke's width.
     */
    intersection(line, strokeRadius) {
      let result = [];
      if (!line.bbox.intersects(this.bbox.grownBy(strokeRadius ?? 0))) {
        return [];
      }
      if (this.parts.length === 0) {
        return new _Path(this.startPoint, [
          { kind: PathCommandType.MoveTo, point: this.startPoint }
        ]).intersection(line, strokeRadius);
      }
      let index = 0;
      for (const part of this.geometry) {
        const intersections = part.argIntersectsLineSegment(line);
        for (const intersection of intersections) {
          result.push({
            curve: part,
            curveIndex: index,
            point: part.at(intersection),
            parameterValue: intersection
          });
        }
        index++;
      }
      const doRaymarching = strokeRadius && strokeRadius > 1e-8;
      if (doRaymarching) {
        const startPoints = result.map((intersection) => intersection.point);
        result = this.raymarchIntersectionWith(line, strokeRadius, startPoints);
      }
      return result;
    }
    /**
     * @returns the nearest point on this path to the given `point`.
     */
    nearestPointTo(point) {
      let closestSquareDist = Infinity;
      let closestPartIndex = 0;
      let closestParameterValue = 0;
      let closestPoint = this.startPoint;
      for (let i = 0; i < this.geometry.length; i++) {
        const current = this.geometry[i];
        const nearestPoint = current.nearestPointTo(point);
        const sqareDist = nearestPoint.point.squareDistanceTo(point);
        if (i === 0 || sqareDist < closestSquareDist) {
          closestPartIndex = i;
          closestSquareDist = sqareDist;
          closestParameterValue = nearestPoint.parameterValue;
          closestPoint = nearestPoint.point;
        }
      }
      return {
        curve: this.geometry[closestPartIndex],
        curveIndex: closestPartIndex,
        parameterValue: closestParameterValue,
        point: closestPoint
      };
    }
    at(index) {
      if (index.curveIndex === 0 && index.parameterValue === 0) {
        return this.startPoint;
      }
      return this.geometry[index.curveIndex].at(index.parameterValue);
    }
    tangentAt(index) {
      return this.geometry[index.curveIndex].tangentAt(index.parameterValue);
    }
    /** Splits this path in two near the given `point`. */
    splitNear(point, options) {
      const nearest = this.nearestPointTo(point);
      return this.splitAt(nearest, options);
    }
    /**
     * Returns a copy of this path with `deleteFrom` until `deleteUntil` replaced with `insert`.
     *
     * This method is analogous to {@link Array.toSpliced}.
     */
    spliced(deleteFrom, deleteTo, insert, options) {
      const isBeforeOrEqual = (a, b) => {
        return a.curveIndex < b.curveIndex || a.curveIndex === b.curveIndex && a.parameterValue <= b.parameterValue;
      };
      if (isBeforeOrEqual(deleteFrom, deleteTo)) {
        const firstSplit = this.splitAt(deleteFrom, options);
        const secondSplit = this.splitAt(deleteTo, options);
        const before = firstSplit[0];
        const after = secondSplit[secondSplit.length - 1];
        return insert ? before.union(insert).union(after) : before.union(after);
      } else {
        const splitAtFrom = this.splitAt([deleteFrom], options);
        const beforeFrom = splitAtFrom[0];
        const splitAtTo = beforeFrom.splitNear(this.at(deleteTo), options);
        const betweenBoth = splitAtTo[splitAtTo.length - 1];
        return insert ? betweenBoth.union(insert) : betweenBoth;
      }
    }
    // @internal
    splitAt(splitAt, options) {
      if (!Array.isArray(splitAt)) {
        splitAt = [splitAt];
      }
      splitAt = [...splitAt];
      splitAt.sort(compareCurveIndices);
      while (splitAt.length > 0 && splitAt[splitAt.length - 1].curveIndex >= this.parts.length - 1 && splitAt[splitAt.length - 1].parameterValue >= 1) {
        splitAt.pop();
      }
      splitAt.reverse();
      while (splitAt.length > 0 && splitAt[splitAt.length - 1].curveIndex <= 0 && splitAt[splitAt.length - 1].parameterValue <= 0) {
        splitAt.pop();
      }
      if (splitAt.length === 0 || this.parts.length === 0) {
        return [this];
      }
      const expectedSplitCount = splitAt.length + 1;
      const mapNewPoint = options?.mapNewPoint ?? ((p) => p);
      const result = [];
      let currentStartPoint = this.startPoint;
      let currentPath = [];
      let { curveIndex, parameterValue } = splitAt.pop();
      for (let i = 0; i < this.parts.length; i++) {
        if (i !== curveIndex) {
          currentPath.push(this.parts[i]);
        } else {
          let part = this.parts[i];
          let geom = this.geometry[i];
          while (i === curveIndex) {
            let newPathStart;
            const newPath = [];
            switch (part.kind) {
              case PathCommandType.MoveTo:
                currentPath.push({
                  kind: part.kind,
                  point: part.point
                });
                newPathStart = part.point;
                break;
              case PathCommandType.LineTo:
                {
                  const split = geom.splitAt(parameterValue);
                  currentPath.push({
                    kind: part.kind,
                    point: mapNewPoint(split[0].p2)
                  });
                  newPathStart = split[0].p2;
                  if (split.length > 1) {
                    console.assert(split.length === 2);
                    newPath.push({
                      kind: part.kind,
                      // Don't map: For lines, the end point of the split is
                      // the same as the end point of the original:
                      point: split[1].p2
                    });
                    geom = split[1];
                  }
                }
                break;
              case PathCommandType.QuadraticBezierTo:
              case PathCommandType.CubicBezierTo:
                {
                  const split = geom.splitAt(parameterValue);
                  let isFirstPart = split.length === 2;
                  for (const segment of split) {
                    geom = segment;
                    const targetArray = isFirstPart ? currentPath : newPath;
                    const controlPoints = segment.getPoints();
                    if (part.kind === PathCommandType.CubicBezierTo) {
                      targetArray.push({
                        kind: part.kind,
                        controlPoint1: mapNewPoint(controlPoints[1]),
                        controlPoint2: mapNewPoint(controlPoints[2]),
                        endPoint: mapNewPoint(controlPoints[3])
                      });
                    } else {
                      targetArray.push({
                        kind: part.kind,
                        controlPoint: mapNewPoint(controlPoints[1]),
                        endPoint: mapNewPoint(controlPoints[2])
                      });
                    }
                    if (!isFirstPart) {
                      newPathStart = controlPoints[0];
                    }
                    isFirstPart = false;
                  }
                }
                break;
              default: {
                const exhaustivenessCheck = part;
                return exhaustivenessCheck;
              }
            }
            result.push(new _Path(currentStartPoint, [...currentPath]));
            currentStartPoint = mapNewPoint(newPathStart);
            console.assert(!!currentStartPoint, "should have a start point");
            currentPath = newPath;
            part = newPath[newPath.length - 1] ?? part;
            const nextSplit = splitAt.pop();
            if (!nextSplit) {
              break;
            } else {
              curveIndex = nextSplit.curveIndex;
              if (i === curveIndex) {
                const originalPoint = this.at(nextSplit);
                parameterValue = geom.nearestPointTo(originalPoint).parameterValue;
                currentPath = [];
              } else {
                parameterValue = nextSplit.parameterValue;
              }
            }
          }
        }
      }
      result.push(new _Path(currentStartPoint, currentPath));
      console.assert(result.length === expectedSplitCount, `should split into splitAt.length + 1 splits (was ${result.length}, expected ${expectedSplitCount})`);
      return result;
    }
    /**
     * Replaces all `MoveTo` commands with `LineTo` commands and connects the end point of this
     * path to the start point.
     */
    asClosed() {
      const newParts = [];
      let hasChanges = false;
      for (const part of this.parts) {
        if (part.kind === PathCommandType.MoveTo) {
          newParts.push({
            kind: PathCommandType.LineTo,
            point: part.point
          });
          hasChanges = true;
        } else {
          newParts.push(part);
        }
      }
      if (!this.getEndPoint().eq(this.startPoint)) {
        newParts.push({
          kind: PathCommandType.LineTo,
          point: this.startPoint
        });
        hasChanges = true;
      }
      if (!hasChanges) {
        return this;
      }
      const result = new _Path(this.startPoint, newParts);
      console.assert(result.getEndPoint().eq(result.startPoint));
      return result;
    }
    static mapPathCommand(part, mapping) {
      switch (part.kind) {
        case PathCommandType.MoveTo:
        case PathCommandType.LineTo:
          return {
            kind: part.kind,
            point: mapping(part.point)
          };
          break;
        case PathCommandType.CubicBezierTo:
          return {
            kind: part.kind,
            controlPoint1: mapping(part.controlPoint1),
            controlPoint2: mapping(part.controlPoint2),
            endPoint: mapping(part.endPoint)
          };
          break;
        case PathCommandType.QuadraticBezierTo:
          return {
            kind: part.kind,
            controlPoint: mapping(part.controlPoint),
            endPoint: mapping(part.endPoint)
          };
          break;
      }
      const exhaustivenessCheck = part;
      return exhaustivenessCheck;
    }
    mapPoints(mapping) {
      const startPoint = mapping(this.startPoint);
      const newParts = [];
      for (const part of this.parts) {
        newParts.push(_Path.mapPathCommand(part, mapping));
      }
      return new _Path(startPoint, newParts);
    }
    transformedBy(affineTransfm) {
      if (affineTransfm.isIdentity()) {
        return this;
      }
      return this.mapPoints((point) => affineTransfm.transformVec2(point));
    }
    /**
     * @internal -- TODO: This method may have incorrect output in some cases.
     */
    closedContainsPoint(point) {
      const bbox = this.getExactBBox();
      if (!bbox.containsPoint(point)) {
        return false;
      }
      const pointOutside = point.plus(Vec2.of(bbox.width, 0));
      const asClosed = this.asClosed();
      const lineToOutside = new LineSegment2_default(point, pointOutside);
      const intersections = asClosed.intersection(lineToOutside);
      const filteredIntersections = intersections.filter((intersection, index) => {
        if (index === 0)
          return true;
        const previousIntersection = intersections[index - 1];
        const isRepeatedIntersection = previousIntersection.parameterValue >= 1 && intersection.parameterValue <= 0;
        return !isRepeatedIntersection;
      });
      return filteredIntersections.length % 2 === 1;
    }
    /**
     * @returns `true` if this path (interpreted as a closed path) contains the given rectangle.
     */
    closedContainsRect(rect) {
      if (!this.bbox.containsRect(rect))
        return false;
      if (!rect.corners.every((corner) => this.closedContainsPoint(corner)))
        return false;
      for (const edge of rect.getEdges()) {
        if (this.intersection(edge).length) {
          return false;
        }
      }
      return true;
    }
    // Creates a new path by joining [other] to the end of this path
    union(other, options = { allowReverse: true }) {
      if (!other) {
        return this;
      }
      if (Array.isArray(other)) {
        return new _Path(this.startPoint, [...this.parts, ...other]);
      }
      const thisEnd = this.getEndPoint();
      let newParts = [];
      if (thisEnd.eq(other.startPoint)) {
        newParts = this.parts.concat(other.parts);
      } else if (options.allowReverse && this.startPoint.eq(other.getEndPoint())) {
        return other.union(this, { allowReverse: false });
      } else if (options.allowReverse && this.startPoint.eq(other.startPoint)) {
        return this.union(other.reversed(), { allowReverse: false });
      } else {
        newParts = [
          ...this.parts,
          {
            kind: PathCommandType.MoveTo,
            point: other.startPoint
          },
          ...other.parts
        ];
      }
      return new _Path(this.startPoint, newParts);
    }
    /**
     * @returns a version of this path with the direction reversed.
     *
     * Example:
     * ```ts,runnable,console
     * import {Path} from '@js-draw/math';
     * console.log(Path.fromString('m0,0l1,1').reversed()); // -> M1,1 L0,0
     * ```
     */
    reversed() {
      const newStart = this.getEndPoint();
      const newParts = [];
      let lastPoint = this.startPoint;
      for (const part of this.parts) {
        switch (part.kind) {
          case PathCommandType.LineTo:
          case PathCommandType.MoveTo:
            newParts.push({
              kind: part.kind,
              point: lastPoint
            });
            lastPoint = part.point;
            break;
          case PathCommandType.CubicBezierTo:
            newParts.push({
              kind: part.kind,
              controlPoint1: part.controlPoint2,
              controlPoint2: part.controlPoint1,
              endPoint: lastPoint
            });
            lastPoint = part.endPoint;
            break;
          case PathCommandType.QuadraticBezierTo:
            newParts.push({
              kind: part.kind,
              controlPoint: part.controlPoint,
              endPoint: lastPoint
            });
            lastPoint = part.endPoint;
            break;
          default: {
            const exhaustivenessCheck = part;
            return exhaustivenessCheck;
          }
        }
      }
      newParts.reverse();
      return new _Path(newStart, newParts);
    }
    /** Computes and returns the end point of this path */
    getEndPoint() {
      if (this.parts.length === 0) {
        return this.startPoint;
      }
      const lastPart = this.parts[this.parts.length - 1];
      if (lastPart.kind === PathCommandType.QuadraticBezierTo || lastPart.kind === PathCommandType.CubicBezierTo) {
        return lastPart.endPoint;
      } else {
        return lastPart.point;
      }
    }
    /**
     * Like {@link closedRoughlyIntersects} except takes stroke width into account.
     *
     * This is intended to be a very fast and rough approximation. Use {@link intersection}
     * and {@link signedDistance} for more accurate (but much slower) intersection calculations.
     *
     * **Note**: Unlike other methods, this accepts `strokeWidth` (and not `strokeRadius`).
     *
     * `strokeRadius` is half of `strokeWidth`.
     */
    roughlyIntersects(rect, strokeWidth = 0) {
      if (this.parts.length === 0) {
        return rect.containsPoint(this.startPoint);
      }
      const isClosed = this.startPoint.eq(this.getEndPoint());
      if (isClosed && strokeWidth === 0) {
        return this.closedRoughlyIntersects(rect);
      }
      if (rect.containsRect(this.bbox)) {
        return true;
      }
      let startPoint = this.startPoint;
      for (const part of this.parts) {
        const bbox = _Path.computeBBoxForSegment(startPoint, part).grownBy(strokeWidth);
        if (part.kind === PathCommandType.LineTo || part.kind === PathCommandType.MoveTo) {
          startPoint = part.point;
        } else {
          startPoint = part.endPoint;
        }
        if (rect.intersects(bbox)) {
          return true;
        }
      }
      return false;
    }
    /**
     * Treats this as a closed path and returns true if part of `rect` is *roughly* within
     * this path's interior.
     *
     * **Note**: Assumes that this is a closed, non-self-intersecting path.
     */
    closedRoughlyIntersects(rect) {
      if (rect.containsRect(this.bbox)) {
        return true;
      }
      const startPt = this.bbox.topLeft.minus(Vec2.of(1, 1));
      const testPts = rect.corners;
      const polygon = this.polylineApproximation();
      for (const point of testPts) {
        const testLine = new LineSegment2_default(point, startPt);
        let intersectionCount = 0;
        for (const line of polygon) {
          if (line.intersects(testLine)) {
            intersectionCount++;
          }
        }
        if (intersectionCount % 2 === 1) {
          return true;
        }
      }
      const grownRect = rect.grownBy(Math.min(rect.size.x, rect.size.y));
      const edges = [];
      for (const subrect of grownRect.divideIntoGrid(4, 4)) {
        edges.push(...subrect.getEdges());
      }
      for (const edge of edges) {
        for (const line of polygon) {
          if (edge.intersects(line)) {
            return true;
          }
        }
      }
      return false;
    }
    /** @returns true if all points on this are equivalent to the points on `other` */
    eq(other, tolerance) {
      if (other.parts.length !== this.parts.length) {
        return false;
      }
      for (let i = 0; i < this.parts.length; i++) {
        const part1 = this.parts[i];
        const part2 = other.parts[i];
        switch (part1.kind) {
          case PathCommandType.LineTo:
          case PathCommandType.MoveTo:
            if (part1.kind !== part2.kind) {
              return false;
            } else if (!part1.point.eq(part2.point, tolerance)) {
              return false;
            }
            break;
          case PathCommandType.CubicBezierTo:
            if (part1.kind !== part2.kind) {
              return false;
            } else if (!part1.controlPoint1.eq(part2.controlPoint1, tolerance) || !part1.controlPoint2.eq(part2.controlPoint2, tolerance) || !part1.endPoint.eq(part2.endPoint, tolerance)) {
              return false;
            }
            break;
          case PathCommandType.QuadraticBezierTo:
            if (part1.kind !== part2.kind) {
              return false;
            } else if (!part1.controlPoint.eq(part2.controlPoint, tolerance) || !part1.endPoint.eq(part2.endPoint, tolerance)) {
              return false;
            }
            break;
          default: {
            const exhaustivenessCheck = part1;
            return exhaustivenessCheck;
          }
        }
      }
      return true;
    }
    /**
     * Returns a path that outlines `rect`.
     *
     * If `lineWidth` is given, the resultant path traces a `lineWidth` thick
     * border around `rect`. Otherwise, the resultant path is just the border
     * of `rect`.
     */
    static fromRect(rect, lineWidth = null) {
      const commands = [];
      let corners;
      let startPoint;
      if (lineWidth !== null) {
        const cornerToEdge = Vec2.of(lineWidth, lineWidth).times(0.5);
        const innerRect = Rect2_default.fromCorners(rect.topLeft.plus(cornerToEdge), rect.bottomRight.minus(cornerToEdge));
        const outerRect = Rect2_default.fromCorners(rect.topLeft.minus(cornerToEdge), rect.bottomRight.plus(cornerToEdge));
        corners = [innerRect.corners[3], ...innerRect.corners, ...outerRect.corners.reverse()];
        startPoint = outerRect.corners[3];
      } else {
        corners = rect.corners.slice(1);
        startPoint = rect.corners[0];
      }
      for (const corner of corners) {
        commands.push({
          kind: PathCommandType.LineTo,
          point: corner
        });
      }
      commands.push({
        kind: PathCommandType.LineTo,
        point: startPoint
      });
      return new _Path(startPoint, commands);
    }
    /**
     * Convert to an [SVG path representation](https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths).
     *
     * If `useNonAbsCommands` is given, relative path commands (e.g. `l10,0`) are to be used instead of
     * absolute commands (e.g. `L10,0`).
     *
     * See also {@link fromString}.
     */
    toString(useNonAbsCommands, ignoreCache = false) {
      if (this.cachedStringVersion && !ignoreCache) {
        return this.cachedStringVersion;
      }
      if (useNonAbsCommands === void 0) {
        useNonAbsCommands = Math.abs(this.bbox.topLeft.x) > 10 && Math.abs(this.bbox.topLeft.y) > 10;
      }
      const result = _Path.toString(this.startPoint, this.parts, !useNonAbsCommands);
      this.cachedStringVersion = result;
      return result;
    }
    serialize() {
      return this.toString();
    }
    // @param onlyAbsCommands - True if we should avoid converting absolute coordinates to relative offsets -- such
    //   conversions can lead to smaller output strings, but also take time.
    static toString(startPoint, parts, onlyAbsCommands) {
      const result = [];
      let prevPoint;
      const addCommand = (command, ...points) => {
        const absoluteCommandParts = [];
        const relativeCommandParts = [];
        const makeAbsCommand = !prevPoint || onlyAbsCommands;
        const roundedPrevX = prevPoint ? toRoundedString_default(prevPoint.x) : "";
        const roundedPrevY = prevPoint ? toRoundedString_default(prevPoint.y) : "";
        for (const point of points) {
          const xComponent = toRoundedString_default(point.x);
          const yComponent = toRoundedString_default(point.y);
          if (!makeAbsCommand) {
            const xComponentRelative = toStringOfSamePrecision_default(point.x - prevPoint.x, xComponent, roundedPrevX, roundedPrevY);
            const yComponentRelative = toStringOfSamePrecision_default(point.y - prevPoint.y, yComponent, roundedPrevX, roundedPrevY);
            if (yComponentRelative.charAt(0) === "-") {
              relativeCommandParts.push(`${xComponentRelative}${yComponentRelative}`);
            } else {
              relativeCommandParts.push(`${xComponentRelative},${yComponentRelative}`);
            }
          } else {
            absoluteCommandParts.push(`${xComponent},${yComponent}`);
          }
        }
        let commandString;
        if (makeAbsCommand) {
          commandString = `${command}${absoluteCommandParts.join(" ")}`;
        } else {
          commandString = `${command.toLowerCase()}${relativeCommandParts.join(" ")}`;
        }
        if (commandString === "l0,0" || commandString === "m0,0") {
          return;
        }
        result.push(commandString);
        if (points.length > 0) {
          prevPoint = points[points.length - 1];
        }
      };
      if (parts[0]?.kind !== PathCommandType.MoveTo) {
        addCommand("M", startPoint);
      }
      let exhaustivenessCheck;
      for (let i = 0; i < parts.length; i++) {
        const part = parts[i];
        switch (part.kind) {
          case PathCommandType.MoveTo:
            addCommand("M", part.point);
            break;
          case PathCommandType.LineTo:
            addCommand("L", part.point);
            break;
          case PathCommandType.CubicBezierTo:
            addCommand("C", part.controlPoint1, part.controlPoint2, part.endPoint);
            break;
          case PathCommandType.QuadraticBezierTo:
            addCommand("Q", part.controlPoint, part.endPoint);
            break;
          default:
            exhaustivenessCheck = part;
            return exhaustivenessCheck;
        }
      }
      return result.join("");
    }
    /**
     * Create a `Path` from a subset of the SVG path specification.
     *
     * Currently, this does not support elliptical arcs or `s` and `t` command
     * shorthands. See https://github.com/personalizedrefrigerator/js-draw/pull/19.
     *
     * @example
     * ```ts,runnable,console
     * import { Path } from '@js-draw/math';
     *
     * const path = Path.fromString('m0,0l100,100');
     * console.log(path.toString(true)); // true: Prefer relative to absolute path commands
     * ```
     */
    static fromString(pathString) {
      pathString = pathString.split("\n").join(" ");
      let lastPos = Vec2.zero;
      let firstPos = null;
      let startPos = null;
      let isFirstCommand = true;
      const commands = [];
      const moveTo = (point) => {
        if (isFirstCommand) {
          isFirstCommand = false;
          return;
        }
        commands.push({
          kind: PathCommandType.MoveTo,
          point
        });
      };
      const lineTo = (point) => {
        if (isFirstCommand) {
          isFirstCommand = false;
          return;
        }
        commands.push({
          kind: PathCommandType.LineTo,
          point
        });
      };
      const cubicBezierTo = (cp1, cp2, end) => {
        commands.push({
          kind: PathCommandType.CubicBezierTo,
          controlPoint1: cp1,
          controlPoint2: cp2,
          endPoint: end
        });
      };
      const quadraticBeierTo = (controlPoint, endPoint) => {
        commands.push({
          kind: PathCommandType.QuadraticBezierTo,
          controlPoint,
          endPoint
        });
      };
      const commandArgCounts = {
        m: 1,
        l: 1,
        c: 3,
        q: 2,
        z: 0,
        h: 1,
        v: 1
      };
      const commandExp = /([MZLHVCSQTA])\s*([^MZLHVCSQTA]*)/gi;
      let current;
      while ((current = commandExp.exec(pathString)) !== null) {
        const argParts = current[2].trim().split(/[^0-9Ee.-]/).filter((part) => part.length > 0).reduce((accumualtor, current2) => {
          current2 = current2.replace(/([^eE])[-]/g, "$1 -");
          const parts = current2.split(" -");
          if (parts[0] !== "") {
            accumualtor.push(parts[0]);
          }
          accumualtor.push(...parts.slice(1).map((part) => `-${part}`));
          return accumualtor;
        }, []);
        let numericArgs = argParts.map((arg) => parseFloat(arg));
        let commandChar = current[1].toLowerCase();
        let uppercaseCommand = current[1] !== commandChar;
        if (commandChar === "v" || commandChar === "h") {
          numericArgs = numericArgs.reduce((accumulator, current2) => {
            if (commandChar === "v") {
              return accumulator.concat(uppercaseCommand ? lastPos.x : 0, current2);
            } else {
              return accumulator.concat(current2, uppercaseCommand ? lastPos.y : 0);
            }
          }, []);
          commandChar = "l";
        } else if (commandChar === "z") {
          if (firstPos) {
            numericArgs = [firstPos.x, firstPos.y];
            firstPos = lastPos;
          } else {
            continue;
          }
          uppercaseCommand = true;
          commandChar = "l";
        }
        const commandArgCount = commandArgCounts[commandChar] ?? 0;
        const allArgs = numericArgs.reduce((accumulator, current2, index, parts) => {
          if (index % 2 !== 0) {
            const currentAsFloat = current2;
            const prevAsFloat = parts[index - 1];
            return accumulator.concat(Vec2.of(prevAsFloat, currentAsFloat));
          } else {
            return accumulator;
          }
        }, []).map((coordinate, index) => {
          let newPos;
          if (uppercaseCommand) {
            newPos = coordinate;
          } else {
            newPos = lastPos.plus(coordinate);
          }
          if ((index + 1) % commandArgCount === 0) {
            lastPos = newPos;
          }
          return newPos;
        });
        if (allArgs.length % commandArgCount !== 0) {
          throw new Error([
            `Incorrect number of arguments: got ${JSON.stringify(allArgs)} with a length of ${allArgs.length} \u2260 ${commandArgCount}k, k \u2208 \u2124.`,
            `The number of arguments to ${commandChar} must be a multiple of ${commandArgCount}!`,
            `Command: ${current[0]}`
          ].join("\n"));
        }
        for (let argPos = 0; argPos < allArgs.length; argPos += commandArgCount) {
          const args = allArgs.slice(argPos, argPos + commandArgCount);
          switch (commandChar.toLowerCase()) {
            case "m":
              if (argPos === 0) {
                moveTo(args[0]);
              } else {
                lineTo(args[0]);
              }
              break;
            case "l":
              lineTo(args[0]);
              break;
            case "c":
              cubicBezierTo(args[0], args[1], args[2]);
              break;
            case "q":
              quadraticBeierTo(args[0], args[1]);
              break;
            default:
              throw new Error(`Unknown path command ${commandChar}`);
          }
          isFirstCommand = false;
        }
        if (allArgs.length > 0) {
          firstPos ??= allArgs[0];
          startPos ??= firstPos;
          lastPos = allArgs[allArgs.length - 1];
        }
      }
      const result = new _Path(startPos ?? Vec2.zero, commands);
      result.cachedStringVersion = pathString;
      return result;
    }
    static fromConvexHullOf(points) {
      if (points.length === 0) {
        return _Path.empty;
      }
      const hull = convexHull2Of_default(points);
      const commands = hull.slice(1).map((p) => ({
        kind: PathCommandType.LineTo,
        point: p
      }));
      commands.push({
        kind: PathCommandType.LineTo,
        point: hull[0]
      });
      return new _Path(hull[0], commands);
    }
  };
  Path.empty = new Path(Vec2.zero, []);

  // node_modules/@js-draw/math/dist/mjs/Color4.mjs
  var Color4 = class _Color4 {
    constructor(r, g, b, a) {
      this.r = r;
      this.g = g;
      this.b = b;
      this.a = a;
      this.hexString = null;
    }
    /**
     * Create a color from red, green, blue components. The color is fully opaque (`a = 1.0`).
     *
     * Each component should be in the range [0, 1].
     */
    static ofRGB(red, green, blue) {
      return _Color4.ofRGBA(red, green, blue, 1);
    }
    /**
     * Creates a color from red, green, blue, and transparency components. Each component should
     * be in the range $[0, 1]$.
     */
    static ofRGBA(red, green, blue, alpha) {
      red = Math.max(0, Math.min(red, 1));
      green = Math.max(0, Math.min(green, 1));
      blue = Math.max(0, Math.min(blue, 1));
      alpha = Math.max(0, Math.min(alpha, 1));
      return new _Color4(red, green, blue, alpha);
    }
    /**
     * Creates a color from an RGB (or RGBA) array.
     *
     * This is similar to {@link ofRGB} and {@link ofRGBA}, but, by default, takes values
     * that range from 0 to 255.
     *
     * If the array values instead range from 0-1, pass `maxValue` as `1`.
     */
    static fromRGBArray(array, maxValue = 255) {
      const red = array[0];
      const green = array[1] ?? red;
      const blue = array[2] ?? red;
      let alpha = 255;
      if (3 < array.length) {
        alpha = array[3];
      }
      return _Color4.ofRGBA(red / maxValue, green / maxValue, blue / maxValue, alpha / maxValue);
    }
    /**
     * Creates a `Color4` from a three or four-component hexadecimal
     * [color string](https://en.wikipedia.org/wiki/Web_colors#Hex_triplet).
     *
     * Example:
     * ```ts,runnable,console
     * import { Color4 } from '@js-draw/math';
     * console.log(Color4.fromHex('#ff0'));
     * ```
     */
    static fromHex(hexString) {
      hexString = (hexString.match(/^[#]?(.*)$/) ?? [])[1];
      hexString = hexString.toUpperCase();
      if (!hexString.match(/^[0-9A-F]+$/)) {
        throw new Error(`${hexString} is not in a valid format.`);
      }
      if (hexString.length === 3 || hexString.length === 4) {
        const components2 = hexString.split("");
        hexString = components2.map((component) => `${component}0`).join("");
      }
      if (hexString.length === 6) {
        hexString += "FF";
      }
      const components = [];
      for (let i = 2; i <= hexString.length; i += 2) {
        const chunk = hexString.substring(i - 2, i);
        components.push(parseInt(chunk, 16) / 255);
      }
      if (components.length !== 4) {
        throw new Error(`Unable to parse ${hexString}: Wrong number of components.`);
      }
      return _Color4.ofRGBA(components[0], components[1], components[2], components[3]);
    }
    /** Like {@link fromHex}, but can handle additional colors if an `HTMLCanvasElement` is available. */
    static fromString(text) {
      if (text.startsWith("#")) {
        return _Color4.fromHex(text);
      }
      if (text === "none" || text === "transparent") {
        return _Color4.transparent;
      }
      if (text === "") {
        return _Color4.black;
      }
      const rgbRegex = /^rgba?\(([,0-9.]+)\)$/i;
      const rgbMatch = text.replace(/\s*/g, "").match(rgbRegex);
      if (rgbMatch) {
        const componentsListStr = rgbMatch[1];
        const componentsList = JSON.parse(`[ ${componentsListStr} ]`);
        if (componentsList.length === 3) {
          return _Color4.ofRGB(componentsList[0] / 255, componentsList[1] / 255, componentsList[2] / 255);
        } else if (componentsList.length === 4) {
          return _Color4.ofRGBA(componentsList[0] / 255, componentsList[1] / 255, componentsList[2] / 255, componentsList[3]);
        } else {
          throw new Error(`RGB string, ${text}, has wrong number of components: ${componentsList.length}`);
        }
      }
      const canvas = document.createElement("canvas");
      canvas.width = 1;
      canvas.height = 1;
      const ctx = canvas.getContext("2d");
      if (!ctx) {
        return _Color4.black;
      }
      ctx.fillStyle = text;
      ctx.fillRect(0, 0, 1, 1);
      const data = ctx.getImageData(0, 0, 1, 1);
      const red = data.data[0] / 255;
      const green = data.data[1] / 255;
      const blue = data.data[2] / 255;
      const alpha = data.data[3] / 255;
      return _Color4.ofRGBA(red, green, blue, alpha);
    }
    /** @returns true if `this` and `other` are approximately equal. */
    eq(other) {
      if (other == null) {
        return false;
      }
      if (this.a === 0 && other.a === 0) {
        return true;
      }
      return this.toHexString() === other.toHexString();
    }
    /**
     * If `fractionTo` is not in the range $[0, 1]$, it will be clamped to the nearest number
     * in that range. For example, `a.mix(b, -1)` is equivalent to `a.mix(b, 0)`.
     *
     * @returns a color `fractionTo` of the way from this color to `other`.
     *
     * @example
     * ```ts
     * Color4.ofRGB(1, 0, 0).mix(Color4.ofRGB(0, 1, 0), 0.1) // -> Color4(0.9, 0.1, 0)
     * ```
     */
    mix(other, fractionTo) {
      fractionTo = Math.min(Math.max(fractionTo, 0), 1);
      const fractionOfThis = 1 - fractionTo;
      return new _Color4(this.r * fractionOfThis + other.r * fractionTo, this.g * fractionOfThis + other.g * fractionTo, this.b * fractionOfThis + other.b * fractionTo, this.a * fractionOfThis + other.a * fractionTo);
    }
    /** Returns a new color with a different opacity. */
    withAlpha(a) {
      return new _Color4(this.r, this.g, this.b, a);
    }
    /**
     * Ignoring this color's alpha component, returns a vector with components,
     * $$
     * \begin{pmatrix} \colorbox{#F44}{\tt r} \\ \colorbox{#4F4}{\tt g} \\ \colorbox{#44F}{\tt b} \end{pmatrix}
     * $$
     */
    get rgb() {
      return Vec3_default.of(this.r, this.g, this.b);
    }
    /**
     * Returns the [relative luminance](https://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef)
     * of this color in the sRGB color space.
     *
     * Ignores the alpha component.
     */
    relativeLuminance() {
      const components = [this.r, this.g, this.b].map((component) => {
        if (component < 0.03928) {
          return component / 12.92;
        } else {
          return Math.pow((component + 0.055) / 1.055, 2.4);
        }
      });
      return 0.2126 * components[0] + 0.7152 * components[1] + 0.0722 * components[2];
    }
    /**
     * Returns the [contrast ratio](https://www.w3.org/TR/2008/REC-WCAG20-20081211/#contrast-ratiodef)
     * between `colorA` and `colorB`.
     */
    static contrastRatio(colorA, colorB) {
      const L1 = colorA.relativeLuminance();
      const L2 = colorB.relativeLuminance();
      return (Math.max(L1, L2) + 0.05) / (Math.min(L1, L2) + 0.05);
    }
    /**
     * @returns the component-wise average of `colors`, or `Color4.transparent` if `colors` is empty.
     */
    static average(colors) {
      let averageA = 0;
      let averageR = 0;
      let averageG = 0;
      let averageB = 0;
      for (const color of colors) {
        averageA += color.a;
        averageR += color.r;
        averageG += color.g;
        averageB += color.b;
      }
      if (colors.length > 0) {
        averageA /= colors.length;
        averageR /= colors.length;
        averageG /= colors.length;
        averageB /= colors.length;
      }
      return new _Color4(averageR, averageG, averageB, averageA);
    }
    /**
     * Converts to (hue, saturation, value).
     * See also https://en.wikipedia.org/wiki/HSL_and_HSV#General_approach
     *
     * The resultant hue is represented in radians and is thus in $[0, 2\pi]$.
     */
    asHSV() {
      const minComponent = Math.min(this.r, this.g, this.b);
      const maxComponent = Math.max(this.r, this.g, this.b);
      const chroma = maxComponent - minComponent;
      let hue;
      if (chroma === 0) {
        hue = 0;
      } else if (this.r >= this.g && this.r >= this.b) {
        hue = (this.g - this.b) / chroma % 6;
      } else if (this.g >= this.r && this.g >= this.b) {
        hue = (this.b - this.r) / chroma + 2;
      } else {
        hue = (this.r - this.g) / chroma + 4;
      }
      hue *= 60;
      hue *= Math.PI / 180;
      if (hue < 0) {
        hue += Math.PI * 2;
      }
      const value = maxComponent;
      const saturation = value > 0 ? chroma / value : 0;
      return Vec3_default.of(hue, saturation, value);
    }
    /**
     * Creates a new `Color4` from a representation [in $HSV$](https://en.wikipedia.org/wiki/HSL_and_HSV#HSV_to_RGB).
     *
     * [Algorithm](https://en.wikipedia.org/wiki/HSL_and_HSV#HSV_to_RGB).
     *
     * Note that hue must be given **in radians**. While non-standard, this is consistent with
     * {@link asHSV}.
     *
     * `hue` and `value` should range from 0 to 1.
     *
     * @param hue $H \in [0, 2\pi]$
     * @param saturation $S_V \in [0, 1]$
     * @param value $V \in [0, 1]$
     */
    static fromHSV(hue, saturation, value) {
      if (hue < 0) {
        hue += Math.PI * 2;
      }
      hue %= Math.PI * 2;
      value = Math.max(0, Math.min(1, value));
      saturation = Math.max(0, Math.min(1, saturation));
      const chroma = value * saturation;
      const huePrime = hue / (Math.PI / 3);
      const secondLargestComponent = chroma * (1 - Math.abs(huePrime % 2 - 1));
      let rgb;
      if (huePrime < 1) {
        rgb = [chroma, secondLargestComponent, 0];
      } else if (huePrime < 2) {
        rgb = [secondLargestComponent, chroma, 0];
      } else if (huePrime < 3) {
        rgb = [0, chroma, secondLargestComponent];
      } else if (huePrime < 4) {
        rgb = [0, secondLargestComponent, chroma];
      } else if (huePrime < 5) {
        rgb = [secondLargestComponent, 0, chroma];
      } else {
        rgb = [chroma, 0, secondLargestComponent];
      }
      const adjustment = value - chroma;
      return _Color4.ofRGB(rgb[0] + adjustment, rgb[1] + adjustment, rgb[2] + adjustment);
    }
    /**
     * Equivalent to `ofRGB(rgb.x, rgb.y, rgb.z)`.
     *
     * All components should be in the range `[0, 1]` (0 to 1 inclusive).
     */
    static fromRGBVector(rgb, alpha) {
      return _Color4.ofRGBA(rgb.x, rgb.y, rgb.z, alpha ?? 1);
    }
    /**
     * @returns a hexadecimal color string representation of `this`, in the form `#rrggbbaa`.
     *
     * @example
     * ```
     * Color4.red.toHexString(); // -> #ff0000ff
     * ```
     */
    toHexString() {
      if (this.hexString) {
        return this.hexString;
      }
      const componentToHex = (component) => {
        const res = Math.round(255 * component).toString(16);
        if (res.length === 1) {
          return `0${res}`;
        }
        return res;
      };
      const alpha = componentToHex(this.a);
      const red = componentToHex(this.r);
      const green = componentToHex(this.g);
      const blue = componentToHex(this.b);
      if (alpha === "ff") {
        return `#${red}${green}${blue}`;
      }
      this.hexString = `#${red}${green}${blue}${alpha}`;
      return this.hexString;
    }
    toString() {
      return this.toHexString();
    }
  };
  Color4.transparent = Color4.ofRGBA(0, 0, 0, 0);
  Color4.red = Color4.ofRGB(1, 0, 0);
  Color4.orange = Color4.ofRGB(1, 0.65, 0);
  Color4.green = Color4.ofRGB(0, 1, 0);
  Color4.blue = Color4.ofRGB(0, 0, 1);
  Color4.purple = Color4.ofRGB(0.5, 0.2, 0.5);
  Color4.yellow = Color4.ofRGB(1, 1, 0.1);
  Color4.clay = Color4.ofRGB(0.8, 0.4, 0.2);
  Color4.black = Color4.ofRGB(0, 0, 0);
  Color4.gray = Color4.ofRGB(0.5, 0.5, 0.5);
  Color4.white = Color4.ofRGB(1, 1, 1);

  // node_modules/js-draw/dist/mjs/util/describeTransformation.mjs
  var describeTransformation = (origin, transform, invertDirections, localizationTable) => {
    const linearTransformedVec = transform.transformVec3(Vec2.unitX);
    const affineTransformedVec = transform.transformVec2(origin);
    const scale = linearTransformedVec.magnitude();
    const clockwiseRotation = -(180 / Math.PI) * linearTransformedVec.angle();
    const translation = affineTransformedVec.minus(origin);
    const result = [];
    if (scale > 1.2) {
      result.push(localizationTable.zoomedIn);
    } else if (scale < 0.8) {
      result.push(localizationTable.zoomedOut);
    }
    if (Math.floor(Math.abs(clockwiseRotation)) > 0) {
      const roundedRotation = Math.round(invertDirections ? -clockwiseRotation : clockwiseRotation);
      result.push(localizationTable.rotatedBy(roundedRotation));
    }
    const minTranslation = 1e-4;
    if (translation.x > minTranslation) {
      result.push(invertDirections ? localizationTable.movedLeft : localizationTable.movedRight);
    } else if (translation.x < -minTranslation) {
      result.push(invertDirections ? localizationTable.movedRight : localizationTable.movedLeft);
    }
    if (translation.y < -minTranslation) {
      result.push(invertDirections ? localizationTable.movedDown : localizationTable.movedUp);
    } else if (translation.y > minTranslation) {
      result.push(invertDirections ? localizationTable.movedUp : localizationTable.movedDown);
    }
    return result.join("; ");
  };
  var describeTransformation_default = describeTransformation;

  // node_modules/js-draw/dist/mjs/Viewport.mjs
  var __classPrivateFieldSet2 = function(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var __classPrivateFieldGet2 = function(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var _inverseTransform;
  var _a;
  var ViewportTransform = class extends Command_default {
  };
  var Viewport = class _Viewport {
    // @internal
    constructor(onTransformChangeCallback) {
      this.onTransformChangeCallback = onTransformChangeCallback;
      this.resetTransform(Mat33.identity);
      this.screenRect = Rect2.empty;
    }
    /**
     * @returns a temporary copy of `this` that does not notify when modified. This is
     * useful when rendering with a temporarily different viewport.
     */
    getTemporaryClone() {
      const result = new _Viewport(() => {
      });
      result.transform = this.transform;
      result.inverseTransform = this.inverseTransform;
      result.screenRect = this.screenRect;
      return result;
    }
    /** Resizes the screen rect to the given size. @internal */
    updateScreenSize(screenSize) {
      this.screenRect = this.screenRect.resizedTo(screenSize);
    }
    /** Get the screen's visible region transformed into canvas space. */
    get visibleRect() {
      return this.screenRect.transformedBoundingBox(this.inverseTransform);
    }
    /** @returns the given point, but in canvas coordinates */
    screenToCanvas(screenPoint) {
      return this.inverseTransform.transformVec2(screenPoint);
    }
    /** @returns the given point transformed into screen coordinates. */
    canvasToScreen(canvasPoint) {
      return this.transform.transformVec2(canvasPoint);
    }
    /**
     * @returns a command that transforms the canvas by `transform`.
     *
     * For example, `Viewport.transformBy(moveRight).apply(editor)` would move the canvas to the right
     * (and thus the viewport to the left):
     * ```ts,runnable
     * import { Editor, Viewport, Mat33, Vec2 } from 'js-draw';
     * const editor = new Editor(document.body);
     * const moveRight = Mat33.translation(Vec2.unitX.times(500));
     * // Move the **canvas** right by 500 units:
     * Viewport.transformBy(moveRight).apply(editor);
     * ```
     */
    static transformBy(transform) {
      return new _Viewport.ViewportTransform(transform);
    }
    /**
     * Updates the transformation directly. Using `transformBy` is preferred.
     * @param newTransform - should map from canvas coordinates to screen coordinates.
     */
    resetTransform(newTransform = Mat33.identity) {
      const oldTransform = this.transform;
      this.transform = newTransform;
      this.inverseTransform = newTransform.inverse();
      this.onTransformChangeCallback?.(oldTransform, newTransform);
    }
    get screenToCanvasTransform() {
      return this.inverseTransform;
    }
    get canvasToScreenTransform() {
      return this.transform;
    }
    /** @returns the size of the visible region in pixels (screen units). */
    getScreenRectSize() {
      return this.screenRect.size;
    }
    /** Alias for `getScreenRectSize`. @deprecated */
    getResolution() {
      return this.getScreenRectSize();
    }
    /** @returns the amount a vector on the canvas is scaled to become a vector on the screen. */
    getScaleFactor() {
      return this.transform.transformVec3(Vec3.unitX).magnitude();
    }
    /**
     * @returns `getScaleFactor()` rounded to the nearest power of 10.
     * For example, if `getScaleFactor()` returns 101, `getScaleFactorToNearestPowerOfTen()`
     * should return `100` because `100` is the nearest power of 10 to 101.
     */
    getScaleFactorToNearestPowerOfTen() {
      return this.getScaleFactorToNearestPowerOf(10);
    }
    getScaleFactorToNearestPowerOf(powerOf) {
      const scaleFactor = this.getScaleFactor();
      return Math.pow(powerOf, Math.round(Math.log(scaleFactor) / Math.log(powerOf)));
    }
    /** Returns the size of a grid cell (in canvas units) as used by {@link snapToGrid}. */
    static getGridSize(scaleFactor) {
      return 50 / scaleFactor;
    }
    /**
     * Snaps `canvasPos` to the nearest grid cell corner.
     *
     * @see {@link getGridSize}.
     */
    snapToGrid(canvasPos) {
      const scaleFactor = this.getScaleFactorToNearestPowerOf(2);
      const snapCoordinate = (coordinate) => {
        const roundFactor = 1 / _Viewport.getGridSize(scaleFactor);
        const snapped = Math.round(coordinate * roundFactor) / roundFactor;
        return snapped;
      };
      const snappedCanvasPos = Vec2.of(snapCoordinate(canvasPos.x), snapCoordinate(canvasPos.y));
      return snappedCanvasPos;
    }
    /** Returns the size of one screen pixel in canvas units. */
    getSizeOfPixelOnCanvas() {
      return 1 / this.getScaleFactor();
    }
    /**
     * @returns the angle of the canvas in radians.
     * This is the angle by which the canvas is rotated relative to the screen.
     *
     * Returns an angle in the range $[-\pi, \pi]$ (the same range as {@link Vec3.angle}).
     */
    getRotationAngle() {
      return this.transform.transformVec3(Vec3.unitX).angle();
    }
    // The separate function type definition seems necessary here.
    // See https://stackoverflow.com/a/58163623/17055750.
    static roundPoint(point, tolerance) {
      const scaleFactor = 10 ** Math.floor(Math.log10(tolerance));
      const roundComponent = (component) => {
        return Math.round(component / scaleFactor) * scaleFactor;
      };
      if (typeof point === "number") {
        return roundComponent(point);
      }
      return point.map(roundComponent);
    }
    /** Round a point with a tolerance of 1 screen unit. */
    roundPoint(point) {
      return _Viewport.roundPoint(point, 1 / this.getScaleFactor());
    }
    // `roundAmount`: An integer >= 0, larger numbers cause less rounding. Smaller numbers cause more
    // (as such `roundAmount = 0` does the most rounding).
    static roundScaleRatio(scaleRatio, roundAmount = 1) {
      if (Math.abs(scaleRatio) <= 1e-12) {
        return 0;
      }
      const decimalComponent = 10 ** Math.floor(Math.log10(Math.abs(scaleRatio)));
      const roundAmountFactor = 2 ** roundAmount;
      scaleRatio = Math.round(scaleRatio / decimalComponent * roundAmountFactor) / roundAmountFactor * decimalComponent;
      return scaleRatio;
    }
    // Computes and returns an affine transformation that makes `toMakeVisible` visible and roughly centered on the screen.
    computeZoomToTransform(toMakeVisible, allowZoomIn = true, allowZoomOut = true) {
      let transform = Mat33.identity;
      if (toMakeVisible.w === 0 || toMakeVisible.h === 0) {
        let newSize = Math.max(toMakeVisible.w, toMakeVisible.h);
        if (newSize === 0) {
          newSize = 50;
          allowZoomIn = false;
          allowZoomOut = false;
        }
        toMakeVisible = new Rect2(toMakeVisible.x, toMakeVisible.y, newSize, newSize);
      }
      if (isNaN(toMakeVisible.size.magnitude())) {
        throw new Error(`${toMakeVisible.toString()} rectangle has NaN size! Cannot zoom to!`);
      }
      const recomputeTargetRect = () => {
        const visibleRect = this.visibleRect.transformedBoundingBox(transform.inverse());
        return visibleRect.transformedBoundingBox(Mat33.scaling2D(4 / 5, visibleRect.center));
      };
      let targetRect = recomputeTargetRect();
      const largerThanTarget = targetRect.w < toMakeVisible.w || targetRect.h < toMakeVisible.h;
      const muchSmallerThanTarget = toMakeVisible.maxDimension / targetRect.maxDimension < 1 / 3;
      if (largerThanTarget && allowZoomOut || muchSmallerThanTarget && allowZoomIn) {
        const multiplier = Math.max(toMakeVisible.w / targetRect.w, toMakeVisible.h / targetRect.h);
        const visibleRectTransform = Mat33.scaling2D(multiplier, targetRect.topLeft);
        const viewportContentTransform = visibleRectTransform.inverse();
        transform = transform.rightMul(viewportContentTransform);
      }
      targetRect = recomputeTargetRect();
      if (!targetRect.containsRect(toMakeVisible)) {
        const translation = toMakeVisible.center.minus(targetRect.center);
        const visibleRectTransform = Mat33.translation(translation);
        const viewportContentTransform = visibleRectTransform.inverse();
        transform = transform.rightMul(viewportContentTransform);
      }
      if (!transform.invertable()) {
        console.warn("Unable to zoom to ", toMakeVisible, "! Computed transform", transform, "is singular.");
        transform = Mat33.identity;
      }
      return transform;
    }
    // Returns a Command that transforms the view such that `toMakeVisible` is visible, and perhaps
    // centered in the viewport.
    //
    // If the content is already roughly centered in the screen and at a reasonable zoom level,
    // the resultant command does nothing.
    //
    // @see {@link computeZoomToTransform}
    zoomTo(toMakeVisible, allowZoomIn = true, allowZoomOut = true) {
      const transform = this.computeZoomToTransform(toMakeVisible, allowZoomIn, allowZoomOut);
      return new _Viewport.ViewportTransform(transform);
    }
  };
  Viewport.ViewportTransform = (_a = class extends ViewportTransform {
    constructor(transform) {
      super();
      this.transform = transform;
      _inverseTransform.set(this, void 0);
      __classPrivateFieldSet2(this, _inverseTransform, transform.inverse(), "f");
    }
    apply(editor) {
      const viewport = editor.viewport;
      viewport.resetTransform(viewport.transform.rightMul(this.transform));
      editor.queueRerender();
    }
    unapply(editor) {
      const viewport = editor.viewport;
      viewport.resetTransform(viewport.transform.rightMul(__classPrivateFieldGet2(this, _inverseTransform, "f")));
      editor.queueRerender();
    }
    description(editor, localizationTable) {
      return describeTransformation_default(editor.viewport.visibleRect.center, this.transform, true, localizationTable);
    }
  }, _inverseTransform = /* @__PURE__ */ new WeakMap(), _a);
  var Viewport_default = Viewport;

  // node_modules/js-draw/dist/mjs/commands/SerializableCommand.mjs
  var __classPrivateFieldSet3 = function(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var __classPrivateFieldGet3 = function(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var _SerializableCommand_commandTypeId;
  var SerializableCommand = class _SerializableCommand extends Command_default {
    /** @param commandTypeId - A unique identifier for this command. */
    constructor(commandTypeId) {
      super();
      _SerializableCommand_commandTypeId.set(this, void 0);
      if (!(commandTypeId in _SerializableCommand.deserializationCallbacks)) {
        throw new Error(`Command ${commandTypeId} must have a registered deserialization callback. To do this, call SerializableCommand.register.`);
      }
      __classPrivateFieldSet3(this, _SerializableCommand_commandTypeId, commandTypeId, "f");
    }
    // Convert this command to an object that can be passed to `JSON.stringify`.
    //
    // Do not rely on the stability of the optupt of this function  it can change
    // form without a major version increase.
    serialize() {
      return {
        data: this.serializeToJSON(),
        commandType: __classPrivateFieldGet3(this, _SerializableCommand_commandTypeId, "f")
      };
    }
    // Convert a `string` containing JSON data (or the output of `JSON.parse`) into a
    // `Command`.
    //
    // Implementations should assume that `data` is untrusted.
    static deserialize(data, editor) {
      const json = typeof data === "string" ? JSON.parse(data) : data;
      const commandType = json.commandType;
      if (!(commandType in _SerializableCommand.deserializationCallbacks)) {
        throw new Error(`Unrecognised command type ${commandType}!`);
      }
      return _SerializableCommand.deserializationCallbacks[commandType](json.data, editor);
    }
    // Register a deserialization callback. This must be called at least once for every subclass of
    // `SerializableCommand`.
    static register(commandTypeId, deserialize) {
      _SerializableCommand.deserializationCallbacks[commandTypeId] = deserialize;
    }
  };
  _SerializableCommand_commandTypeId = /* @__PURE__ */ new WeakMap();
  SerializableCommand.deserializationCallbacks = {};
  var SerializableCommand_default = SerializableCommand;

  // node_modules/js-draw/dist/mjs/commands/UnresolvedCommand.mjs
  var UnresolvedSerializableCommand = class extends SerializableCommand_default {
    constructor(commandId, componentID, component) {
      super(commandId);
      this.component = component ?? null;
      this.componentID = componentID;
    }
    resolveComponent(image) {
      if (this.component) {
        return;
      }
      const component = image.lookupElement(this.componentID);
      if (!component) {
        throw new Error(`Unable to resolve component with ID ${this.componentID}`);
      }
      this.component = component;
    }
  };

  // node_modules/js-draw/dist/mjs/util/assertions.mjs
  function assertUnreachable(key) {
    throw new Error(`Should be unreachable. Key: ${key}.`);
  }
  function assertIsNumber(value, allowNaN = false) {
    if (typeof value !== "number" || !allowNaN && isNaN(value)) {
      throw new Error("Given value is not a number");
    }
  }
  function assertIsString(value) {
    if (typeof value !== "string") {
      throw new Error("Given value is not a string");
    }
  }
  function assertIsArray(values) {
    if (!Array.isArray(values)) {
      throw new Error("Asserting isArray: Given entity is not an array");
    }
  }
  function assertIsNumberArray(values, allowNaN = false) {
    assertIsArray(values);
    assertIsNumber(values.length);
    for (const value of values) {
      assertIsNumber(value, allowNaN);
    }
  }
  function assertIsStringArray(values) {
    assertIsArray(values);
    assertIsNumber(values.length);
    for (const value of values) {
      assertIsString(value);
    }
  }
  function assertIsBoolean(value) {
    if (typeof value !== "boolean") {
      throw new Error("Given value is not a boolean");
    }
  }
  function assertTruthy(value) {
    if (!value) {
      throw new Error(`${JSON.stringify(value)} is not truthy`);
    }
  }
  function assertIsObject(value) {
    if (typeof value !== "object") {
      throw new Error(`AssertIsObject: Given entity is not an object (type = ${typeof value})`);
    }
  }

  // node_modules/js-draw/dist/mjs/components/AbstractComponent.mjs
  var __setFunctionName = function(f, name, prefix) {
    if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
    return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
  };
  var _a2;
  var ComponentSizingMode;
  (function(ComponentSizingMode2) {
    ComponentSizingMode2[ComponentSizingMode2["BoundingBox"] = 0] = "BoundingBox";
    ComponentSizingMode2[ComponentSizingMode2["FillScreen"] = 1] = "FillScreen";
    ComponentSizingMode2[ComponentSizingMode2["Anywhere"] = 2] = "Anywhere";
  })(ComponentSizingMode || (ComponentSizingMode = {}));
  var AbstractComponent = class _AbstractComponent {
    constructor(componentKind2, initialZIndex) {
      this.componentKind = componentKind2;
      this.loadSaveData = {};
      this.lastChangedTime = (/* @__PURE__ */ new Date()).getTime();
      if (initialZIndex !== void 0) {
        this.zIndex = initialZIndex;
      } else {
        this.zIndex = _AbstractComponent.zIndexCounter++;
      }
      this.id = `${(/* @__PURE__ */ new Date()).getTime()}-${Math.random()}`;
      if (_AbstractComponent.deserializationCallbacks[componentKind2] === void 0) {
        throw new Error(`Component ${componentKind2} has not been registered using AbstractComponent.registerComponent`);
      }
    }
    // Returns a unique ID for this element.
    // @see { @link EditorImage.lookupElement }
    getId() {
      return this.id;
    }
    // Store the deserialization callback (or lack of it) for [componentKind].
    // If components are registered multiple times (as may be done in automated tests),
    // the most recent deserialization callback is used.
    static registerComponent(componentKind2, deserialize) {
      this.deserializationCallbacks[componentKind2] = deserialize ?? null;
    }
    /**
     * Attach data that can be used while exporting the component (e.g. to SVG).
     *
     * This is intended for use by an {@link ImageLoader}.
     */
    attachLoadSaveData(key, data) {
      if (!this.loadSaveData[key]) {
        this.loadSaveData[key] = [];
      }
      this.loadSaveData[key].push(data);
    }
    /** See {@link attachLoadSaveData} */
    getLoadSaveData() {
      return this.loadSaveData;
    }
    getZIndex() {
      return this.zIndex;
    }
    /**
     * @returns the bounding box of this. This can be a slight overestimate if doing so
     * 			significantly improves performance.
     */
    getBBox() {
      return this.contentBBox;
    }
    /**
     * @returns the bounding box of this. Unlike `getBBox`, this should **not** be a rough estimate.
     */
    getExactBBox() {
      return this.getBBox();
    }
    /**
     * Returns information about how this component should be displayed
     * (e.g. fill the screen or get its size from {@link getBBox}).
     *
     * {@link EditorImage.queueRerenderOf} must be called to apply changes to
     * the output of this method if this component has already been added to an
     * {@link EditorImage}.
     */
    getSizingMode() {
      return ComponentSizingMode.BoundingBox;
    }
    /**
     * **Optimization**
     *
     * Should return `true` if this component covers the entire `visibleRect`
     * and would prevent anything below this component from being visible.
     *
     * Should return `false` otherwise.
     */
    occludesEverythingBelowWhenRenderedInRect(_visibleRect) {
      return false;
    }
    /** Called when this component is added to the given image. */
    onAddToImage(_image) {
    }
    onRemoveFromImage() {
    }
    /**
     * @returns true if this component intersects `rect` -- it is entirely contained
     *  within the rectangle or one of the rectangle's edges intersects this component.
     *
     * The default implementation assumes that `this.getExactBBox()` returns a tight bounding box
     * -- that any horiziontal/vertical line that intersects this' boounding box also
     * intersects a point in this component. If this is not the case, components must override
     * this function.
     */
    intersectsRect(rect) {
      if (rect.containsRect(this.getExactBBox())) {
        return true;
      }
      const testLines = rect.getEdges();
      return testLines.some((edge) => this.intersects(edge));
    }
    /**
     * Returns a selection of points within this object. Each contiguous section
     * of this object should have a point in the returned array.
     *
     * Subclasses should override this method if the center of the bounding box is
     * not contained within the object.
     */
    keyPoints() {
      return [this.getBBox().center];
    }
    // @returns true iff this component can be selected (e.g. by the selection tool.)
    isSelectable() {
      return true;
    }
    // @returns true iff this component should be added to the background, rather than the
    // foreground of the image.
    isBackground() {
      return false;
    }
    // @returns an approximation of the proportional time it takes to render this component.
    // This is intended to be a rough estimate, but, for example, a stroke with two points sould have
    // a renderingWeight approximately twice that of a stroke with one point.
    getProportionalRenderingTime() {
      return 1;
    }
    /**
     * Returns a command that, when applied, transforms this by [affineTransfm] and
     * updates the editor.
     *
     * The transformed component is also moved to the top (use
     * {@link AbstractComponent#setZIndexAndTransformBy} to avoid this behavior).
     */
    transformBy(affineTransfm) {
      return new _AbstractComponent.TransformElementCommand(affineTransfm, this.getId(), this);
    }
    // Returns a command that updates this component's z-index.
    setZIndex(newZIndex) {
      return new _AbstractComponent.TransformElementCommand(Mat33.identity, this.getId(), this, newZIndex);
    }
    /**
     * Combines {@link transformBy} and {@link setZIndex} into a single command.
     *
     * @param newZIndex - The z-index this component should have after applying this command.
     * @param originalZIndex - @internal The z-index the component should revert to after unapplying
     *                         this command.
     */
    setZIndexAndTransformBy(affineTransfm, newZIndex, originalZIndex) {
      return new _AbstractComponent.TransformElementCommand(affineTransfm, this.getId(), this, newZIndex, originalZIndex);
    }
    // Returns a copy of this component.
    clone() {
      const clone = this.createClone();
      for (const attachmentKey in this.loadSaveData) {
        for (const val of this.loadSaveData[attachmentKey]) {
          clone.attachLoadSaveData(attachmentKey, val);
        }
      }
      return clone;
    }
    /**
     * Creates a copy of this component with a particular `id`.
     * This is used internally by {@link Duplicate} when deserializing.
     *
     * @internal -- users of the library shouldn't need this.
     */
    cloneWithId(cloneId) {
      const clone = this.clone();
      clone.id = cloneId;
      return clone;
    }
    // Convert the component to an object that can be passed to
    // `JSON.stringify`.
    //
    // Do not rely on the output of this function to take a particular form 
    // this function's output can change form without a major version increase.
    serialize() {
      const data = this.serializeToJSON();
      if (data === null) {
        throw new Error(`${this} cannot be serialized.`);
      }
      return {
        name: this.componentKind,
        zIndex: this.zIndex,
        id: this.id,
        loadSaveData: this.loadSaveData,
        data
      };
    }
    // Returns true if `data` is not deserializable. May return false even if [data]
    // is not deserializable.
    static isNotDeserializable(json) {
      if (typeof json === "string") {
        json = JSON.parse(json);
      }
      if (typeof json !== "object") {
        return true;
      }
      if (!this.deserializationCallbacks[json?.name]) {
        return true;
      }
      if (!json.data) {
        return true;
      }
      return false;
    }
    // Convert a string or an object produced by `JSON.parse` into an `AbstractComponent`.
    static deserialize(json) {
      if (typeof json === "string") {
        json = JSON.parse(json);
      }
      if (_AbstractComponent.isNotDeserializable(json)) {
        throw new Error(`Element with data ${json} cannot be deserialized.`);
      }
      const instance = this.deserializationCallbacks[json.name](json.data);
      if (json.id) {
        assertIsString(json.id);
        instance.id = json.id;
      }
      if (isFinite(json.zIndex)) {
        instance.zIndex = json.zIndex;
        _AbstractComponent.zIndexCounter = Math.max(_AbstractComponent.zIndexCounter, instance.zIndex + 1);
      }
      return instance;
    }
  };
  AbstractComponent.zIndexCounter = 0;
  AbstractComponent.deserializationCallbacks = {};
  AbstractComponent.transformElementCommandId = "transform-element";
  AbstractComponent.TransformElementCommand = (_a2 = class extends UnresolvedSerializableCommand {
    // Construct a new TransformElementCommand. `component`, while optional, should
    // be provided if available. If not provided, it will be fetched from the editor's
    // document when the command is applied.
    constructor(affineTransfm, componentID, component, targetZIndex, origZIndex) {
      super(AbstractComponent.transformElementCommandId, componentID, component);
      this.affineTransfm = affineTransfm;
      this.origZIndex = origZIndex;
      this.targetZIndex = targetZIndex ?? AbstractComponent.zIndexCounter++;
      if (this.targetZIndex >= AbstractComponent.zIndexCounter) {
        AbstractComponent.zIndexCounter = this.targetZIndex + 1;
      }
      if (component && origZIndex === void 0) {
        this.origZIndex = component.getZIndex();
      }
    }
    resolveComponent(image) {
      if (this.component) {
        return;
      }
      super.resolveComponent(image);
      this.origZIndex ??= this.component.getZIndex();
    }
    updateTransform(editor, newTransfm, targetZIndex) {
      if (!this.component) {
        throw new Error("this.component is undefined or null!");
      }
      const parent = editor.image.findParent(this.component);
      let hadParent = false;
      if (parent) {
        parent.remove();
        hadParent = true;
      }
      this.component.applyTransformation(newTransfm);
      this.component.zIndex = targetZIndex;
      this.component.lastChangedTime = (/* @__PURE__ */ new Date()).getTime();
      if (targetZIndex >= AbstractComponent.zIndexCounter) {
        AbstractComponent.zIndexCounter = targetZIndex + 1;
      }
      if (hadParent) {
        EditorImage_default.addComponent(this.component).apply(editor);
      }
    }
    apply(editor) {
      this.resolveComponent(editor.image);
      this.updateTransform(editor, this.affineTransfm, this.targetZIndex);
      editor.queueRerender();
    }
    unapply(editor) {
      this.resolveComponent(editor.image);
      this.updateTransform(editor, this.affineTransfm.inverse(), this.origZIndex);
      editor.queueRerender();
    }
    description(_editor, localizationTable) {
      return localizationTable.transformedElements(1, describeTransformation_default(Vec2.zero, this.affineTransfm, false, localizationTable));
    }
    serializeToJSON() {
      return {
        id: this.componentID,
        transfm: this.affineTransfm.toArray(),
        targetZIndex: this.targetZIndex,
        origZIndex: this.origZIndex
      };
    }
  }, __setFunctionName(_a2, "TransformElementCommand"), (() => {
    SerializableCommand_default.register(AbstractComponent.transformElementCommandId, (json, editor) => {
      const elem = editor.image.lookupElement(json.id) ?? void 0;
      const transform = new Mat33(...json.transfm);
      const targetZIndex = json.targetZIndex;
      const origZIndex = json.origZIndex ?? void 0;
      return new AbstractComponent.TransformElementCommand(transform, json.id, elem, targetZIndex, origZIndex);
    });
  })(), _a2);
  var AbstractComponent_default = AbstractComponent;

  // node_modules/js-draw/dist/mjs/EventDispatcher.mjs
  var EventDispatcher = class {
    constructor() {
      this.listeners = {};
    }
    dispatch(eventName, event) {
      const listenerList = this.listeners[eventName];
      if (listenerList) {
        for (let i = 0; i < listenerList.length; i++) {
          listenerList[i](event);
        }
      }
    }
    on(eventName, callback) {
      if (!this.listeners[eventName])
        this.listeners[eventName] = [];
      this.listeners[eventName].push(callback);
      return {
        // Retuns false if the listener has already been removed, true otherwise.
        remove: () => {
          const originalListeners = this.listeners[eventName];
          this.off(eventName, callback);
          return originalListeners.length !== this.listeners[eventName].length;
        }
      };
    }
    /** Removes an event listener. This is equivalent to calling `.remove()` on the object returned by `.on`. */
    off(eventName, callback) {
      const listeners = this.listeners[eventName];
      if (!listeners)
        return;
      this.listeners[eventName] = listeners.filter((otherCallback) => otherCallback !== callback);
    }
  };

  // node_modules/js-draw/dist/mjs/image/EditorImage.mjs
  var __setFunctionName2 = function(f, name, prefix) {
    if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
    return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
  };
  var _a3;
  var _b;
  var _c;
  var sortLeavesByZIndex = (leaves) => {
    leaves.sort((a, b) => a.getContent().getZIndex() - b.getContent().getZIndex());
  };
  var EditorImageEventType;
  (function(EditorImageEventType2) {
    EditorImageEventType2[EditorImageEventType2["ExportViewportChanged"] = 0] = "ExportViewportChanged";
    EditorImageEventType2[EditorImageEventType2["AutoresizeModeChanged"] = 1] = "AutoresizeModeChanged";
    EditorImageEventType2[EditorImageEventType2["ComponentAdded"] = 2] = "ComponentAdded";
    EditorImageEventType2[EditorImageEventType2["ComponentRemoved"] = 3] = "ComponentRemoved";
  })(EditorImageEventType || (EditorImageEventType = {}));
  var debugMode = false;
  var EditorImage = class {
    // @internal
    constructor() {
      this.componentCount = 0;
      this.settingExportRect = false;
      this.root = new RootImageNode();
      this.background = new RootImageNode();
      this.componentsById = /* @__PURE__ */ new Map();
      this.notifier = new EventDispatcher();
      this.importExportViewport = new Viewport_default(() => {
        this.onExportViewportChanged();
      });
      this.importExportViewport.updateScreenSize(Vec2.of(500, 500));
      this.shouldAutoresizeExportViewport = false;
    }
    // Returns all components that make up the background of this image. These
    // components are rendered below all other components.
    getBackgroundComponents() {
      const result = [];
      const leaves = this.background.getLeaves();
      sortLeavesByZIndex(leaves);
      for (const leaf of leaves) {
        const content = leaf.getContent();
        if (content) {
          result.push(content);
        }
      }
      return result;
    }
    // Returns the parent of the given element, if it exists.
    findParent(elem) {
      return this.background.getChildWithContent(elem) ?? this.root.getChildWithContent(elem);
    }
    // Forces a re-render of `elem` when the image is next re-rendered as a whole.
    // Does nothing if `elem` is not in this.
    queueRerenderOf(elem) {
      const parent = this.findParent(elem);
      if (parent) {
        parent.remove();
        this.addComponentDirectly(elem);
      }
    }
    /** @internal */
    renderWithCache(screenRenderer, cache, viewport) {
      this.background.render(screenRenderer, viewport.visibleRect);
      if (!debugMode) {
        cache.render(screenRenderer, this.root, viewport);
      } else {
        this.root.render(screenRenderer, viewport.visibleRect);
      }
    }
    /**
     * Renders this image to the given `renderer`.
     *
     * If `viewport` is non-null, only components that can be seen from that viewport
     * will be rendered. If `viewport` is `null`, **all** components are rendered.
     *
     * **Example**:
     * [[include:doc-pages/inline-examples/canvas-renderer.md]]
     */
    render(renderer, viewport) {
      this.background.render(renderer, viewport?.visibleRect);
      this.root.render(renderer, viewport?.visibleRect);
    }
    /**
     * Like {@link renderAll}, but can be stopped early and paused.
     *
     * **Note**: If the image is being edited during an async rendering, there is no
     * guarantee that all nodes will be rendered correctly (some may be missing).
     *
     * @internal
     */
    async renderAllAsync(renderer, preRenderComponent) {
      const stoppedEarly = !await this.background.renderAllAsync(renderer, preRenderComponent);
      if (!stoppedEarly) {
        return await this.root.renderAllAsync(renderer, preRenderComponent);
      }
      return false;
    }
    /**
     * Renders all nodes, even ones not within the viewport.
     *
     * This can be slow for large images
     * @internal
     */
    renderAll(renderer) {
      this.render(renderer, null);
    }
    /**
     * @returns all elements in the image, sorted by z-index (low to high).
     *
     * This can be slow for large images. If you only need all elemenst in part of the image,
     * consider using {@link getComponentsIntersecting} instead.
     *
     * **Note**: The result does not include background elements. See {@link getBackgroundComponents}.
     */
    getAllComponents() {
      const leaves = this.root.getLeaves();
      sortLeavesByZIndex(leaves);
      return leaves.map((leaf) => leaf.getContent());
    }
    /** @deprecated in favor of {@link getAllComponents} */
    getAllElements() {
      return this.getAllComponents();
    }
    /** Returns the number of elements added to this image. @internal */
    estimateNumElements() {
      return this.componentCount;
    }
    /** @deprecated @see getComponentsIntersecting */
    getElementsIntersectingRegion(region, includeBackground = false) {
      return this.getComponentsIntersecting(region, includeBackground);
    }
    /**
     * @returns a list of `AbstractComponent`s intersecting `region`, sorted by increasing z-index.
     *
     * Components in the background layer are only included if `includeBackground` is `true`.
     */
    getComponentsIntersecting(region, includeBackground = false) {
      let leaves = this.root.getLeavesIntersectingRegion(region);
      if (includeBackground) {
        leaves = leaves.concat(this.background.getLeavesIntersectingRegion(region));
      }
      sortLeavesByZIndex(leaves);
      return leaves.map((leaf) => leaf.getContent());
    }
    /** Called whenever (just after) an element is completely removed. @internal */
    onDestroyElement(elem) {
      this.componentCount--;
      const componentId2 = elem.getId();
      this.componentsById.delete(componentId2);
      this.notifier.dispatch(EditorImageEventType.ComponentRemoved, {
        kind: EditorImageEventType.ComponentRemoved,
        image: this,
        componentId: componentId2
      });
      this.autoresizeExportViewport();
    }
    /** Called just after an element is added. @internal */
    onElementAdded(elem) {
      this.componentCount++;
      const elementId = elem.getId();
      this.componentsById.set(elem.getId(), elem);
      this.notifier.dispatch(EditorImageEventType.ComponentAdded, {
        kind: EditorImageEventType.ComponentAdded,
        image: this,
        componentId: elementId
      });
      this.autoresizeExportViewport();
    }
    /**
     * @returns the AbstractComponent with `id`, if it exists.
     *
     * @see {@link AbstractComponent.getId}
     */
    lookupElement(id) {
      return this.componentsById.get(id) ?? null;
    }
    addComponentDirectly(elem) {
      elem.onAddToImage(this);
      const parentTree = elem.isBackground() ? this.background : this.root;
      const result = parentTree.addLeaf(elem);
      this.onElementAdded(elem);
      return result;
    }
    removeElementDirectly(element) {
      const container = this.findParent(element);
      container?.remove();
      if (container) {
        this.onDestroyElement(element);
        return true;
      }
      return false;
    }
    /**
     * Returns a command that adds the given element to the `EditorImage`.
     * If `applyByFlattening` is true, the content of the wet ink renderer is
     * rendered onto the main rendering canvas instead of doing a full re-render.
     *
     * @see {@link Display.flatten}
     *
     * **Example**:
     *
     * [[include:doc-pages/inline-examples/adding-a-stroke.md]]
     */
    static addComponent(elem, applyByFlattening = false) {
      return new _a3.AddComponentCommand(elem, applyByFlattening);
    }
    /** @see EditorImage.addComponent */
    addComponent(component, applyByFlattening) {
      return _a3.addComponent(component, applyByFlattening);
    }
    /** Alias for {@link addComponent}. @deprecated Prefer `.addComponent` */
    addElement(elem, applyByFlattening) {
      return this.addComponent(elem, applyByFlattening);
    }
    /** Alias for {@link addComponent}. @deprecated Prefer `.addComponent`. */
    static addElement(elem, applyByFlattening = false) {
      return this.addComponent(elem, applyByFlattening);
    }
    /**
     * @returns a `Viewport` for rendering the image when importing/exporting.
     */
    getImportExportViewport() {
      return this.importExportViewport;
    }
    /**
     * @see {@link setImportExportRect}
     */
    getImportExportRect() {
      return this.getImportExportViewport().visibleRect;
    }
    /**
     * Sets the import/export rectangle to the given `imageRect`. Disables
     * autoresize if it was previously enabled.
     *
     * **Note**: The import/export rectangle is the same as the size of any
     * {@link BackgroundComponent}s (and other components that auto-resize).
     */
    setImportExportRect(imageRect) {
      return _a3.SetImportExportRectCommand.of(this, imageRect, false);
    }
    /** @see {@link setAutoresizeEnabled} */
    getAutoresizeEnabled() {
      return this.shouldAutoresizeExportViewport;
    }
    /**
     * Returns a `Command` that sets whether the image should autoresize when
     * {@link AbstractComponent}s are added/removed.
     *
     * @example
     *
     * ```ts,runnable
     * import { Editor } from 'js-draw';
     *
     * const editor = new Editor(document.body);
     * const toolbar = editor.addToolbar();
     *
     * // Add a save button to demonstrate what the output looks like
     * // (it should change size to fit whatever was drawn)
     * toolbar.addSaveButton(() => {
     *   document.body.replaceChildren(editor.toSVG({ sanitize: true }));
     * });
     *
     * // Actually using setAutoresizeEnabled:
     * //
     * // To set autoresize without announcing for accessibility/making undoable
     * const addToHistory = false;
     * editor.dispatchNoAnnounce(editor.image.setAutoresizeEnabled(true), addToHistory);
     *
     * // Add to undo history **and** announce for accessibility
     * //editor.dispatch(editor.image.setAutoresizeEnabled(true), true);
     * ```
     */
    setAutoresizeEnabled(autoresize) {
      if (autoresize === this.shouldAutoresizeExportViewport) {
        return Command_default.empty;
      }
      const newBBox = this.root.getBBox();
      return _a3.SetImportExportRectCommand.of(this, newBBox, autoresize);
    }
    setAutoresizeEnabledDirectly(shouldAutoresize) {
      if (shouldAutoresize !== this.shouldAutoresizeExportViewport) {
        this.shouldAutoresizeExportViewport = shouldAutoresize;
        this.notifier.dispatch(EditorImageEventType.AutoresizeModeChanged, {
          kind: EditorImageEventType.AutoresizeModeChanged,
          image: this
        });
      }
    }
    /** Updates the size/position of the viewport */
    autoresizeExportViewport() {
      if (this.shouldAutoresizeExportViewport) {
        this.setExportRectDirectly(this.root.getBBox());
      }
    }
    /**
     * Sets the import/export viewport directly, without returning a `Command`.
     * As such, this is not undoable.
     *
     * See setImportExportRect
     *
     * Returns true if changes to the viewport were made (and thus
     * ExportViewportChanged was fired.)
     */
    setExportRectDirectly(newRect) {
      const viewport = this.getImportExportViewport();
      const lastSize = viewport.getScreenRectSize();
      const lastTransform = viewport.canvasToScreenTransform;
      const newTransform = Mat33.translation(newRect.topLeft.times(-1));
      if (!lastSize.eq(newRect.size) || !lastTransform.eq(newTransform)) {
        this.settingExportRect = true;
        viewport.updateScreenSize(newRect.size);
        viewport.resetTransform(newTransform);
        this.settingExportRect = false;
        this.onExportViewportChanged();
        return true;
      }
      return false;
    }
    onExportViewportChanged() {
      if (!this.settingExportRect) {
        this.notifier.dispatch(EditorImageEventType.ExportViewportChanged, {
          kind: EditorImageEventType.ExportViewportChanged,
          image: this
        });
      }
    }
    /**
     * @internal
     *
     * Enables debug mode for **all** `EditorImage`s.
     *
     * **Only use for debugging**.
     *
     * @internal
     */
    static setDebugMode(newDebugMode) {
      debugMode = newDebugMode;
    }
  };
  _a3 = EditorImage;
  EditorImage.AddComponentCommand = (_b = class extends SerializableCommand_default {
    // If [applyByFlattening], then the rendered content of this element
    // is present on the display's wet ink canvas. As such, no re-render is necessary
    // the first time this command is applied (the surfaces are joined instead).
    constructor(element, applyByFlattening = false) {
      super("add-element");
      this.element = element;
      this.applyByFlattening = applyByFlattening;
      this.serializedElem = null;
      this.serializedElem = null;
      if (isNaN(element.getBBox().area)) {
        throw new Error("Elements in the image cannot have NaN bounding boxes");
      }
    }
    apply(editor) {
      editor.image.addComponentDirectly(this.element);
      if (!this.applyByFlattening) {
        editor.queueRerender();
      } else {
        this.applyByFlattening = false;
        editor.display.flatten();
      }
    }
    unapply(editor) {
      editor.image.removeElementDirectly(this.element);
      editor.queueRerender();
    }
    description(_editor, localization7) {
      return localization7.addComponentAction(this.element.description(localization7));
    }
    serializeToJSON() {
      return {
        elemData: this.serializedElem ?? this.element.serialize()
      };
    }
  }, __setFunctionName2(_b, "AddComponentCommand"), (() => {
    SerializableCommand_default.register("add-element", (json, editor) => {
      const id = json.elemData.id;
      const foundElem = editor.image.lookupElement(id);
      const elem = foundElem ?? AbstractComponent_default.deserialize(json.elemData);
      const result = new _a3.AddComponentCommand(elem);
      result.serializedElem = json.elemData;
      return result;
    });
  })(), _b);
  EditorImage.SetImportExportRectCommand = (_c = class extends SerializableCommand_default {
    constructor(originalSize, originalTransform, originalAutoresize, newExportRect, newAutoresize) {
      super(_a3.SetImportExportRectCommand.commandId);
      this.originalSize = originalSize;
      this.originalTransform = originalTransform;
      this.originalAutoresize = originalAutoresize;
      this.newExportRect = newExportRect;
      this.newAutoresize = newAutoresize;
    }
    // Uses `image` to store the original size/transform
    static of(image, newExportRect, newAutoresize) {
      const importExportViewport = image.getImportExportViewport();
      const originalSize = importExportViewport.visibleRect.size;
      const originalTransform = importExportViewport.canvasToScreenTransform;
      const originalAutoresize = image.getAutoresizeEnabled();
      return new _a3.SetImportExportRectCommand(originalSize, originalTransform, originalAutoresize, newExportRect, newAutoresize);
    }
    apply(editor) {
      editor.image.setAutoresizeEnabledDirectly(this.newAutoresize);
      editor.image.setExportRectDirectly(this.newExportRect);
      editor.queueRerender();
    }
    unapply(editor) {
      const viewport = editor.image.getImportExportViewport();
      editor.image.setAutoresizeEnabledDirectly(this.originalAutoresize);
      viewport.updateScreenSize(this.originalSize);
      viewport.resetTransform(this.originalTransform);
      editor.queueRerender();
    }
    description(_editor, localization7) {
      if (this.newAutoresize !== this.originalAutoresize) {
        if (this.newAutoresize) {
          return localization7.enabledAutoresizeOutputCommand;
        } else {
          return localization7.disabledAutoresizeOutputCommand;
        }
      }
      return localization7.resizeOutputCommand(this.newExportRect);
    }
    serializeToJSON() {
      return {
        originalSize: this.originalSize.xy,
        originalTransform: this.originalTransform.toArray(),
        newRegion: {
          x: this.newExportRect.x,
          y: this.newExportRect.y,
          w: this.newExportRect.w,
          h: this.newExportRect.h
        },
        autoresize: this.newAutoresize,
        originalAutoresize: this.originalAutoresize
      };
    }
  }, __setFunctionName2(_c, "SetImportExportRectCommand"), _c.commandId = "set-import-export-rect", (() => {
    const commandId = _c.commandId;
    SerializableCommand_default.register(commandId, (json, _editor) => {
      assertIsNumber(json.originalSize.x);
      assertIsNumber(json.originalSize.y);
      assertIsNumberArray(json.originalTransform);
      assertIsNumberArray([
        json.newRegion.x,
        json.newRegion.y,
        json.newRegion.w,
        json.newRegion.h
      ]);
      assertIsBoolean(json.autoresize ?? false);
      assertIsBoolean(json.originalAutoresize ?? false);
      const originalSize = Vec2.ofXY(json.originalSize);
      const originalTransform = new Mat33(...json.originalTransform);
      const finalRect = new Rect2(json.newRegion.x, json.newRegion.y, json.newRegion.w, json.newRegion.h);
      const autoresize = json.autoresize ?? false;
      const originalAutoresize = json.originalAutoresize ?? false;
      return new _a3.SetImportExportRectCommand(originalSize, originalTransform, originalAutoresize, finalRect, autoresize);
    });
  })(), _c);
  var EditorImage_default = EditorImage;
  var computeFirstIndexToRender = (sortedLeaves, visibleRect) => {
    let startIndex = 0;
    if (visibleRect) {
      for (let i = sortedLeaves.length - 1; i >= 1; i--) {
        if (
          // Check for occlusion
          sortedLeaves[i].getBBox().containsRect(visibleRect) && sortedLeaves[i].getContent()?.occludesEverythingBelowWhenRenderedInRect(visibleRect)
        ) {
          startIndex = i;
          break;
        }
      }
    }
    return startIndex;
  };
  var ImageNode = class _ImageNode {
    constructor(parent = null) {
      this.parent = parent;
      this.targetChildCount = 30;
      this.children = [];
      this.bbox = Rect2.empty;
      this.content = null;
      this.id = _ImageNode.idCounter++;
    }
    getId() {
      return this.id;
    }
    onContentChange() {
      this.id = _ImageNode.idCounter++;
    }
    getContent() {
      return this.content;
    }
    getParent() {
      return this.parent;
    }
    // Override this to change how children are considered within a given region.
    getChildrenIntersectingRegion(region, isTooSmallFilter) {
      return this.children.filter((child) => {
        const bbox = child.getBBox();
        return !isTooSmallFilter?.(bbox) && bbox.intersects(region);
      });
    }
    getChildrenOrSelfIntersectingRegion(region, isTooSmall) {
      if (this.content && this.bbox.intersects(region) && !isTooSmall?.(this.bbox)) {
        return [this];
      }
      return this.getChildrenIntersectingRegion(region, isTooSmall);
    }
    /**
     * Returns a list of `ImageNode`s with content (and thus no children).
     * Override getChildrenIntersectingRegion to customize how this method
     * determines whether/which children are in `region`.
     *
     * @paran region - All resultant `ImageNode`s must intersect `region`.
     * @param isTooSmall - If `isTooSmall` returns true for an image node, that node
     *                     is excluded from the output.
     *
     */
    getLeavesIntersectingRegion(region, isTooSmall) {
      const result = [];
      const workList = [];
      workList.push(this);
      while (workList.length > 0) {
        const current = workList.pop();
        const processed = current.getChildrenOrSelfIntersectingRegion(region, isTooSmall);
        for (const item of processed) {
          if (item.content) {
            result.push(item);
          } else {
            workList.push(item);
          }
        }
      }
      return result;
    }
    // Returns the child of this with the target content or `null` if no
    // such child exists.
    //
    // Note: Relies on all children to have valid bounding boxes.
    getChildWithContent(target) {
      const candidates = this.getLeavesIntersectingRegion(target.getBBox());
      for (const candidate of candidates) {
        if (candidate.getContent() === target) {
          return candidate;
        }
      }
      return null;
    }
    // Returns a list of leaves with this as an ancestor.
    // Like getLeavesInRegion, but does not check whether ancestors are in a given rectangle
    getLeaves() {
      if (this.content) {
        return [this];
      }
      const result = [];
      for (const child of this.children) {
        result.push(...child.getLeaves());
      }
      return result;
    }
    addLeaf(leaf) {
      this.onContentChange();
      if (this.content === null && this.children.length === 0) {
        this.content = leaf;
        this.recomputeBBox(true);
        return this;
      }
      if (this.content !== null) {
        console.assert(this.children.length === 0);
        const contentNode = new _ImageNode(this);
        contentNode.content = this.content;
        this.content = null;
        this.children.push(contentNode);
        contentNode.recomputeBBox(false);
      }
      const leafBBox = leaf.getBBox();
      if (leafBBox.containsRect(this.getBBox())) {
        const nodeForNewLeaf = new _ImageNode(this);
        if (this.children.length < this.targetChildCount) {
          this.children.push(nodeForNewLeaf);
        } else {
          const nodeForChildren = new _ImageNode(this);
          nodeForChildren.children = this.children;
          this.children = [nodeForNewLeaf, nodeForChildren];
          nodeForChildren.updateParents();
          nodeForChildren.recomputeBBox(true);
        }
        return nodeForNewLeaf.addLeaf(leaf);
      }
      const containingNodes = this.children.filter((child) => child.getBBox().containsRect(leafBBox));
      if (containingNodes.length > 0 && this.children.length >= this.targetChildCount) {
        containingNodes.sort((a, b) => a.getBBox().area - b.getBBox().area);
        const result = containingNodes[0].addLeaf(leaf);
        result.rebalance();
        return result;
      }
      const newNode = _ImageNode.createLeafNode(this, leaf);
      this.children.push(newNode);
      newNode.recomputeBBox(true);
      if (this.children.length >= this.targetChildCount) {
        this.rebalance();
      }
      return newNode;
    }
    // Creates a new leaf node with the given content.
    // This only establishes the parent-child linking in one direction. Callers
    // must add the resultant node to the list of children manually.
    static createLeafNode(parent, content) {
      const newNode = new _ImageNode(parent);
      newNode.content = content;
      return newNode;
    }
    getBBox() {
      return this.bbox;
    }
    // Recomputes this' bounding box. If [bubbleUp], also recompute
    // this' ancestors bounding boxes. This also re-computes this' bounding box
    // in the z-direction (z-indicies).
    recomputeBBox(bubbleUp) {
      const oldBBox = this.bbox;
      if (this.content !== null) {
        this.bbox = this.content.getBBox();
      } else {
        this.bbox = Rect2.union(...this.children.map((child) => child.getBBox()));
      }
      if (bubbleUp && !oldBBox.eq(this.bbox)) {
        if (this.bbox.containsRect(oldBBox)) {
          this.parent?.unionBBoxWith(this.bbox);
        } else {
          this.parent?.recomputeBBox(true);
        }
      }
      this.checkRep();
    }
    // Grows this' bounding box to also include `other`.
    // Always bubbles up.
    unionBBoxWith(other) {
      this.bbox = this.bbox.union(other);
      this.parent?.unionBBoxWith(other);
    }
    updateParents(recursive = false) {
      for (const child of this.children) {
        child.parent = this;
        if (recursive) {
          child.updateParents(recursive);
        }
      }
    }
    rebalance() {
      if (this.parent && this.parent.children.length === 1) {
        console.assert(this.parent.content === null);
        console.assert(this.parent.children[0] === this);
        const oldParent = this.parent;
        if (oldParent.parent !== null) {
          const newParent = oldParent.parent;
          newParent.children = newParent.children.filter((c) => c !== oldParent);
          oldParent.parent = null;
          oldParent.children = [];
          this.parent = newParent;
          newParent.children.push(this);
          this.parent.recomputeBBox(false);
        } else if (this.content === null) {
          this.parent.children = this.children;
          this.parent.updateParents();
          this.parent = null;
        }
      }
      if (this.children.length > this.targetChildCount * 10) {
        const grid = this.getBBox().divideIntoGrid(4, 4);
        const indexToCount = [];
        while (indexToCount.length < grid.length) {
          indexToCount.push(0);
        }
        for (const child of this.children) {
          for (let i = 0; i < grid.length; i++) {
            if (grid[i].containsRect(child.getBBox())) {
              indexToCount[i]++;
            }
          }
        }
        let indexWithGreatest = 0;
        let greatestCount = indexToCount[0];
        for (let i = 1; i < indexToCount.length; i++) {
          if (indexToCount[i] > greatestCount) {
            indexWithGreatest = i;
            greatestCount = indexToCount[i];
          }
        }
        const targetGridSquare = grid[indexWithGreatest];
        if (greatestCount > 4) {
          const newChildren = [];
          const childNodeChildren = [];
          for (const child of this.children) {
            if (targetGridSquare.containsRect(child.getBBox())) {
              childNodeChildren.push(child);
            } else {
              newChildren.push(child);
            }
          }
          if (childNodeChildren.length < this.children.length) {
            this.children = newChildren;
            const child = new _ImageNode(this);
            this.children.push(child);
            child.children = childNodeChildren;
            child.updateParents(false);
            child.recomputeBBox(false);
            child.rebalance();
          }
        }
      }
      if (this.parent && this.children.length === 0 && this.content === null) {
        this.remove();
      }
    }
    // Removes the parent-to-child link.
    // Called internally by `.remove`
    removeChild(child) {
      this.checkRep();
      const oldChildCount = this.children.length;
      this.children = this.children.filter((node) => {
        return node !== child;
      });
      console.assert(this.children.length === oldChildCount - 1, `${oldChildCount - 1} \u2260 ${this.children.length} after removing all nodes equal to ${child}. Nodes should only be removed once.`);
      this.children.forEach((child2) => {
        child2.rebalance();
      });
      this.recomputeBBox(true);
      this.rebalance();
      this.checkRep();
    }
    // Remove this node and all of its children
    remove() {
      this.content?.onRemoveFromImage();
      if (!this.parent) {
        this.content = null;
        this.children = [];
        return;
      }
      this.parent.removeChild(this);
      this.parent = null;
      this.content = null;
      this.children = [];
      this.checkRep();
    }
    // Creates a (potentially incomplete) async rendering of this image.
    // Returns false if stopped early
    async renderAllAsync(renderer, preRenderComponent) {
      const leaves = this.getLeaves();
      sortLeavesByZIndex(leaves);
      const totalLeaves = leaves.length;
      for (let leafIndex = 0; leafIndex < totalLeaves; leafIndex++) {
        const leaf = leaves[leafIndex];
        const component = leaf.getContent();
        if (!component) {
          continue;
        }
        const shouldContinue = await preRenderComponent(component, leafIndex, totalLeaves);
        if (!shouldContinue) {
          return false;
        }
        component.render(renderer, void 0);
      }
      return true;
    }
    render(renderer, visibleRect) {
      let leaves;
      if (visibleRect) {
        leaves = this.getLeavesIntersectingRegion(visibleRect, (rect) => renderer.isTooSmallToRender(rect));
      } else {
        leaves = this.getLeaves();
      }
      sortLeavesByZIndex(leaves);
      const startIndex = computeFirstIndexToRender(leaves);
      for (let i = startIndex; i < leaves.length; i++) {
        const leaf = leaves[i];
        leaf.getContent().render(renderer, visibleRect);
      }
      if (debugMode && visibleRect) {
        if (startIndex !== 0) {
          console.log("EditorImage: skipped ", startIndex, "nodes due to occlusion");
        }
        this.renderDebugBoundingBoxes(renderer, visibleRect);
      }
    }
    // Debug only: Shows bounding boxes of this and all children.
    renderDebugBoundingBoxes(renderer, visibleRect, depth = 0) {
      const bbox = this.getBBox();
      const pixelSize = 1 / (renderer.getSizeOfCanvasPixelOnScreen() || 1);
      if (bbox.maxDimension < 3 * pixelSize || !bbox.intersects(visibleRect)) {
        return;
      }
      renderer.startObject(bbox);
      const isLeaf = !!this.content;
      const fill = isLeaf ? Color4.ofRGBA(1, 0, 1, 0.4) : Color4.ofRGBA(0, 1, Math.sin(depth), 0.6);
      const lineWidth = isLeaf ? 1 * pixelSize : 2 * pixelSize;
      renderer.drawRect(bbox.intersection(visibleRect), lineWidth, { fill });
      renderer.endObject();
      if (bbox.maxDimension > visibleRect.maxDimension / 3) {
        const textStyle = {
          fontFamily: "monospace",
          size: bbox.minDimension / 20,
          renderingStyle: { fill: Color4.red }
        };
        renderer.drawText(`Depth: ${depth}`, Mat33.translation(bbox.bottomLeft), textStyle);
      }
      for (const child of this.children) {
        child.renderDebugBoundingBoxes(renderer, visibleRect, depth + 1);
      }
    }
    checkRep(depth = 0) {
      if (debugMode) {
        if (this.parent && !this.parent.children.includes(this)) {
          throw new Error(`Parent does not have this node as a child. (depth: ${depth})`);
        }
        let expectedBBox = null;
        const seenChildren = /* @__PURE__ */ new Set();
        for (const child of this.children) {
          expectedBBox ??= child.getBBox();
          expectedBBox = expectedBBox.union(child.getBBox());
          if (child.parent !== this) {
            throw new Error(`Child with bbox ${child.getBBox()} and ${child.children.length} has wrong parent (was ${child.parent}).`);
          }
          if (seenChildren.has(child)) {
            throw new Error(`Child ${child} is present twice or more in its parent's child list`);
          }
          seenChildren.add(child);
        }
        const tolerance = this.bbox.minDimension / 100;
        if (expectedBBox && !this.bbox.eq(expectedBBox, tolerance)) {
          throw new Error(`Wrong bounding box ${expectedBBox} \\neq ${this.bbox} (depth: ${depth})`);
        }
      }
    }
  };
  ImageNode.idCounter = 0;
  var RootImageNode = class extends ImageNode {
    constructor() {
      super(...arguments);
      this.fullscreenChildren = [];
      this.dataComponents = [];
    }
    getChildrenIntersectingRegion(region, _isTooSmall) {
      const result = super.getChildrenIntersectingRegion(region);
      for (const node of this.fullscreenChildren) {
        result.push(node);
      }
      return result;
    }
    getChildrenOrSelfIntersectingRegion(region, _isTooSmall) {
      const content = this.getContent();
      if (content && content.getSizingMode() === ComponentSizingMode.FillScreen) {
        return [this];
      }
      return super.getChildrenOrSelfIntersectingRegion(region, _isTooSmall);
    }
    getLeaves() {
      const leaves = super.getLeaves();
      return this.dataComponents.concat(this.fullscreenChildren, leaves);
    }
    removeChild(child) {
      let removed = false;
      const checkTargetChild = (component) => {
        const isTarget = component === child;
        removed ||= isTarget;
        return !isTarget;
      };
      this.dataComponents = this.dataComponents.filter(checkTargetChild);
      this.fullscreenChildren = this.fullscreenChildren.filter(checkTargetChild);
      if (!removed) {
        super.removeChild(child);
      }
    }
    getChildWithContent(target) {
      const searchExtendedChildren = () => {
        const candidates = this.fullscreenChildren.concat(this.dataComponents);
        for (const candidate of candidates) {
          if (candidate.getContent() === target) {
            return candidate;
          }
        }
        return null;
      };
      if (target.getSizingMode() === ComponentSizingMode.BoundingBox) {
        return super.getChildWithContent(target) ?? searchExtendedChildren();
      }
      return super.getChildWithContent(target) ?? searchExtendedChildren();
    }
    addLeaf(leafContent) {
      const sizingMode = leafContent.getSizingMode();
      if (sizingMode === ComponentSizingMode.BoundingBox) {
        return super.addLeaf(leafContent);
      } else if (sizingMode === ComponentSizingMode.FillScreen) {
        this.onContentChange();
        const newNode = ImageNode.createLeafNode(this, leafContent);
        this.fullscreenChildren.push(newNode);
        return newNode;
      } else if (sizingMode === ComponentSizingMode.Anywhere) {
        this.onContentChange();
        const newNode = ImageNode.createLeafNode(this, leafContent);
        this.dataComponents.push(newNode);
        return newNode;
      } else {
        const exhaustivenessCheck = sizingMode;
        throw new Error(`Invalid sizing mode, ${sizingMode}`);
        return exhaustivenessCheck;
      }
    }
  };

  // node_modules/js-draw/dist/mjs/types.mjs
  var EditorEventType;
  (function(EditorEventType2) {
    EditorEventType2[EditorEventType2["ToolEnabled"] = 0] = "ToolEnabled";
    EditorEventType2[EditorEventType2["ToolDisabled"] = 1] = "ToolDisabled";
    EditorEventType2[EditorEventType2["ToolUpdated"] = 2] = "ToolUpdated";
    EditorEventType2[EditorEventType2["UndoRedoStackUpdated"] = 3] = "UndoRedoStackUpdated";
    EditorEventType2[EditorEventType2["CommandDone"] = 4] = "CommandDone";
    EditorEventType2[EditorEventType2["CommandUndone"] = 5] = "CommandUndone";
    EditorEventType2[EditorEventType2["ObjectAdded"] = 6] = "ObjectAdded";
    EditorEventType2[EditorEventType2["ViewportChanged"] = 7] = "ViewportChanged";
    EditorEventType2[EditorEventType2["DisplayResized"] = 8] = "DisplayResized";
    EditorEventType2[EditorEventType2["SelectionUpdated"] = 9] = "SelectionUpdated";
    EditorEventType2[EditorEventType2["ReadOnlyModeToggled"] = 10] = "ReadOnlyModeToggled";
    EditorEventType2[EditorEventType2["ColorPickerToggled"] = 11] = "ColorPickerToggled";
    EditorEventType2[EditorEventType2["ColorPickerColorSelected"] = 12] = "ColorPickerColorSelected";
    EditorEventType2[EditorEventType2["ToolbarDropdownShown"] = 13] = "ToolbarDropdownShown";
  })(EditorEventType || (EditorEventType = {}));
  var UndoEventType;
  (function(UndoEventType2) {
    UndoEventType2[UndoEventType2["CommandDone"] = 0] = "CommandDone";
    UndoEventType2[UndoEventType2["CommandUndone"] = 1] = "CommandUndone";
    UndoEventType2[UndoEventType2["CommandRedone"] = 2] = "CommandRedone";
  })(UndoEventType || (UndoEventType = {}));

  // node_modules/js-draw/dist/mjs/Pointer.mjs
  var PointerDevice;
  (function(PointerDevice2) {
    PointerDevice2[PointerDevice2["Pen"] = 0] = "Pen";
    PointerDevice2[PointerDevice2["Eraser"] = 1] = "Eraser";
    PointerDevice2[PointerDevice2["Touch"] = 2] = "Touch";
    PointerDevice2[PointerDevice2["PrimaryButtonMouse"] = 3] = "PrimaryButtonMouse";
    PointerDevice2[PointerDevice2["RightButtonMouse"] = 4] = "RightButtonMouse";
    PointerDevice2[PointerDevice2["Other"] = 5] = "Other";
  })(PointerDevice || (PointerDevice = {}));
  var Pointer = class _Pointer {
    constructor(screenPos, canvasPos, pressure, isPrimary, down, device, id, timeStamp) {
      this.screenPos = screenPos;
      this.canvasPos = canvasPos;
      this.pressure = pressure;
      this.isPrimary = isPrimary;
      this.down = down;
      this.device = device;
      this.id = id;
      this.timeStamp = timeStamp;
    }
    /**
     * Snaps this pointer to the nearest grid point (rounds the coordinates of this
     * pointer based on the current zoom). Returns a new Pointer and does not modify
     * this.
     */
    snappedToGrid(viewport) {
      const snappedCanvasPos = viewport.snapToGrid(this.canvasPos);
      return this.withCanvasPosition(snappedCanvasPos, viewport);
    }
    // Snap this pointer to the X or Y axis (whichever is closer), where (0,0)
    // is considered to be at `originPointScreen`.
    // @internal
    lockedToXYAxesScreen(originPointScreen, viewport) {
      const current = this.screenPos;
      const currentFromStart = current.minus(originPointScreen);
      const projOntoXAxis = Vec2.unitX.times(currentFromStart.x);
      const projOntoYAxis = Vec2.unitY.times(currentFromStart.y);
      let pos;
      if (currentFromStart.dot(projOntoXAxis) > currentFromStart.dot(projOntoYAxis)) {
        pos = projOntoXAxis;
      } else {
        pos = projOntoYAxis;
      }
      pos = pos.plus(originPointScreen);
      return this.withScreenPosition(pos, viewport);
    }
    /** @see {@link withCanvasPosition} */
    withScreenPosition(screenPos, viewport) {
      const canvasPos = viewport.screenToCanvas(screenPos);
      return this.withCanvasPosition(canvasPos, viewport);
    }
    /** Returns a copy of this pointer with a changed timestamp. */
    withTimestamp(timeStamp) {
      return new _Pointer(this.screenPos, this.canvasPos, this.pressure, this.isPrimary, this.down, this.device, this.id, timeStamp);
    }
    /**
     * Returns a copy of this pointer with a new position. The screen position is determined
     * by the given `canvasPos`.
     */
    withCanvasPosition(canvasPos, viewport) {
      const screenPos = viewport.canvasToScreen(canvasPos);
      return new _Pointer(screenPos, canvasPos, this.pressure, this.isPrimary, this.down, this.device, this.id, this.timeStamp);
    }
    // Creates a Pointer from a DOM event. If `relativeTo` is given, (0, 0) in screen coordinates is
    // considered the top left of `relativeTo`.
    static ofEvent(evt, isDown, viewport, relativeTo) {
      let screenPos = Vec2.of(evt.clientX, evt.clientY);
      if (relativeTo) {
        const bbox = relativeTo.getBoundingClientRect();
        screenPos = screenPos.minus(Vec2.of(bbox.left, bbox.top));
      }
      const pointerTypeToDevice = {
        mouse: PointerDevice.PrimaryButtonMouse,
        pen: PointerDevice.Pen,
        touch: PointerDevice.Touch
      };
      let device = pointerTypeToDevice[evt.pointerType] ?? PointerDevice.Other;
      const eraserButtonMask = 32;
      if (device === PointerDevice.Pen && (evt.buttons & eraserButtonMask) !== 0) {
        device = PointerDevice.Eraser;
      }
      const timeStamp = evt.timeStamp;
      const canvasPos = viewport.roundPoint(viewport.screenToCanvas(screenPos));
      if (device === PointerDevice.PrimaryButtonMouse) {
        if (evt.buttons & 2) {
          device = PointerDevice.RightButtonMouse;
        }
      }
      return new _Pointer(screenPos, canvasPos, evt.pressure ?? null, evt.isPrimary, isDown, device, evt.pointerId, timeStamp);
    }
    // Create a new Pointer from a point on the canvas.
    // Intended for unit tests.
    static ofCanvasPoint(canvasPos, isDown, viewport, id = 0, device = PointerDevice.Pen, isPrimary = true, pressure = null, timeStamp = null) {
      const screenPos = viewport.canvasToScreen(canvasPos);
      timeStamp ??= performance.now();
      return new _Pointer(screenPos, canvasPos, pressure, isPrimary, isDown, device, id, timeStamp);
    }
    // Create a new Pointer from a point on the screen.
    // Intended for unit tests.
    static ofScreenPoint(screenPos, isDown, viewport, id = 0, device = PointerDevice.Pen, isPrimary = true, pressure = null, timeStamp = null) {
      const canvasPos = viewport.screenToCanvas(screenPos);
      timeStamp ??= performance.now();
      return new _Pointer(screenPos, canvasPos, pressure, isPrimary, isDown, device, id, timeStamp);
    }
  };

  // node_modules/js-draw/dist/mjs/util/untilNextAnimationFrame.mjs
  var untilNextAnimationFrame = () => {
    return new Promise((resolve) => {
      requestAnimationFrame(() => resolve());
    });
  };
  var untilNextAnimationFrame_default = untilNextAnimationFrame;

  // node_modules/js-draw/dist/mjs/inputEvents.mjs
  var InputEvtType;
  (function(InputEvtType2) {
    InputEvtType2[InputEvtType2["PointerDownEvt"] = 0] = "PointerDownEvt";
    InputEvtType2[InputEvtType2["PointerMoveEvt"] = 1] = "PointerMoveEvt";
    InputEvtType2[InputEvtType2["PointerUpEvt"] = 2] = "PointerUpEvt";
    InputEvtType2[InputEvtType2["GestureCancelEvt"] = 3] = "GestureCancelEvt";
    InputEvtType2[InputEvtType2["WheelEvt"] = 4] = "WheelEvt";
    InputEvtType2[InputEvtType2["KeyPressEvent"] = 5] = "KeyPressEvent";
    InputEvtType2[InputEvtType2["KeyUpEvent"] = 6] = "KeyUpEvent";
    InputEvtType2[InputEvtType2["CopyEvent"] = 7] = "CopyEvent";
    InputEvtType2[InputEvtType2["PasteEvent"] = 8] = "PasteEvent";
    InputEvtType2[InputEvtType2["ContextMenu"] = 9] = "ContextMenu";
  })(InputEvtType || (InputEvtType = {}));
  var keyEventFromHTMLEvent = (kind, event) => {
    return {
      kind,
      key: event.key,
      code: event.code,
      ctrlKey: event.ctrlKey || event.metaKey,
      altKey: event.altKey,
      shiftKey: event.shiftKey
    };
  };
  var keyUpEventFromHTMLEvent = (event) => {
    return keyEventFromHTMLEvent(InputEvtType.KeyUpEvent, event);
  };
  var keyPressEventFromHTMLEvent = (event) => {
    return keyEventFromHTMLEvent(InputEvtType.KeyPressEvent, event);
  };
  var isPointerEvt = (event) => {
    return event.kind === InputEvtType.PointerDownEvt || event.kind === InputEvtType.PointerMoveEvt || event.kind === InputEvtType.PointerUpEvt;
  };

  // node_modules/js-draw/dist/mjs/util/ReactiveValue.mjs
  var __classPrivateFieldSet4 = function(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var __classPrivateFieldGet4 = function(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var _ReactiveValueImpl_value;
  var _ReactiveValueImpl_onUpdateListeners;
  var noOpUpdateListenerResult = {
    remove() {
    }
  };
  var noOpSetUpdateListener = () => {
    return noOpUpdateListenerResult;
  };
  var ReactiveValue = class _ReactiveValue {
    /** Returns a promise that resolves when this value is next changed. */
    waitForNextUpdate() {
      return new Promise((resolve) => {
        const listener = this.onUpdate((value) => {
          listener.remove();
          resolve(value);
        });
      });
    }
    /** Creates a `ReactiveValue` with an initial value, `initialValue`. */
    static fromInitialValue(initialValue) {
      return new ReactiveValueImpl(initialValue);
    }
    /** Returns a `ReactiveValue` that is **known** will never change. */
    static fromImmutable(value) {
      return {
        get: () => value,
        onUpdate: noOpSetUpdateListener,
        onUpdateAndNow: (callback) => {
          callback(value);
          return noOpUpdateListenerResult;
        },
        // Never resolves -- immutable.
        waitForNextUpdate: () => new Promise(() => {
        })
      };
    }
    /**
     * Creates a `ReactiveValue` whose values come from `callback`.
     *
     * `callback` is called whenever any of `sourceValues` are updated and initially to
     * set the initial value of the result.
     */
    static fromCallback(callback, sourceValues) {
      const result = new ReactiveValueImpl(callback());
      const resultRef = typeof WeakRef !== "undefined" ? new WeakRef(result) : { deref: () => result };
      for (const value of sourceValues) {
        const listener = value.onUpdate(() => {
          const value2 = resultRef.deref();
          if (value2) {
            value2.set(callback());
          } else {
            listener.remove();
          }
        });
      }
      return result;
    }
    static map(source, map, inverseMap) {
      const result = _ReactiveValue.fromInitialValue(map(source.get()));
      let expectedResultValue = result.get();
      source.onUpdate((newValue) => {
        expectedResultValue = map(newValue);
        result.set(expectedResultValue);
      });
      if (inverseMap) {
        result.onUpdate((newValue) => {
          if (newValue !== expectedResultValue) {
            source.set(inverseMap(newValue));
          }
        });
      }
      return result;
    }
    static union(values) {
      return _ReactiveValue.fromCallback(() => {
        return values.map((value) => value.get());
      }, values);
    }
  };
  var MutableReactiveValue = class extends ReactiveValue {
    static fromProperty(sourceValue, propertyName) {
      const child = ReactiveValue.fromInitialValue(sourceValue.get()[propertyName]);
      const childRef = typeof WeakRef !== "undefined" ? new WeakRef(child) : { deref: () => child };
      const sourceListener = sourceValue.onUpdate((newValue) => {
        const childValue = childRef.deref();
        if (childValue) {
          childValue.set(newValue[propertyName]);
        } else {
          sourceListener.remove();
        }
      });
      child.onUpdate((newValue) => {
        sourceValue.set({
          ...sourceValue.get(),
          [propertyName]: newValue
        });
      });
      return child;
    }
  };
  var ReactiveValueImpl = class extends MutableReactiveValue {
    constructor(initialValue) {
      super();
      _ReactiveValueImpl_value.set(this, void 0);
      _ReactiveValueImpl_onUpdateListeners.set(this, void 0);
      __classPrivateFieldSet4(this, _ReactiveValueImpl_value, initialValue, "f");
      __classPrivateFieldSet4(this, _ReactiveValueImpl_onUpdateListeners, [], "f");
    }
    set(newValue) {
      if (__classPrivateFieldGet4(this, _ReactiveValueImpl_value, "f") === newValue) {
        return;
      }
      __classPrivateFieldSet4(this, _ReactiveValueImpl_value, newValue, "f");
      for (const listener of __classPrivateFieldGet4(this, _ReactiveValueImpl_onUpdateListeners, "f")) {
        listener(newValue);
      }
    }
    get() {
      return __classPrivateFieldGet4(this, _ReactiveValueImpl_value, "f");
    }
    onUpdate(listener) {
      __classPrivateFieldGet4(this, _ReactiveValueImpl_onUpdateListeners, "f").push(listener);
      return {
        remove: () => {
          __classPrivateFieldSet4(this, _ReactiveValueImpl_onUpdateListeners, __classPrivateFieldGet4(this, _ReactiveValueImpl_onUpdateListeners, "f").filter((otherListener) => {
            return otherListener !== listener;
          }), "f");
        }
      };
    }
    onUpdateAndNow(callback) {
      callback(this.get());
      return this.onUpdate(callback);
    }
  };
  _ReactiveValueImpl_value = /* @__PURE__ */ new WeakMap(), _ReactiveValueImpl_onUpdateListeners = /* @__PURE__ */ new WeakMap();
  var ReactiveValue_default = ReactiveValue;

  // node_modules/js-draw/dist/mjs/tools/BaseTool.mjs
  var __classPrivateFieldSet5 = function(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var __classPrivateFieldGet5 = function(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var _BaseTool_enabled;
  var _BaseTool_group;
  var _BaseTool_inputMapper;
  var _BaseTool_readOnlyEditorChangeListener;
  var BaseTool = class {
    constructor(notifier, description) {
      this.notifier = notifier;
      this.description = description;
      _BaseTool_enabled.set(this, void 0);
      _BaseTool_group.set(this, null);
      _BaseTool_inputMapper.set(this, null);
      _BaseTool_readOnlyEditorChangeListener.set(this, null);
      __classPrivateFieldSet5(this, _BaseTool_enabled, ReactiveValue.fromInitialValue(true), "f");
      __classPrivateFieldGet5(this, _BaseTool_enabled, "f").onUpdate((enabled) => {
        if (enabled) {
          __classPrivateFieldGet5(this, _BaseTool_group, "f")?.notifyEnabled(this);
          this.notifier.dispatch(EditorEventType.ToolEnabled, {
            kind: EditorEventType.ToolEnabled,
            tool: this
          });
        } else {
          this.notifier.dispatch(EditorEventType.ToolDisabled, {
            kind: EditorEventType.ToolDisabled,
            tool: this
          });
        }
      });
    }
    /** Override this to allow this tool to be enabled in a read-only editor */
    canReceiveInputInReadOnlyEditor() {
      return false;
    }
    setInputMapper(mapper) {
      __classPrivateFieldSet5(this, _BaseTool_inputMapper, mapper, "f");
      if (mapper) {
        mapper.setEmitListener((event) => this.dispatchEventToCallback(event));
      }
    }
    getInputMapper() {
      return __classPrivateFieldGet5(this, _BaseTool_inputMapper, "f");
    }
    dispatchEventToCallback(event) {
      let exhaustivenessCheck;
      switch (event.kind) {
        case InputEvtType.PointerDownEvt:
          return this.onPointerDown(event);
        case InputEvtType.PointerMoveEvt:
          this.onPointerMove(event);
          break;
        case InputEvtType.PointerUpEvt:
          return this.onPointerUp(event) ?? false;
        case InputEvtType.GestureCancelEvt:
          this.onGestureCancel(event);
          break;
        case InputEvtType.WheelEvt:
          return this.onWheel(event);
        case InputEvtType.KeyPressEvent:
          return this.onKeyPress(event);
        case InputEvtType.KeyUpEvent:
          return this.onKeyUp(event);
        case InputEvtType.CopyEvent:
          return this.onCopy(event);
        case InputEvtType.PasteEvent:
          return this.onPaste(event);
        case InputEvtType.ContextMenu:
          return this.onContextMenu(event);
        default:
          exhaustivenessCheck = event;
          return exhaustivenessCheck;
      }
      return true;
    }
    // @internal
    onEvent(event) {
      if (__classPrivateFieldGet5(this, _BaseTool_inputMapper, "f")) {
        return __classPrivateFieldGet5(this, _BaseTool_inputMapper, "f").onEvent(event);
      }
      return this.dispatchEventToCallback(event);
    }
    /**
     * Returns true iff the tool handled the event and thus should receive additional
     * events.
     */
    onPointerDown(_event) {
      return false;
    }
    onPointerMove(_event) {
    }
    /**
     * Returns true iff there are additional pointers down and the tool should
     * remain active to handle the additional events.
     *
     * For most purposes, this should return `false` or nothing.
     */
    onPointerUp(_event) {
    }
    onGestureCancel(_event) {
    }
    onWheel(_event) {
      return false;
    }
    onCopy(_event) {
      return false;
    }
    onPaste(_event) {
      return false;
    }
    onKeyPress(_event) {
      return false;
    }
    onKeyUp(_event) {
      return false;
    }
    onContextMenu(_event) {
      return false;
    }
    /**
     * Return true if, while this tool is active, `_event` can be delivered to
     * another tool that is higher priority than this.
     * @internal May be renamed
     */
    eventCanBeDeliveredToNonActiveTool(_event) {
      return true;
    }
    setEnabled(enabled) {
      __classPrivateFieldGet5(this, _BaseTool_enabled, "f").set(enabled);
    }
    isEnabled() {
      return __classPrivateFieldGet5(this, _BaseTool_enabled, "f").get();
    }
    /**
     * Returns a {@link ReactiveValue} that updates based on whether this tool is
     * enabled.
     *
     * @example
     * ```ts
     * const tool = new SomeTool();
     *
     * // Watch for changes in enabled status
     * tool.enabledValue().onUpdate(enabled => doSomething(enabled));
     * ```
     */
    enabledValue() {
      return __classPrivateFieldGet5(this, _BaseTool_enabled, "f");
    }
    // Connect this tool to a set of other tools, ensuring that at most one
    // of the tools in the group is enabled.
    setToolGroup(group) {
      if (this.isEnabled()) {
        group.notifyEnabled(this);
      }
      __classPrivateFieldSet5(this, _BaseTool_group, group, "f");
    }
    getToolGroup() {
      if (__classPrivateFieldGet5(this, _BaseTool_group, "f")) {
        return __classPrivateFieldGet5(this, _BaseTool_group, "f");
      }
      return null;
    }
    // Called when the tool is removed/when the editor is destroyed.
    // Subclasses that override this method **must call super.onDestroy()**.
    onDestroy() {
      __classPrivateFieldGet5(this, _BaseTool_readOnlyEditorChangeListener, "f")?.remove();
      __classPrivateFieldSet5(this, _BaseTool_readOnlyEditorChangeListener, null, "f");
      __classPrivateFieldSet5(this, _BaseTool_group, null, "f");
    }
  };
  _BaseTool_enabled = /* @__PURE__ */ new WeakMap(), _BaseTool_group = /* @__PURE__ */ new WeakMap(), _BaseTool_inputMapper = /* @__PURE__ */ new WeakMap(), _BaseTool_readOnlyEditorChangeListener = /* @__PURE__ */ new WeakMap();
  var BaseTool_default = BaseTool;

  // node_modules/js-draw/dist/mjs/commands/localization.mjs
  var defaultCommandLocalization = {
    updatedViewport: "Transformed Viewport",
    transformedElements: (elemCount, action) => `Transformed ${elemCount} element${elemCount === 1 ? "" : "s"} (${action})`,
    resizeOutputCommand: (newSize) => `Resized image to ${newSize.w}x${newSize.h}`,
    enabledAutoresizeOutputCommand: "Enabled output autoresize",
    disabledAutoresizeOutputCommand: "Disabled output autoresize",
    addComponentAction: (componentDescription) => `Added ${componentDescription}`,
    eraseAction: (componentDescription, numElems) => `Erased ${numElems} ${componentDescription}`,
    duplicateAction: (componentDescription, numElems) => `Duplicated ${numElems} ${componentDescription}`,
    unionOf: (actionDescription, actionCount) => `Union: ${actionCount} ${actionDescription}`,
    inverseOf: (actionDescription) => `Inverse of ${actionDescription}`,
    elements: "Elements",
    erasedNoElements: "Erased nothing",
    duplicatedNoElements: "Duplicated nothing",
    rotatedBy: (degrees) => `Rotated by ${Math.abs(degrees)} degrees ${degrees < 0 ? "clockwise" : "counter-clockwise"}`,
    movedLeft: "Moved left",
    movedUp: "Moved up",
    movedDown: "Moved down",
    movedRight: "Moved right",
    zoomedOut: "Zoomed out",
    zoomedIn: "Zoomed in",
    andNMoreCommands: (count) => `And ${count} more commands.`,
    selectedElements: (count) => `Selected ${count} element${count === 1 ? "" : "s"}`
  };

  // node_modules/js-draw/dist/mjs/components/localization.mjs
  var defaultComponentLocalization = {
    unlabeledImageNode: "Unlabeled image node",
    stroke: "Stroke",
    svgObject: "SVG Object",
    emptyBackground: "Empty background",
    gridBackground: "Grid background",
    filledBackgroundWithColor: (color) => `Filled background (${color})`,
    text: (text) => `Text object: ${text}`,
    imageNode: (description) => `Image: ${description}`,
    restyledElement: (elementDescription) => `Restyled ${elementDescription}`
  };

  // node_modules/js-draw/dist/mjs/rendering/localization.mjs
  var defaultTextRendererLocalization = {
    pathNodeCount: (count) => `There are ${count} visible path objects.`,
    textNodeCount: (count) => `There are ${count} visible text nodes.`,
    imageNodeCount: (nodeCount) => `There are ${nodeCount} visible image nodes.`,
    textNode: (content) => `Text: ${content}`,
    imageNode: (label) => `Image: ${label}`,
    unlabeledImageNode: "Unlabeled image",
    rerenderAsText: "Re-render as text"
  };

  // node_modules/js-draw/dist/mjs/toolbar/utils/localization.mjs
  var defaultToolbarUtilsLocalization = {
    help: "Help",
    helpHidden: "Help hidden",
    next: "Next",
    previous: "Previous",
    close: "Close",
    helpScreenNavigationHelp: "Click on a control for more information.",
    helpControlsAccessibilityLabel: "Controls: Activate a control to show help."
  };

  // node_modules/js-draw/dist/mjs/toolbar/localization.mjs
  var defaultToolbarLocalization = {
    ...defaultToolbarUtilsLocalization,
    pen: "Pen",
    eraser: "Eraser",
    select: "Select",
    handTool: "Pan",
    zoom: "Zoom",
    image: "Image",
    reformatSelection: "Format selection",
    inputAltText: "Alt text",
    decreaseImageSize: "Decrease size",
    resetImage: "Reset",
    chooseFile: "Choose file",
    dragAndDropHereOrBrowse: "Drag and drop here\nor\n{{browse}}",
    submit: "Submit",
    addAll: "Add all",
    cancel: "Cancel",
    resetView: "Reset view",
    thicknessLabel: "Thickness",
    colorLabel: "Color",
    fontLabel: "Font",
    textSize: "Size",
    resizeImageToSelection: "Resize image to selection",
    deleteSelection: "Delete selection",
    duplicateSelection: "Duplicate selection",
    exit: "Exit",
    save: "Save",
    undo: "Undo",
    redo: "Redo",
    fullStrokeEraser: "Full stroke eraser",
    selectPenType: "Pen type",
    selectShape: "Shape",
    pickColorFromScreen: "Pick color from screen",
    clickToPickColorAnnouncement: "Click on the screen to pick a color",
    colorSelectionCanceledAnnouncement: "Color selection canceled",
    selectionTool__lassoSelect: "Freeform selection",
    selectionTool__lassoSelect__help: "When enabled, dragging creates a freeform (lasso) selection.",
    selectionToolKeyboardShortcuts: "Selection tool: Use arrow keys to move selected items, lowercase/uppercase \u2018i\u2019 and \u2018o\u2019 to resize.",
    documentProperties: "Page",
    backgroundColor: "Background color",
    imageWidthOption: "Width",
    imageHeightOption: "Height",
    useGridOption: "Grid",
    enableAutoresizeOption: "Auto-resize",
    toggleOverflow: "More",
    about: "About",
    inputStabilization: "Stabilization",
    strokeAutocorrect: "Autocorrect",
    pressureSensitivity: "Pressure",
    touchPanning: "Scroll with touch",
    roundedTipPen: "Round",
    roundedTipPen2: "Polyline",
    flatTipPen: "Flat",
    arrowPen: "Arrow",
    linePen: "Line",
    outlinedRectanglePen: "Outlined rectangle",
    filledRectanglePen: "Filled rectangle",
    outlinedCirclePen: "Outlined circle",
    lockRotation: "Lock rotation",
    paste: "Paste",
    errorImageHasZeroSize: "Error: Image has zero size",
    describeTheImage: "Image description",
    fileInput__loading: "Loading...",
    fileInput__andNMoreFiles: (n) => `(...${n} more)`,
    // Help text
    penDropdown__baseHelpText: "This tool draws shapes or freehand lines.",
    penDropdown__colorHelpText: "Changes the pen's color",
    penDropdown__thicknessHelpText: "Changes the thickness of strokes drawn by the pen.",
    penDropdown__penTypeHelpText: "Changes the pen style.\n\nEither a \u201Cpen\u201D style or \u201Cshape\u201D can be chosen. Choosing a \u201Cpen\u201D style draws freehand lines. Choosing a \u201Cshape\u201D draws shapes.",
    penDropdown__autocorrectHelpText: "Converts approximate freehand lines and rectangles to perfect ones.\n\nThe pen must be held stationary at the end of a stroke to trigger a correction.",
    penDropdown__stabilizationHelpText: "Draws smoother strokes.\n\nThis also adds a short delay between the mouse/stylus and the stroke.",
    penDropdown__pressureSensitivityHelpText: "Changes the thickness of strokes according to how hard you press, when using a compatible device like a stylus.",
    handDropdown__baseHelpText: "This tool is responsible for scrolling, rotating, and zooming the editor.",
    handDropdown__zoomInHelpText: "Zooms in.",
    handDropdown__zoomOutHelpText: "Zooms out.",
    handDropdown__resetViewHelpText: "Resets the zoom level to 100% and resets scroll.",
    handDropdown__zoomDisplayHelpText: "Shows the current zoom level. 100% shows the image at its actual size.",
    handDropdown__touchPanningHelpText: "When enabled, touchscreen gestures move the image rather than select or draw.",
    handDropdown__lockRotationHelpText: "When enabled, prevents touch gestures from rotating the screen.",
    eraserDropdown__baseHelpText: "This tool removes strokes, images, and text under the cursor.",
    eraserDropdown__thicknessHelpText: "Changes the size of the eraser.",
    eraserDropdown__fullStrokeEraserHelpText: "When in full-stroke mode, entire shapes are erased.\n\nWhen not in full-stroke mode, shapes can be partially erased.",
    selectionDropdown__baseHelpText: "Selects content and manipulates the selection",
    selectionDropdown__resizeToHelpText: "Crops the drawing to the size of what's currently selected.\n\nIf auto-resize is enabled, it will be disabled.",
    selectionDropdown__deleteHelpText: "Erases selected items.",
    selectionDropdown__duplicateHelpText: "Makes a copy of selected items.",
    selectionDropdown__changeColorHelpText: "Changes the color of selected items.",
    pageDropdown__baseHelpText: "Controls the drawing canvas' background color, pattern, and size.",
    pageDropdown__backgroundColorHelpText: "Changes the background color of the drawing canvas.",
    pageDropdown__gridCheckboxHelpText: "Enables/disables a background grid pattern.",
    pageDropdown__autoresizeCheckboxHelpText: "When checked, the page grows to fit the drawing.\n\nWhen unchecked, the page is visible and its size can be set manually.",
    pageDropdown__aboutButtonHelpText: "Shows version, debug, and other information.",
    colorPickerPipetteHelpText: "Picks a color from the screen.",
    colorPickerToggleHelpText: "Opens/closes the color picker.",
    closeSidebar: (toolName) => `Close sidebar for ${toolName}`,
    dropdownShown: (toolName) => `Menu for ${toolName} shown`,
    dropdownHidden: (toolName) => `Menu for ${toolName} hidden`,
    zoomLevel: (zoomPercent) => `Zoom: ${zoomPercent}%`,
    colorChangedAnnouncement: (color) => `Color changed to ${color}`,
    imageSize: (size, units) => `Image size: ${size} ${units}`,
    imageLoadError: (message) => `Error loading image: ${message}`
  };

  // node_modules/js-draw/dist/mjs/tools/localization.mjs
  var defaultToolLocalization = {
    penTool: (penId) => `Pen ${penId}`,
    selectionTool: "Selection",
    selectAllTool: "Select all shortcut",
    eraserTool: "Eraser",
    touchPanTool: "Touch panning",
    twoFingerPanZoomTool: "Panning and zooming",
    undoRedoTool: "Undo/Redo",
    rightClickDragPanTool: "Right-click drag",
    pipetteTool: "Pick color from screen",
    keyboardPanZoom: "Keyboard pan/zoom shortcuts",
    selectionMenu__show: "Show selection menu",
    selectionMenu__copyToClipboard: "Copy to clipboard",
    selectionMenu__duplicate: "Duplicate",
    selectionMenu__delete: "Delete",
    selectionMenu__paste: "Paste",
    copyPasteError__heading: "Copy/paste",
    copyPasteError__description: "Something went wrong \u2014 this tool may not have clipboard access.",
    copyPasteError__errorDetails: "Show error",
    copyPasteError__pasteRetry: "To retry, please paste into the input box below:",
    copyPasteError__copyRetry: "To retry, please copy the text in the input box below:",
    copyPasteError__copyMe: "Copy me!",
    autocorrectedTo: (strokeDescription) => `Autocorrected to ${strokeDescription}`,
    autocorrectionCanceled: "Autocorrect cancelled",
    textTool: "Text",
    enterTextToInsert: "Text to insert",
    changeTool: "Change tool",
    pasteHandler: "Copy paste handler",
    soundExplorer: "Sound-based image exploration",
    disableAccessibilityExploreTool: "Disable sound-based exploration",
    enableAccessibilityExploreTool: "Enable sound-based exploration",
    soundExplorerUsageAnnouncement: "Sound-based image exploration enabled: Click/drag the screen to play a sound representation of different parts of the image.",
    findLabel: "Find",
    toNextMatch: "Next",
    closeDialog: "Close",
    findDialogShown: "Find dialog shown",
    findDialogHidden: "Find dialog hidden",
    focusedFoundText: (matchIdx, totalMatches) => `Viewing match ${matchIdx} of ${totalMatches}`,
    anyDevicePanning: "Any device panning",
    copied: (count) => `Copied ${count} item(s)`,
    pasted: (count) => `Pasted ${count} item(s)`,
    toolEnabledAnnouncement: (toolName) => `${toolName} enabled`,
    toolDisabledAnnouncement: (toolName) => `${toolName} disabled`
  };

  // node_modules/js-draw/dist/mjs/localization.mjs
  var defaultEditorLocalization = {
    ...defaultToolbarLocalization,
    ...defaultToolLocalization,
    ...defaultCommandLocalization,
    ...defaultComponentLocalization,
    ...defaultTextRendererLocalization,
    accessibilityInputInstructions: [
      'Press "t" to read the contents of the viewport as text.',
      "Use the arrow keys to move the viewport, click and drag to draw strokes.",
      'Press "w" to zoom in and "s" to zoom out.'
    ].join(" "),
    loading: (percentage) => `Loading ${percentage}%...`,
    imageEditor: "Image Editor",
    doneLoading: "Done loading",
    undoAnnouncement: (commandDescription) => `Undid ${commandDescription}`,
    redoAnnouncement: (commandDescription) => `Redid ${commandDescription}`,
    softwareLibraries: "Libraries",
    developerInformation: "Developer information"
  };

  // node_modules/js-draw/dist/mjs/localizations/zh.mjs
  var localization2 = {
    ...defaultEditorLocalization,
    help: "\u5E2E\u52A9",
    helpHidden: "\u5E2E\u52A9\u5DF2\u9690\u85CF",
    next: "\u4E0B\u4E00\u9875",
    previous: "\u4E0A\u4E00\u9875",
    close: "\u5173\u95ED",
    helpScreenNavigationHelp: "\u70B9\u51FB\u63A7\u4EF6\u67E5\u770B\u66F4\u591A\u4FE1\u606F\u3002",
    helpControlsAccessibilityLabel: "\u63A7\u4EF6\uFF1A\u6FC0\u6D3B\u63A7\u4EF6\u4EE5\u663E\u793A\u5E2E\u52A9\u3002",
    pen: "\u753B\u7B14",
    eraser: "\u6A61\u76AE\u64E6",
    select: "\u9009\u62E9",
    handTool: "\u5E73\u79FB",
    zoom: "\u7F29\u653E",
    image: "\u56FE\u7247",
    reformatSelection: "\u683C\u5F0F\u5316\u9009\u533A",
    inputAltText: "\u66FF\u4EE3\u6587\u672C",
    decreaseImageSize: "\u51CF\u5C0F\u5C3A\u5BF8",
    resetImage: "\u91CD\u7F6E",
    chooseFile: "\u9009\u62E9\u6587\u4EF6",
    dragAndDropHereOrBrowse: "\u5C06\u6587\u4EF6\u62D6\u62FD\u5230\u6B64\u5904\u6216{{\u6D4F\u89C8}}",
    submit: "\u63D0\u4EA4",
    addAll: "\u5168\u90E8\u6DFB\u52A0",
    cancel: "\u53D6\u6D88",
    resetView: "\u91CD\u7F6E\u89C6\u56FE",
    thicknessLabel: "\u7C97\u7EC6",
    colorLabel: "\u989C\u8272",
    fontLabel: "\u5B57\u4F53",
    textSize: "\u5B57\u53F7",
    resizeImageToSelection: "\u6309\u9009\u533A\u8C03\u6574\u56FE\u7247\u5927\u5C0F",
    deleteSelection: "\u5220\u9664\u9009\u533A",
    duplicateSelection: "\u590D\u5236\u9009\u533A",
    exit: "\u9000\u51FA",
    save: "\u4FDD\u5B58",
    undo: "\u64A4\u9500",
    redo: "\u91CD\u505A",
    fullStrokeEraser: "\u5168\u7B14\u5212\u6A61\u76AE\u64E6",
    selectPenType: "\u5DE5\u5177\u7C7B\u578B",
    selectShape: "\u5F62\u72B6",
    pickColorFromScreen: "\u4ECE\u5C4F\u5E55\u53D6\u8272",
    clickToPickColorAnnouncement: "\u70B9\u51FB\u5C4F\u5E55\u4EE5\u9009\u53D6\u989C\u8272",
    colorSelectionCanceledAnnouncement: "\u989C\u8272\u9009\u62E9\u5DF2\u53D6\u6D88",
    selectionTool__lassoSelect: "\u81EA\u7531\u9009\u533A",
    selectionTool__lassoSelect__help: "\u542F\u7528\u540E\uFF0C\u62D6\u62FD\u5C06\u521B\u5EFA\u81EA\u7531\u5F62\u5F0F\uFF08\u5957\u7D22\uFF09\u9009\u533A\u3002",
    selectionToolKeyboardShortcuts: "\u9009\u62E9\u5DE5\u5177\uFF1A\u4F7F\u7528\u65B9\u5411\u952E\u79FB\u52A8\u6240\u9009\u9879\u76EE\uFF0C\u4F7F\u7528\u5C0F\u5199/\u5927\u5199 \u201Ci\u201D \u548C \u201Co\u201D \u8C03\u6574\u5927\u5C0F\u3002",
    documentProperties: "\u9875\u9762",
    backgroundColor: "\u80CC\u666F\u8272",
    imageWidthOption: "\u5BBD\u5EA6",
    imageHeightOption: "\u9AD8\u5EA6",
    useGridOption: "\u7F51\u683C",
    enableAutoresizeOption: "\u81EA\u52A8\u8C03\u6574\u5927\u5C0F",
    toggleOverflow: "\u66F4\u591A",
    about: "\u5173\u4E8E",
    inputStabilization: "\u7A33\u5B9A",
    strokeAutocorrect: "\u81EA\u52A8\u66F4\u6B63",
    pressureSensitivity: "\u538B\u529B",
    touchPanning: "\u89E6\u5C4F\u5E73\u79FB",
    roundedTipPen: "\u81EA\u7531\u753B\u7B14",
    roundedTipPen2: "\u6298\u7EBF",
    flatTipPen: "\u5E73\u5934\u7B14",
    arrowPen: "\u7BAD\u5934",
    linePen: "\u76F4\u7EBF",
    outlinedRectanglePen: "\u7A7A\u5FC3\u77E9\u5F62",
    filledRectanglePen: "\u5B9E\u5FC3\u77E9\u5F62",
    outlinedCirclePen: "\u7A7A\u5FC3\u5706",
    lockRotation: "\u9501\u5B9A\u65CB\u8F6C",
    paste: "\u7C98v\u8D34",
    errorImageHasZeroSize: "\u9519\u8BEF\uFF1A\u56FE\u7247\u5C3A\u5BF8\u4E3A\u96F6",
    describeTheImage: "\u56FE\u50CF\u63CF\u8FF0",
    fileInput__loading: "\u52A0\u8F7D\u4E2D...",
    fileInput__andNMoreFiles: (n) => `(\u8FD8\u6709 ${n} \u4E2A)`,
    closeSidebar: (toolName) => `\u5173\u95ED ${toolName} \u7684\u4FA7\u8FB9\u680F`,
    dropdownShown: (toolName) => `\u5DF2\u663E\u793A ${toolName} \u4E0B\u62C9\u83DC\u5355`,
    dropdownHidden: (toolName) => `\u5DF2\u9690\u85CF ${toolName} \u4E0B\u62C9\u83DC\u5355`,
    zoomLevel: (zoomPercent) => `\u7F29\u653E\uFF1A${zoomPercent}%`,
    colorChangedAnnouncement: (color) => `\u989C\u8272\u5DF2\u66F4\u6539\u4E3A ${color}`,
    imageSize: (size, units) => `\u56FE\u7247\u5C3A\u5BF8\uFF1A${size} ${units}`,
    imageLoadError: (message) => `\u56FE\u7247\u52A0\u8F7D\u9519\u8BEF\uFF1A${message}`,
    penTool: (penId) => `\u753B\u7B14 ${penId}`,
    selectionTool: "\u9009\u62E9\u5DE5\u5177",
    selectAllTool: "\u5168\u9009",
    eraserTool: "\u6A61\u76AE\u64E6\u5DE5\u5177",
    touchPanTool: "\u89E6\u5C4F\u5E73\u79FB\u5DE5\u5177",
    twoFingerPanZoomTool: "\u53CC\u6307\u5E73\u79FB\u4E0E\u7F29\u653E",
    undoRedoTool: "\u64A4\u9500/\u91CD\u505A\u5DE5\u5177",
    rightClickDragPanTool: "\u53F3\u952E\u62D6\u62FD",
    pipetteTool: "\u53D6\u8272\u5668",
    keyboardPanZoom: "\u952E\u76D8\u5E73\u79FB\u4E0E\u7F29\u653E\u5FEB\u6377\u952E",
    selectionMenu__show: "\u663E\u793A\u9009\u62E9\u83DC\u5355",
    selectionMenu__copyToClipboard: "\u590D\u5236\u5230\u526A\u8D34\u677F",
    selectionMenu__duplicate: "\u590D\u5236",
    selectionMenu__delete: "\u5220\u9664",
    selectionMenu__paste: "\u7C98\u8D34",
    copyPasteError__heading: "\u590D\u5236/\u7C98\u8D34",
    copyPasteError__description: "\u51FA\u9519\u4E86\u2014\u2014\u6B64\u5DE5\u5177\u53EF\u80FD\u65E0\u6CD5\u8BBF\u95EE\u526A\u8D34\u677F\u3002",
    copyPasteError__errorDetails: "\u663E\u793A\u9519\u8BEF",
    copyPasteError__pasteRetry: "\u8BF7\u91CD\u8BD5\uFF1A\u5728\u4E0B\u65B9\u8F93\u5165\u6846\u4E2D\u7C98\u8D34\uFF1A",
    copyPasteError__copyRetry: "\u8BF7\u91CD\u8BD5\uFF1A\u5728\u4E0B\u65B9\u8F93\u5165\u6846\u4E2D\u590D\u5236\u6587\u672C\uFF1A",
    copyPasteError__copyMe: "\u70B9\u6211\u590D\u5236\uFF01",
    autocorrectedTo: (strokeDescription) => `\u5DF2\u81EA\u52A8\u66F4\u6B63\u4E3A ${strokeDescription}`,
    autocorrectionCanceled: "\u81EA\u52A8\u66F4\u6B63\u5DF2\u53D6\u6D88",
    textTool: "\u6587\u672C\u5DE5\u5177",
    enterTextToInsert: "\u8F93\u5165\u8981\u63D2\u5165\u7684\u6587\u672C",
    changeTool: "\u5207\u6362\u5DE5\u5177",
    pasteHandler: "\u590D\u5236\u7C98\u8D34\u5904\u7406\u5668",
    soundExplorer: "\u58F0\u97F3\u63A2\u7D22",
    disableAccessibilityExploreTool: "\u5173\u95ED\u58F0\u97F3\u63A2\u7D22",
    enableAccessibilityExploreTool: "\u5F00\u542F\u58F0\u97F3\u63A2\u7D22",
    soundExplorerUsageAnnouncement: "\u5DF2\u542F\u7528\u58F0\u97F3\u56FE\u50CF\u63A2\u7D22\uFF1A\u70B9\u51FB\u6216\u62D6\u62FD\u5C4F\u5E55\uFF0C\u5373\u53EF\u901A\u8FC7\u58F0\u97F3\u611F\u53D7\u56FE\u50CF\u4E0D\u540C\u533A\u57DF\u3002",
    findLabel: "\u67E5\u627E",
    toNextMatch: "\u4E0B\u4E00\u4E2A",
    closeDialog: "\u5173\u95ED",
    findDialogShown: "\u5DF2\u663E\u793A\u67E5\u627E\u5BF9\u8BDD\u6846",
    findDialogHidden: "\u5DF2\u9690\u85CF\u67E5\u627E\u5BF9\u8BDD\u6846",
    focusedFoundText: (matchIdx, totalMatches) => `\u7B2C ${matchIdx} \u6761\u7ED3\u679C\uFF0C\u5171 ${totalMatches} \u6761`,
    anyDevicePanning: "\u4EFB\u610F\u8BBE\u5907\u5E73\u79FB",
    copied: (count) => `\u5DF2\u590D\u5236 ${count} \u4E2A\u9879\u76EE`,
    pasted: (count) => `\u5DF2\u7C98\u8D34 ${count} \u4E2A\u9879\u76EE`,
    toolEnabledAnnouncement: (toolName) => `${toolName} \u5DF2\u542F\u7528`,
    toolDisabledAnnouncement: (toolName) => `${toolName} \u5DF2\u7981\u7528`,
    updatedViewport: "\u5DF2\u66F4\u65B0\u89C6\u53E3",
    transformedElements: (elemCount, action) => `${elemCount} \u4E2A\u5143\u7D20\u5DF2\u53D8\u6362 (${action})`,
    resizeOutputCommand: (newSize) => `\u56FE\u7247\u5C3A\u5BF8\u5DF2\u66F4\u6539\u4E3A ${newSize.w}\xD7${newSize.h}`,
    enabledAutoresizeOutputCommand: "\u5DF2\u542F\u7528\u8F93\u51FA\u81EA\u52A8\u8C03\u6574\u5927\u5C0F",
    disabledAutoresizeOutputCommand: "\u5DF2\u7981\u7528\u8F93\u51FA\u81EA\u52A8\u8C03\u6574\u5927\u5C0F",
    addComponentAction: (componentDescription) => `\u5DF2\u6DFB\u52A0 ${componentDescription}`,
    eraseAction: (componentDescription, countErased) => `\u5DF2\u5220\u9664 ${countErased} \u4E2A ${componentDescription}`,
    duplicateAction: (componentDescription, countErased) => `\u5DF2\u590D\u5236 ${countErased} \u4E2A ${componentDescription}`,
    unionOf: (actionDescription, actionCount) => `\u5408\u5E76\uFF1A${actionCount} \u4E2A ${actionDescription}`,
    inverseOf: (actionDescription) => `${actionDescription} \u5DF2\u53CD\u5411`,
    elements: "\u5143\u7D20",
    erasedNoElements: "\u672Av\u5220\u9664\u4EFB\u4F55\u5185\u5BB9",
    duplicatedNoElements: "\u672A\u590D\u5236\u4EFB\u4F55\u5185\u5BB9",
    rotatedBy: (degrees) => `\u5DF2\u65CB\u8F6C ${Math.abs(degrees)} \u5EA6 ${degrees < 0 ? "\u987A\u65F6\u9488" : "\u9006\u65F6\u9488"}`,
    movedLeft: "\u5DF2\u5411\u5DE6\u79FB\u52A8",
    movedUp: "\u5DF2\u5411\u4E0A\u79FB\u52A8",
    movedDown: "\u5DF2\u5411\u4E0B\u79FB\u52A8",
    movedRight: "\u5DF2\u5411\u53F3\u79FB\u52A8",
    zoomedOut: "\u5DF2\u7F29\u5C0F",
    zoomedIn: "\u5DF2\u653E\u5927",
    andNMoreCommands: (count) => `\u8FD8\u6709 ${count} \u6761\u547D\u4EE4\u3002`,
    selectedElements: (count) => `\u5DF2\u9009 ${count} \u4E2A\u5143\u7D20`,
    unlabeledImageNode: "\u672A\u547D\u540D\u56FE\u7247",
    stroke: "\u7B14\u753B",
    svgObject: "SVG \u5BF9\u8C61",
    emptyBackground: "\u7A7A\u767D\u80CC\u666F",
    gridBackground: "\u7F51\u683C\u80CC\u666F",
    filledBackgroundWithColor: (color) => `\u5DF2\u586B\u5145\u80CC\u666F\uFF08${color}\uFF09`,
    text: (text) => `\u6587\u672C\u5BF9\u8C61\uFF1A${text}`,
    imageNode: (label) => `\u56FE\u7247\uFF1A${label}`,
    restyledElement: (elementDescription) => `\u5DF2\u91CD\u65B0\u6837\u5F0F\u5316 ${elementDescription}`,
    pathNodeCount: (count) => `\u53EF\u89C1\u8DEF\u5F84\u5BF9\u8C61\uFF1A${count} \u4E2A`,
    textNodeCount: (count) => `\u53EF\u89C1\u6587\u672C\u8282\u70B9\uFF1A${count} \u4E2A`,
    imageNodeCount: (nodeCount) => `\u53EF\u89C1\u56FE\u7247\u8282\u70B9\uFF1A${nodeCount} \u4E2A`,
    textNode: (content) => `\u6587\u672C\uFF1A${content}`,
    rerenderAsText: "\u4EE5\u6587\u672C\u5F62\u5F0F\u91CD\u7ED8",
    accessibilityInputInstructions: "\u6309\u201Ct\u201D\u5C06\u89C6\u53E3\u5185\u5BB9\u6717\u8BFB\u4E3A\u6587\u672C\u3002\u4F7F\u7528\u65B9\u5411\u952E\u79FB\u52A8\u89C6\u53E3\uFF0C\u70B9\u51FB\u5E76\u62D6\u62FD\u7ED8\u5236\u7B14\u753B\u3002\u6309\u201Cw\u201D\u653E\u5927\uFF0C\u6309\u201Cs\u201D\u7F29\u5C0F\u3002",
    loading: (percentage) => `\u52A0\u8F7D\u4E2D ${percentage}%...`,
    imageEditor: "\u56FE\u7247\u7F16\u8F91\u5668",
    doneLoading: "\u52A0\u8F7D\u5B8C\u6210",
    undoAnnouncement: (commandDescription) => `\u5DF2\u64A4\u9500 ${commandDescription}`,
    redoAnnouncement: (commandDescription) => `\u5DF2\u91CD\u505A ${commandDescription}`,
    softwareLibraries: "\u8F6F\u4EF6\u5E93",
    developerInformation: "\u5F00\u53D1\u8005\u4FE1\u606F"
  };
  var zh_default = localization2;

  // node_modules/js-draw/dist/mjs/localizations/de.mjs
  var localization3 = {
    ...defaultEditorLocalization,
    help: "Hilfe",
    helpHidden: "Hilfe ausgeblendet",
    next: "Weiter",
    previous: "Zur\xFCck",
    close: "Schlie\xDFen",
    helpScreenNavigationHelp: "Auf ein Steuerelement klicken, um weitere Informationen zu erhalten.",
    helpControlsAccessibilityLabel: "Steuerelemente: Aktiviere ein Steuerelement, um Hilfe anzuzeigen.",
    pen: "Stift",
    eraser: "Radierer",
    select: "Auswahl",
    handTool: "Verschieben",
    zoom: "Vergr\xF6\xDFerung",
    image: "Bild",
    reformatSelection: "Formatauswahl",
    inputAltText: "Alt-Text:",
    decreaseImageSize: "Verkleinern",
    resetImage: "Zur\xFCcksetzen",
    chooseFile: "Datei w\xE4hlen",
    dragAndDropHereOrBrowse: "Hierher ziehen\noder\n{{Durchsuchen}}",
    submit: "Absenden",
    addAll: "Alle hinzuf\xFCgen",
    cancel: "Abbrechen",
    resetView: "Ansicht zur\xFCcksetzen",
    thicknessLabel: "Dicke:",
    colorLabel: "Farbe:",
    fontLabel: "Schriftart:",
    textSize: "Gr\xF6\xDFe:",
    resizeImageToSelection: "Bildgr\xF6\xDFe an Auswahl anpassen",
    deleteSelection: "Auswahl l\xF6schen",
    duplicateSelection: "Auswahl duplizieren",
    exit: "Beenden",
    save: "Speichern",
    undo: "R\xFCckg\xE4ngig",
    redo: "Wiederholen",
    fullStrokeEraser: "Vollst\xE4ndiger Radierer",
    selectPenType: "Stiftstil:",
    selectShape: "Form",
    pickColorFromScreen: "Farbe von Bildschirm ausw\xE4hlen",
    clickToPickColorAnnouncement: "Klicke auf den Bildschirm, um eine Farbe auszuw\xE4hlen",
    colorSelectionCanceledAnnouncement: "Farbauswahl abgebrochen",
    selectionTool__lassoSelect: "Freihand-Auswahl",
    selectionTool__lassoSelect__help: "Wenn diese Option aktiviert ist, wird durch Ziehen eine Freiformauswahl (Lasso) erstellt.",
    selectionToolKeyboardShortcuts: "Auswahl-Werkzeug: Verwende die Pfeiltasten, um ausgew\xE4hlte Elemente zu verschieben, und die Kleinbuchstaben/Gro\xDFbuchstaben \u201Ei\u201C und \u201Eo\u201C, um die Gr\xF6\xDFe zu \xE4ndern.",
    documentProperties: "Seite",
    backgroundColor: "Hintergrundfarbe:",
    imageWidthOption: "Breite:",
    imageHeightOption: "H\xF6he:",
    useGridOption: "Gitter:",
    enableAutoresizeOption: "Automatische Gr\xF6\xDFenanpassung",
    toggleOverflow: "Mehr",
    about: "\xDCber",
    inputStabilization: "Stabilisierung",
    strokeAutocorrect: "Autokorrektur",
    pressureSensitivity: "Druck",
    touchPanning: "Mit Touch verschieben",
    roundedTipPen: "Rund",
    roundedTipPen2: "Polylinie",
    flatTipPen: "Flach",
    arrowPen: "Pfeil",
    linePen: "Linie",
    outlinedRectanglePen: "Umrandetes Rechteck",
    filledRectanglePen: "Ausgef\xFClltes Rechteck",
    outlinedCirclePen: "Umrandeter Kreis.",
    lockRotation: "Drehung sperren",
    paste: "Einf\xFCgen",
    errorImageHasZeroSize: "Fehler: Bild hat Gr\xF6\xDFe Null",
    describeTheImage: "Bildbeschreibung",
    fileInput__loading: "Lade...",
    fileInput__andNMoreFiles: (n) => `(...${n} mehr)`,
    penDropdown__baseHelpText: "Dieses Werkzeug zeichnet Formen oder Freihandlinien.",
    penDropdown__colorHelpText: "\xC4ndert die Farbe des Stifts",
    penDropdown__thicknessHelpText: "\xC4ndert die Strichst\xE4rke des mit dem Stift gezeichneten Strichs.",
    penDropdown__penTypeHelpText: "\xC4ndert den Stiftstil.\n\nEs kann entweder ein \u201EStiftstil\u201C oder eine \u201EForm\u201C ausgew\xE4hlt werden. Bei Auswahl eines \u201EStiftstils\u201C werden Freihandlinien gezeichnet. Bei Auswahl einer \u201EForm\u201C werden Formen gezeichnet.",
    penDropdown__autocorrectHelpText: "Wandelt grobe Freihandlinien und Rechtecke in perfekte Linien und Rechtecke um.\n\nDer Stift muss am Ende eines Strichs still gehalten werden, um eine Korrektur auszul\xF6sen.",
    penDropdown__stabilizationHelpText: "Zeichnet glattere Striche.\n\nDadurch entsteht auch eine kurze Verz\xF6gerung zwischen Maus/Stift und Strich.",
    penDropdown__pressureSensitivityHelpText: "\xC4ndert die Strichst\xE4rke entsprechend der Druckst\xE4rke, wenn du ein kompatibles Ger\xE4t wie einen Stylus verwendest.",
    handDropdown__baseHelpText: "Dieses Werkzeug ist f\xFCr das Scrollen, Drehen und Zoomen im Editor zust\xE4ndig.",
    handDropdown__zoomInHelpText: "Vergr\xF6\xDFert",
    handDropdown__zoomOutHelpText: "Verkleinert",
    handDropdown__resetViewHelpText: "Setzt den Zoomfaktor auf 100 % zur\xFCck und setzt den Bildlauf zur\xFCck.",
    handDropdown__zoomDisplayHelpText: "Zeigt den aktuellen Zoomfaktor an. 100 % zeigt das Bild in seiner tats\xE4chlichen Gr\xF6\xDFe an.",
    handDropdown__touchPanningHelpText: "Wenn aktiviert, verschieben Touchscreen-Gesten das Bild, anstatt es auszuw\xE4hlen oder zu zeichnen.",
    handDropdown__lockRotationHelpText: "Wenn aktiviert, verhindert diese Option, dass Touch-Gesten den Bildschirm drehen.",
    eraserDropdown__baseHelpText: "Dieses Werkzeug entfernt Striche, Bilder und Text unter dem Cursor.",
    eraserDropdown__thicknessHelpText: "\xC4ndert die Gr\xF6\xDFe des Radierers.",
    eraserDropdown__fullStrokeEraserHelpText: "Im vollst\xE4ndigen Modus werden ganze Formen gel\xF6scht.\n\nAu\xDFerhalb des vollst\xE4ndigen Modus k\xF6nnen Formen teilweise gel\xF6scht werden.",
    selectionDropdown__baseHelpText: "W\xE4hlt Inhalte aus und bearbeitet die Auswahl",
    selectionDropdown__resizeToHelpText: "Schneidet die Zeichnung auf die Gr\xF6\xDFe der aktuell ausgew\xE4hlten Fl\xE4che zu.\n\nWenn die automatische Gr\xF6\xDFenanpassung aktiviert ist, wird sie deaktiviert.",
    selectionDropdown__deleteHelpText: "L\xF6scht ausgew\xE4hlte Elemente.",
    selectionDropdown__duplicateHelpText: "Erstellt eine Kopie der ausgew\xE4hlten Elemente.",
    selectionDropdown__changeColorHelpText: "\xC4ndert die Farbe ausgew\xE4hlter Elemente.",
    pageDropdown__baseHelpText: "Steuert die Hintergrundfarbe, das Muster und die Gr\xF6\xDFe der Zeichenfl\xE4che.",
    pageDropdown__backgroundColorHelpText: "\xC4ndert die Hintergrundfarbe der Zeichenfl\xE4che.",
    pageDropdown__gridCheckboxHelpText: "Aktiviert/deaktiviert ein Hintergrundraster",
    pageDropdown__autoresizeCheckboxHelpText: "Wenn aktiviert, wird die Seite an die Zeichnung angepasst.\n\nWenn deaktiviert, ist die Seite sichtbar und ihre Gr\xF6\xDFe kann manuell festgelegt werden.",
    pageDropdown__aboutButtonHelpText: "Zeigt Version, Debugging und andere Informationen an.",
    colorPickerPipetteHelpText: "W\xE4hlt eine Farbe vom Bildschirm aus.",
    colorPickerToggleHelpText: "\xD6ffnet/schlie\xDFt den Farbw\xE4hler.",
    closeSidebar: (toolName) => `Sidebar f\xFCr ${toolName} schlie\xDFen`,
    dropdownShown: (toolName) => `Dropdown-Men\xFC f\xFCr ${toolName} angezeigt`,
    dropdownHidden: (toolName) => `Dropdown-Men\xFC f\xFCr ${toolName} versteckt`,
    zoomLevel: (zoomPercent) => `Verg\xF6\xDFerung: ${zoomPercent}%`,
    colorChangedAnnouncement: (color) => `Farbe zu ${color} ge\xE4ndert`,
    imageSize: (size, units) => `Bild-Gr\xF6\xDFe: ${size} ${units}`,
    imageLoadError: (message) => `Fehler beim Laden des Bildes: ${message}`,
    penTool: (penNumber) => `Stift ${penNumber}`,
    selectionTool: "Auswahl",
    selectAllTool: "Alle ausw\xE4hlen",
    eraserTool: "Radierer",
    touchPanTool: "Ansicht mit Touchscreen verschieben",
    twoFingerPanZoomTool: "Ansicht verschieben und vergr\xF6\xDFern",
    undoRedoTool: "R\xFCckg\xE4ngig/Wiederholen",
    rightClickDragPanTool: "Rechtsklick-Ziehen",
    pipetteTool: "Farbe von Bildschirm ausw\xE4hlen",
    keyboardPanZoom: "Tastaturk\xFCrzel zum Verschieben/Vergr\xF6\xDFern der Ansicht",
    selectionMenu__show: "Auswahlmen\xFC anzeigen",
    selectionMenu__copyToClipboard: "In Zwischenablage kopieren",
    selectionMenu__duplicate: "Duplizieren",
    selectionMenu__delete: "L\xF6schen",
    selectionMenu__paste: "Einf\xFCgen",
    copyPasteError__heading: "Kopieren/Einf\xFCgen",
    copyPasteError__description: "Ein Fehler ist aufgetreten \u2013 dieses Tool hat m\xF6glicherweise keinen Zugriff auf die Zwischenablage.",
    copyPasteError__errorDetails: "Fehler anzeigen",
    copyPasteError__pasteRetry: "Um es erneut zu versuchen, f\xFCge bitte den Text in das Eingabefeld unten ein:",
    copyPasteError__copyMe: "Kopiere mich!",
    autocorrectedTo: (strokeDescription) => `Automatisch korrigiert zu ${strokeDescription}`,
    autocorrectionCanceled: "Autokorrektur abgebrochen",
    enterTextToInsert: "Einzuf\xFCgender Text",
    changeTool: "Werkzeug wechseln",
    pasteHandler: "Kopieren-Einf\xFCgen-Handler",
    soundExplorer: "Klangbasierte Bilderkundung",
    disableAccessibilityExploreTool: "Klangbasierte Erkundung deaktivieren",
    enableAccessibilityExploreTool: "Klangbasierte Erkundung aktivieren",
    soundExplorerUsageAnnouncement: "Soundbasierte Bilduntersuchung aktiviert: Klicke/ziehe den Bildschirm, um eine akustische Darstellung verschiedener Bildbereiche abzuspielen.",
    findLabel: "Suchen",
    toNextMatch: "Weiter",
    closeDialog: "Schlie\xDFen",
    findDialogShown: "Suchen-Dialog angezeigt",
    findDialogHidden: "Suchen-Dialog versteckt",
    focusedFoundText: (matchIdx, totalMatches) => `Sieh Treffer ${matchIdx} von ${totalMatches} an`,
    anyDevicePanning: "Ansicht mit jedem Eingabeger\xE4t verschieben",
    copied: (count) => `Copied ${count} item(s)`,
    pasted: (count) => `Pasted ${count} item(s)`,
    toolEnabledAnnouncement: (toolName) => `${toolName} aktiviert`,
    toolDisabledAnnouncement: (toolName) => `${toolName} deaktiviert`,
    updatedViewport: "Transformierte Ansicht",
    transformedElements: (elemCount, action) => `${elemCount} Element${1 === elemCount ? "" : "e"} transformiert (${action})`,
    resizeOutputCommand: (newSize) => `Bildgr\xF6\xDFe auf ${newSize.w}x${newSize.h} ge\xE4ndert`,
    enabledAutoresizeOutputCommand: "Automatische Gr\xF6\xDFenanpassung der Ausgabe aktiviert",
    disabledAutoresizeOutputCommand: "Automatische Gr\xF6\xDFenanpassung der Ausgabe deaktiviert",
    addComponentAction: (componentDescription) => `${componentDescription} hinzugef\xFCgt`,
    eraseAction: (elemDescription, countErased) => `${countErased} ${elemDescription} gel\xF6scht`,
    duplicateAction: (elemDescription, countErased) => `${countErased} ${elemDescription} dupliziert`,
    unionOf: (actionDescription, actionCount) => `Vereinigung: ${actionCount} ${actionDescription}`,
    inverseOf: (actionDescription) => `${actionDescription} umgekehrt`,
    elements: "Elemente",
    erasedNoElements: "Nichts entfernt",
    duplicatedNoElements: "Nichts dupliziert",
    rotatedBy: (degrees) => `${Math.abs(degrees)} Grad ${degrees < 0 ? "im Uhrzeigersinn" : "gegen den Uhrzeigersinn"} gedreht`,
    movedLeft: "Nach links bewegt",
    movedUp: "Nach oben bewegt",
    movedDown: "Nach unten bewegt",
    movedRight: "Nach rechts bewegt",
    zoomedOut: "Ansicht verkleinert",
    zoomedIn: "Ansicht vergr\xF6\xDFert",
    andNMoreCommands: (count) => `Und noch ${count} weitere Befehle.`,
    selectedElements: (count) => `${count} Element${1 === count ? "" : "e"} ausgew\xE4hlt`,
    unlabeledImageNode: "Bild ohne Label",
    stroke: "Strich",
    svgObject: "SVG-Objekt",
    emptyBackground: "Leerer Hintergrund",
    gridBackground: "Hintergrundraster",
    filledBackgroundWithColor: (color) => `Gef\xFCllter Hintergrund (${color})`,
    text: (text) => `Text-Objekt: ${text}`,
    imageNode: (label) => `Bild: ${label}`,
    restyledElement: (elementDescription) => `${elementDescription} umgestaltet`,
    pathNodeCount: (count) => `Es gibt ${count} sichtbare Pfad-Objekte.`,
    textNodeCount: (count) => `Es gibt ${count} sichtbare Text-Knotenpunkte.`,
    imageNodeCount: (nodeCount) => `Es gibt ${nodeCount} sichtbare Bild-Knoten.`,
    textNode: (content) => `Text: ${content}`,
    rerenderAsText: "Als Text darstellen",
    accessibilityInputInstructions: "Dr\xFCcke \u201At\u2018, um den Inhalt des Ansichtsfensters als Text zu lesen. Verwende die Pfeiltasten, um die Ansicht zu verschieben, und klicke und ziehe, um Striche zu zeichnen. Dr\xFCcke \u201Aw\u2018 zum Vergr\xF6\xDFern und \u201As\u2018 zum Verkleinern der Ansicht.",
    loading: (percentage) => `${percentage}% geladen...`,
    imageEditor: "Bild-Editor",
    doneLoading: "Fertig geladen",
    undoAnnouncement: (commandDescription) => `${commandDescription} r\xFCckg\xE4ngig gemacht`,
    redoAnnouncement: (commandDescription) => `${commandDescription} wiederholt`,
    softwareLibraries: "Bibliotheken",
    developerInformation: "Enwicklerinformation"
  };
  var de_default = localization3;

  // node_modules/js-draw/dist/mjs/localizations/en.mjs
  var localization4 = {
    ...defaultEditorLocalization
  };
  var en_default = localization4;

  // node_modules/js-draw/dist/mjs/localizations/es.mjs
  var localization5 = {
    ...defaultEditorLocalization,
    pen: "Lapiz",
    eraser: "Borrador",
    select: "Selecciona",
    handTool: "Mover",
    image: "Imagen",
    inputAltText: "Texto alternativo",
    resetImage: "Reiniciar",
    chooseFile: "Seleccionar archivo",
    cancel: "Cancelar",
    resetView: "Reiniciar vista",
    thicknessLabel: "Tama\xF1o",
    fontLabel: "Fuente:",
    textSize: "Tama\xF1o",
    resizeImageToSelection: "Redimensionar la imagen a lo que est\xE1 seleccionado",
    deleteSelection: "Borra la selecci\xF3n",
    duplicateSelection: "Duplica la selecci\xF3n",
    exit: "Salir",
    save: "Guardar",
    undo: "Deshace",
    redo: "Rehace",
    selectPenType: "Punta",
    selectShape: "Forma",
    pickColorFromScreen: "Selecciona un color de la pantalla",
    clickToPickColorAnnouncement: "Haga un clic en la pantalla para seleccionar un color",
    documentProperties: "Fondo",
    backgroundColor: "Color de fondo",
    imageWidthOption: "Ancho",
    imageHeightOption: "Alto",
    enableAutoresizeOption: "Redimensionar autom\xE1tico",
    toggleOverflow: "M\xE1s",
    about: "Acerca de",
    touchPanning: "Mover la pantalla con un dedo",
    roundedTipPen: "Lapiz Redondeado",
    arrowPen: "Flecha",
    linePen: "L\xEDnea",
    outlinedRectanglePen: "Rect\xE1ngulo delineado",
    filledRectanglePen: "Rect\xE1ngulo sin borde",
    lockRotation: "Bloquea rotaci\xF3n",
    paste: "Pegar",
    selectionMenu__paste: "Pegar",
    selectionMenu__delete: "Eliminar",
    selectionMenu__duplicate: "Duplicar",
    closeSidebar: (toolName) => `Close sidebar for ${toolName}`,
    dropdownShown: (toolName) => `Men\xFA por ${toolName} es visible`,
    dropdownHidden: (toolName) => {
      return `Men\xFA por ${toolName} fue ocultado`;
    },
    zoomLevel: (zoomPercent) => `Zoom: ${zoomPercent}%`,
    colorChangedAnnouncement: (color) => {
      return `Color fue cambiado a ${color}`;
    },
    imageSize: (size, units) => `Tama\xF1o del imagen: ${size} ${units}`,
    imageLoadError: (message) => `Error cargando imagen: ${message}`,
    penTool: (penId) => `Lapiz ${penId}`,
    selectionTool: "Selecciona",
    eraserTool: "Borrador",
    touchPanTool: "Instrumento de mover la pantalla con un dedo",
    undoRedoTool: "Deshace/rehace",
    pipetteTool: "Seleccione un color de la pantalla",
    keyboardPanZoom: "Mover la pantalla con el teclado",
    textTool: "Texto",
    enterTextToInsert: "Entra texto",
    findLabel: "Buscar",
    toNextMatch: "Pr\xF3xima",
    closeDialog: "Cerrar",
    anyDevicePanning: "Mover la pantalla con todo dispotivo",
    copied: (count) => `${count} cosas fueron copiados`,
    pasted: (count) => count === 1 ? "Pegado" : `${count} cosas fueron pegados`,
    toolEnabledAnnouncement: (toolName) => `${toolName} fue activado`,
    toolDisabledAnnouncement: (toolName) => `${toolName} fue desactivado`,
    resizeOutputCommand: (newSize) => `Tama\xF1o de imagen fue cambiado a ${newSize.w}x${newSize.h}`,
    eraseAction: (componentDescription, numElems) => `Borrado: ${numElems} ${componentDescription}`,
    rerenderAsText: "Redibuja la pantalla al texto",
    loading: (percentage) => `Cargando: ${percentage}%...`,
    imageEditor: "Editor de dibujos",
    doneLoading: "El cargado termin\xF3",
    undoAnnouncement: (commandDescription) => `${commandDescription} fue deshecho`,
    redoAnnouncement: (commandDescription) => `${commandDescription} fue rehecho`
  };
  var es_default = localization5;

  // node_modules/js-draw/dist/mjs/localizations/sk.mjs
  var localization6 = {
    ...defaultEditorLocalization,
    help: "Pomoc",
    helpHidden: "Skryt\xE1 pomoc",
    next: "\u010Eal\u0161ie",
    previous: "Prech\xE1dzaj\xFAce",
    close: "Zavrie\u0165",
    helpScreenNavigationHelp: "Kliknut\xEDm na ovl\xE1dac\xED prvok z\xEDskate viac inform\xE1ci\xED.",
    helpControlsAccessibilityLabel: "Ovl\xE1dacie prvky: Aktivujte ovl\xE1dac\xED prvok, ktor\xFD zobraz\xED pomoc.",
    pen: "Pero",
    eraser: "Guma",
    select: "Vybra\u0165",
    handTool: "Posun",
    zoom: "Pribl\xED\u017Ei\u0165",
    image: "Obr\xE1zok",
    reformatSelection: "V\xFDber form\xE1tu",
    inputAltText: "Alternat\xEDvny text",
    decreaseImageSize: "Zmen\u0161i\u0165 ve\u013Ekos\u0165",
    resetImage: "Obnovi\u0165",
    chooseFile: "Vybra\u0165 s\xFAbor",
    dragAndDropHereOrBrowse: "Presu\u0148te sem alebo {{preh\u013Ead\xE1va\u0165}}",
    submit: "Odosla\u0165",
    addAll: "Prida\u0165 v\u0161etko",
    cancel: "Zru\u0161i\u0165",
    resetView: "Obnovi\u0165 zobrazenie",
    thicknessLabel: "Hr\xFAbka",
    colorLabel: "Farba",
    fontLabel: "P\xEDsmo",
    textSize: "Ve\u013Ekos\u0165",
    resizeImageToSelection: "Zmena ve\u013Ekosti obr\xE1zka pod\u013Ea v\xFDberu",
    deleteSelection: "Vymaza\u0165 v\xFDber",
    duplicateSelection: "Duplikova\u0165 v\xFDber",
    exit: "Ukon\u010Di\u0165",
    save: "Ulo\u017Ei\u0165",
    undo: "Sp\xE4\u0165",
    redo: "Opakova\u0165",
    fullStrokeEraser: "Guma s pln\xFDm \u0165ahom",
    selectPenType: "Typ pera",
    selectShape: "Tvar",
    pickColorFromScreen: "Vybra\u0165 farbu z obrazovky",
    clickToPickColorAnnouncement: "Kliknut\xEDm na obrazovku vyberte farbu",
    colorSelectionCanceledAnnouncement: "V\xFDber farby zru\u0161en\xFD",
    selectionTool__lassoSelect: "V\xFDber vo\u013En\xE9ho tvaru",
    selectionTool__lassoSelect__help: "Ak je t\xE1to funkcia zapnut\xE1, \u0165ahanie vytvor\xED vo\u013En\xFD tvar (laso) v\xFDberu.",
    selectionToolKeyboardShortcuts: "N\xE1stroj na v\xFDber: Pomocou kl\xE1vesov so \u0161\xEDpkami m\xF4\u017Eete presun\xFA\u0165 vybran\xE9 polo\u017Eky, mal\xFDmi/ve\u013Ek\xFDmi p\xEDsmenami \u201Ei\u201C a \u201Eo\u201C m\xF4\u017Eete zmeni\u0165 ve\u013Ekos\u0165.",
    documentProperties: "Strana",
    backgroundColor: "Farba pozadia",
    imageWidthOption: "\u0160\xEDrka",
    imageHeightOption: "V\xFD\u0161ka",
    useGridOption: "Mrie\u017Eka",
    enableAutoresizeOption: "Automatick\xE1 zmena ve\u013Ekosti",
    toggleOverflow: "Viac",
    about: "O aplik\xE1cii",
    inputStabilization: "Stabiliz\xE1cia",
    strokeAutocorrect: "Automatick\xE1 oprava",
    pressureSensitivity: "Tlak",
    touchPanning: "Pos\xFAvanie dotykom",
    roundedTipPen: "Okr\xFAhle",
    roundedTipPen2: "Viac\u010Diarov\xE9",
    flatTipPen: "Ploch\xE9",
    arrowPen: "\u0160\xEDpka",
    linePen: "\u010Ciara",
    outlinedRectanglePen: "Obrys obd\u013A\u017Enika",
    filledRectanglePen: "Pln\xFD obd\u013A\u017Enik",
    outlinedCirclePen: "Kru\u017Enica",
    lockRotation: "Zamkn\xFA\u0165 ot\xE1\u010Danie",
    paste: "Vlo\u017Ei\u0165",
    errorImageHasZeroSize: "Chyba: Obr\xE1zok m\xE1 nulov\xFA ve\u013Ekos\u0165",
    describeTheImage: "Popis obr\xE1zku",
    fileInput__loading: "Na\u010D\xEDtavanie...",
    fileInput__andNMoreFiles: (n) => `(...${n} \u010Fal\u0161\xEDch)`,
    penDropdown__baseHelpText: "Tento n\xE1stroj kresl\xED tvary alebo vo\u013En\xE9 \u010Diary.",
    penDropdown__colorHelpText: "Zmen\xED farbu pera",
    penDropdown__thicknessHelpText: "Men\xED hr\xFAbku \u0165ahov nakreslen\xFDch perom.",
    penDropdown__penTypeHelpText: "Zmen\xED \u0161t\xFDl pera.\n\nM\xF4\u017Eete si vybra\u0165 bu\u010F \u0161t\xFDl \u201Epero\u201C, alebo \u201Etvar\u201C. V\xFDberom \u0161t\xFDlu \u201Epero\u201C sa kreslia vo\u013En\xE9 \u010Diary. V\xFDberom \u0161t\xFDlu \u201Etvar\u201C sa kreslia tvary.",
    penDropdown__autocorrectHelpText: "Prevedie pribli\u017En\xE9 vo\u013En\xE9 \u010Diary a obd\u013A\u017Eniky na dokonal\xE9.\n\nPero mus\xED by\u0165 dr\u017Ean\xE9 nehybne na konci \u0165ahu, aby sa spustila oprava.",
    penDropdown__stabilizationHelpText: "Kresl\xED hlad\u0161ie \u0165ahy.\n\nPrid\xE1va tie\u017E kr\xE1tke oneskorenie medzi pohybom my\u0161i/stylusu a \u0165ahom.",
    penDropdown__pressureSensitivityHelpText: "Pri pou\u017Eit\xED kompatibiln\xE9ho zariadenia, napr\xEDklad stylusu, men\xED hr\xFAbku \u0165ahov pod\u013Ea sily stla\u010Denia.",
    handDropdown__baseHelpText: "Tento n\xE1stroj je zodpovedn\xFD za pos\xFAvanie, ot\xE1\u010Danie a zv\xE4\u010D\u0161ovanie editora.",
    handDropdown__zoomInHelpText: "Pribl\xED\u017Ei\u0165.",
    handDropdown__zoomOutHelpText: "Oddiali\u0165.",
    handDropdown__resetViewHelpText: "Obnov\xED \xFArove\u0148 pribl\xED\u017Eenia na 100 % a vynuluje pos\xFAvanie.",
    handDropdown__zoomDisplayHelpText: "Zobraz\xED aktu\xE1lnu \xFArove\u0148 pribl\xED\u017Eenia. 100 % zobrazuje obr\xE1zok v jeho skuto\u010Dnej ve\u013Ekosti.",
    handDropdown__touchPanningHelpText: "Ke\u010F je t\xE1to funkcia zapnut\xE1, gest\xE1 dotykovej obrazovky pos\xFAvaj\xFA obr\xE1zok, a nevyberaj\xFA ho ani nekreslia.",
    handDropdown__lockRotationHelpText: "Ak je t\xE1to funkcia zapnut\xE1, zabra\u0148uje dotykov\xFDm gest\xE1m ot\xE1\u010Da\u0165 obrazovku.",
    eraserDropdown__baseHelpText: "Tento n\xE1stroj odstra\u0148uje \u0165ahy, obr\xE1zky a text pod kurzorom.",
    eraserDropdown__thicknessHelpText: "Zmen\xED ve\u013Ekos\u0165 gumy.",
    eraserDropdown__fullStrokeEraserHelpText: "`V re\u017Eime pln\xE9ho \u0165ahu sa vyma\u017E\xFA cel\xE9 tvary.\n\nKe\u010F nie je v re\u017Eime pln\xE9ho \u0165ahu, tvary sa m\xF4\u017Eu by\u0165 \u010Diasto\u010Dne vymazan\xE9.`",
    selectionDropdown__baseHelpText: "Vyber\xE1 obsah a manipuluje s v\xFDberom",
    selectionDropdown__resizeToHelpText: "Ore\u017Ee kresbu na ve\u013Ekos\u0165 toho, \u010Do je aktu\xE1lne vybran\xE9.\n\nAk je zapnut\xE1 automatick\xE1 zmena ve\u013Ekosti, bude t\xE1to funkcia vypnut\xE1.",
    selectionDropdown__deleteHelpText: "Vyma\u017Ee vybran\xE9 polo\u017Eky.",
    selectionDropdown__duplicateHelpText: "Vytvor\xED k\xF3piu vybran\xFDch polo\u017Eiek.",
    selectionDropdown__changeColorHelpText: "Zmen\xED farbu vybran\xFDch polo\u017Eiek.",
    pageDropdown__baseHelpText: "Ovl\xE1da farbu, vzor a ve\u013Ekos\u0165 pozadia kresliaceho pl\xE1tna.",
    pageDropdown__backgroundColorHelpText: "Zmen\xED farbu pozadia kresliaceho pl\xE1tna.",
    pageDropdown__gridCheckboxHelpText: "Zapne/vypne vzor mrie\u017Eky na pozad\xED.",
    pageDropdown__autoresizeCheckboxHelpText: "Pokia\u013E je ozna\u010Den\xE9, str\xE1nka sa zv\xE4\u010D\u0161\xED tak, aby sa prisp\xF4sobila kresbe.\n\nKe\u010F nie je ozna\u010Den\xE9, str\xE1nka je vidite\u013En\xE1 a jej ve\u013Ekos\u0165 sa d\xE1 nastavi\u0165 ru\u010Dne.",
    pageDropdown__aboutButtonHelpText: "Zobraz\xED verziu, ladenie a \u010Fal\u0161ie inform\xE1cie.",
    colorPickerPipetteHelpText: "Vyberie farbu z obrazovky.",
    colorPickerToggleHelpText: "Otvor\xED/zatvor\xED v\xFDber farieb.",
    closeSidebar: (toolName) => `Zatvori\u0165 bo\u010Dn\xFD panel pre ${toolName}`,
    dropdownShown: (toolName) => `Ponuka pre ${toolName} zobrazen\xE1`,
    dropdownHidden: (toolName) => `Ponuka pre ${toolName} skryt\xE1`,
    zoomLevel: (zoomPercent) => `Pribl\xED\u017Eenie: ${zoomPercent}%`,
    colorChangedAnnouncement: (color) => `Farba zmenen\xE1 na ${color}`,
    imageSize: (size, units) => `Ve\u013Ekos\u0165 obr\xE1zka: ${size} ${units}`,
    imageLoadError: (message) => `Chyba pri na\u010D\xEDtavan\xED obr\xE1zka: ${message}`,
    penTool: (penId) => `Pero ${penId}`,
    selectionTool: "V\xFDber",
    selectAllTool: "Skratka pre v\xFDber v\u0161etk\xFDch",
    eraserTool: "Guma",
    touchPanTool: "Pos\xFAvanie dotykom",
    twoFingerPanZoomTool: "Posun a pribl\xED\u017Eenie",
    undoRedoTool: "Sp\xE4\u0165/Opakova\u0165",
    rightClickDragPanTool: "\u0164ahanie prav\xFDm tla\u010Didlom my\u0161i",
    pipetteTool: "Vybra\u0165 farbu z obrazovky",
    keyboardPanZoom: "Kl\xE1vesov\xE9 skratky pre pos\xFAvanie/pribl\xED\u017Eenie",
    selectionMenu__show: "Zobrazi\u0165 ponuku v\xFDberu",
    selectionMenu__copyToClipboard: "Kop\xEDrova\u0165 do schr\xE1nky",
    selectionMenu__duplicate: "Duplikova\u0165",
    selectionMenu__delete: "Vymaza\u0165",
    selectionMenu__paste: "Vlo\u017Ei\u0165",
    copyPasteError__heading: "Kop\xEDrova\u0165/vlo\u017Ei\u0165",
    copyPasteError__description: "Nie\u010Do sa pokazilo - tento n\xE1stroj nemus\xED ma\u0165 pr\xEDstup k schr\xE1nke.",
    copyPasteError__errorDetails: "Zobrazi\u0165 chybu",
    copyPasteError__pasteRetry: "Ak chcete opakova\u0165 pokus, vlo\u017Ete ho do ni\u017E\u0161ie uveden\xE9ho vstupn\xE9ho po\u013Ea:",
    copyPasteError__copyRetry: "Ak chcete opakova\u0165 pokus, skop\xEDrujte text do vstupn\xE9ho po\u013Ea ni\u017E\u0161ie:",
    copyPasteError__copyMe: "Skop\xEDruj ma!",
    autocorrectedTo: (strokeDescription) => `Automaticky opraven\xE9 na ${strokeDescription}`,
    autocorrectionCanceled: "Automatick\xE1 oprava zru\u0161en\xE1",
    enterTextToInsert: "Text, ktor\xFD sa m\xE1 vlo\u017Ei\u0165",
    changeTool: "Zmeni\u0165 n\xE1stroj",
    findLabel: "H\u013Eada\u0165",
    toNextMatch: "\u010Eal\u0161ie",
    closeDialog: "Zavrie\u0165",
    findDialogShown: "Dial\xF3gov\xE9 okno vyh\u013Ead\xE1vania zobrazen\xE9",
    findDialogHidden: "Dial\xF3gov\xE9 okno vyh\u013Ead\xE1vania je skryt\xE9",
    copied: (count) => `Skop\xEDrovan\xFDch ${count} polo\u017Eiek`,
    pasted: (count) => `Vlo\u017Een\xFDch ${count} polo\u017Eiek`,
    toolEnabledAnnouncement: (toolName) => `${toolName} zapnut\xE9`,
    toolDisabledAnnouncement: (toolName) => `${toolName} vypnut\xE9`,
    resizeOutputCommand: (newSize) => `Zmenen\xE1 ve\u013Ekos\u0165 obr\xE1zka na ${newSize.w}x${newSize.h}`,
    enabledAutoresizeOutputCommand: "Automatick\xE1 zmena ve\u013Ekosti v\xFDstupu je povolen\xE1",
    disabledAutoresizeOutputCommand: "Automatick\xE1 zmena ve\u013Ekosti v\xFDstupu je zak\xE1zan\xE1",
    addComponentAction: (componentDescription) => `Pridan\xE9 ${componentDescription}`,
    eraseAction: (componentDescription, numElems) => `Vymazan\xE9 ${numElems} ${componentDescription}`,
    duplicateAction: (componentDescription, numElems) => `Duplikovan\xE9 ${numElems} ${componentDescription}`,
    elements: "Prvky",
    erasedNoElements: "Ni\u010D sa nevymazalo.",
    duplicatedNoElements: "Ni\u010D sa neduplikovalo.",
    rotatedBy: (degrees) => `Oto\u010Den\xE9 o ${Math.abs(degrees)} stup\u0148ov ${degrees < 0 ? "clockwise" : "counter-clockwise"}`,
    movedLeft: "Presunut\xE9 do\u013Eava",
    movedUp: "Presunut\xE9 hore",
    movedDown: "Presunut\xE9 dole",
    movedRight: "Presunut\xE9 doprava",
    zoomedOut: "Oddialen\xE9",
    zoomedIn: "Pribl\xED\u017Een\xE9",
    andNMoreCommands: (count) => `A ${count} \u010Fal\u0161\xEDch pr\xEDkazov.`,
    unlabeledImageNode: "Obr\xE1zok bez ozna\u010Denia",
    stroke: "\u0164ah",
    svgObject: "Objekt SVG",
    emptyBackground: "Pr\xE1zdne pozadie",
    gridBackground: "Pozadie s mrie\u017Ekou",
    filledBackgroundWithColor: (color) => `Vyplnen\xE9 pozadie (${color})`,
    text: (text) => `Textov\xFD objekt: ${text}`,
    imageNode: (label) => `Obr\xE1zok: ${label}`,
    pathNodeCount: (count) => `Vidite\u013En\xFDch je ${count} objektov ciest.`,
    textNodeCount: (count) => `Vidite\u013En\xFDch je ${count} textov\xFDch uzlov.`,
    imageNodeCount: (nodeCount) => `Vidite\u013En\xFDch je ${nodeCount} obrazov\xFDch uzlov.`,
    rerenderAsText: "Op\xE4tovne vykresli\u0165 ako text.",
    accessibilityInputInstructions: "Pomocou tla\u010Didla \u201Et\u201C pre\u010D\xEDtate obsah zobrazovacieho okna ako text. Pomocou kl\xE1vesov so \u0161\xEDpkami pohybujte zobrazovac\xEDm oknom, kliknut\xEDm a \u0165ahan\xEDm kreslite \u0165ahy. Stla\u010Den\xEDm tla\u010Didla \u201Ew\u201C pribl\xED\u017Eite a stla\u010Den\xEDm tla\u010Didla \u201Es\u201C oddialite poh\u013Ead.",
    loading: (percentage) => `Na\u010D\xEDtava sa ${percentage}%...`,
    imageEditor: "Editor obr\xE1zkov",
    doneLoading: "Na\u010D\xEDtanie dokon\u010Den\xE9",
    softwareLibraries: "Kni\u017Enice",
    developerInformation: "Inform\xE1cie pre v\xFDvoj\xE1rov"
  };
  var sk_default = localization6;

  // node_modules/js-draw/dist/mjs/localizations/getLocalizationTable.mjs
  var allLocales = {
    de: de_default,
    en: en_default,
    es: es_default,
    sk: sk_default,
    zh: zh_default
  };
  var languageFromLocale = (locale) => {
    const matches = /^(\w+)[_-](\w+)$/.exec(locale);
    if (!matches) {
      return locale;
    }
    return matches[1];
  };
  var matchingLocalizationTable = (userLocales, localizationTables, defaultLocalizationTable) => {
    let prevLanguage;
    for (const locale of userLocales) {
      const language = languageFromLocale(locale);
      if (prevLanguage && language !== prevLanguage) {
        if (prevLanguage in localizationTables) {
          return localizationTables[prevLanguage];
        }
      }
      if (locale in localizationTables) {
        return localizationTables[locale];
      }
      prevLanguage = language;
    }
    if (prevLanguage && prevLanguage in localizationTables) {
      return localizationTables[prevLanguage];
    } else {
      return defaultLocalizationTable;
    }
  };
  var getLocalizationTable = (userLocales) => {
    userLocales ??= navigator.languages;
    return matchingLocalizationTable(userLocales, allLocales, defaultEditorLocalization);
  };
  var getLocalizationTable_default = getLocalizationTable;

  // node_modules/js-draw/dist/mjs/shortcuts/KeyBinding.mjs
  var isUppercaseLetter = (text) => {
    return text.toUpperCase() === text && text.toLowerCase() !== text && text.length === 1;
  };
  var isLowercaseLetter = (text) => {
    return text.toLowerCase() === text && text.toUpperCase() !== text && text.length === 1;
  };
  var KeyBinding = class _KeyBinding {
    constructor(trigger) {
      this.key = trigger.key;
      this.shiftKey = trigger.shiftKey;
      this.ctrlKey = trigger.ctrlKey;
      this.altKey = trigger.altKey;
      this.metaKey = trigger.metaKey;
      this.controlOrMeta = trigger.controlOrMeta;
    }
    /** Returns true if and only if `keyEvent` should trigger this shortcut. */
    matchesEvent(keyEvent) {
      const lowercaseKey = keyEvent.key?.toLowerCase();
      const isUpperCaseKey = isUppercaseLetter(keyEvent.key ?? "");
      const isLowercaseKey = isLowercaseLetter(keyEvent.key ?? "");
      const ctrlKey = (keyEvent.ctrlKey ?? false) || lowercaseKey === "control";
      const altKey = (keyEvent.altKey ?? false) || lowercaseKey === "alt";
      const metaKey = (keyEvent.metaKey ?? false) || lowercaseKey === "meta";
      const shiftKey = (keyEvent.shiftKey ?? isUpperCaseKey) || lowercaseKey === "shift";
      const keyEventHasCtrlOrMeta = keyEvent.controlOrMeta || keyEvent.ctrlKey || keyEvent.metaKey || false;
      if (this.key !== keyEvent.code) {
        if (this.key.toLowerCase() !== lowercaseKey) {
          return false;
        }
        if ((isUpperCaseKey || isLowercaseKey) && this.key !== keyEvent.key) {
          const uppercaseKeyMatches = this.shiftKey === true && this.key.toUpperCase() === keyEvent.key;
          if (!uppercaseKeyMatches) {
            return false;
          }
        }
      }
      const shortcutControlOrMeta = this.controlOrMeta;
      const ctrlAndMetaMatches = ctrlKey === this.ctrlKey && metaKey === this.metaKey && !shortcutControlOrMeta;
      const matches = (ctrlAndMetaMatches || shortcutControlOrMeta && keyEventHasCtrlOrMeta) && altKey === this.altKey && (shiftKey === this.shiftKey || this.shiftKey === void 0);
      return matches;
    }
    /**
     * Returns a string representation of this shortcut in the same format accepted by
     * {@link fromString}.
     */
    toString() {
      const result = [];
      if (this.ctrlKey && this.key !== "control") {
        result.push("Ctrl");
      }
      if (this.controlOrMeta) {
        result.push("CtrlOrMeta");
      }
      if (this.altKey && this.key !== "alt") {
        result.push("Alt");
      }
      if (this.metaKey && this.key !== "meta") {
        result.push("Meta");
      }
      if (this.shiftKey && this.key !== "shift") {
        result.push("Shift");
      }
      result.push(this.key);
      return result.join("+");
    }
    /**
     * Accepts a string in the form `modifier1+modifier2+...+key` (e.g. `Ctrl+Shift+a`)
     * and returns the corresponding `KeyboardShortcut`.
     */
    static fromString(shortcutStr) {
      const getDefaultModifiers = (key2) => {
        let shiftKey2 = void 0;
        if (isUppercaseLetter(key2)) {
          shiftKey2 = true;
        } else if (isLowercaseLetter(key2)) {
          shiftKey2 = false;
        } else if (key2.length > 1) {
          shiftKey2 = false;
        }
        const lowercaseKey = key2.toLowerCase();
        if (lowercaseKey === "shift") {
          shiftKey2 = true;
        }
        return {
          shiftKey: shiftKey2,
          ctrlKey: lowercaseKey === "control" || lowercaseKey === "ctrl",
          altKey: lowercaseKey === "alt",
          metaKey: lowercaseKey === "meta",
          controlOrMeta: lowercaseKey === "control or meta" || lowercaseKey === "ctrlormeta"
        };
      };
      const hasNoModifiers = shortcutStr.search(/[-+]/) === -1 || shortcutStr.length === 1;
      if (hasNoModifiers) {
        const modifiers = getDefaultModifiers(shortcutStr);
        return new _KeyBinding({
          key: shortcutStr,
          ...modifiers
        });
      }
      const keyModifiersExp = /^(.*[-+])?(.+)$/g;
      const match = keyModifiersExp.exec(shortcutStr);
      if (!match) {
        throw new Error(`Invalid shortcut expression, ${shortcutStr}!`);
      }
      const key = match[2];
      const defaultModifiers = getDefaultModifiers(key);
      const modifierStrings = (match[1] ?? "").split(/[-+]/);
      let shiftKey = defaultModifiers.shiftKey;
      let ctrlKey = defaultModifiers.ctrlKey;
      let altKey = defaultModifiers.altKey;
      let metaKey = defaultModifiers.metaKey;
      let controlOrMeta = defaultModifiers.controlOrMeta;
      for (const modifier of modifierStrings) {
        if (modifier === "") {
          continue;
        }
        switch (modifier.toLowerCase()) {
          case "shift":
            shiftKey = true;
            break;
          case "anyshift":
            shiftKey = void 0;
            break;
          case "ctrl":
          case "control":
            ctrlKey = true;
            break;
          case "meta":
            metaKey = true;
            break;
          case "ctrlormeta":
          case "ctrl or meta":
          case "controlormeta":
            controlOrMeta = true;
            break;
          case "alt":
            altKey = true;
            break;
          default:
            throw new Error(`Unknown modifier: "${modifier}" in shortcut ${shortcutStr}.`);
        }
      }
      const shortcut = new _KeyBinding({
        key,
        shiftKey,
        ctrlKey,
        altKey,
        metaKey,
        controlOrMeta
      });
      return shortcut;
    }
  };

  // node_modules/js-draw/dist/mjs/shortcuts/KeyboardShortcutManager.mjs
  var KeyboardShortcutManager = class _KeyboardShortcutManager {
    /**
     * Creates a new `ShortcutManager` with an initial set of shortcut overrides.
     *
     * @internal
     */
    constructor(initialOverrides) {
      this.shortcutOverrides = /* @__PURE__ */ Object.create(null);
      for (const id in initialOverrides) {
        this.overrideShortcut(id, initialOverrides[id]);
      }
    }
    /**
     * Override an existing shortcut with a custom set of triggers.
     * @internal
     */
    overrideShortcut(shortcutId, overrideWith) {
      this.shortcutOverrides[shortcutId] = [...overrideWith];
    }
    /** Returns true if `keyEvent` matches the shortcut with `shortcutId`. @internal */
    matchesShortcut(shortcutId, keyEvent) {
      let shortcutList = this.shortcutOverrides[shortcutId];
      if (!shortcutList) {
        if (shortcutId in _KeyboardShortcutManager.shortcuts) {
          shortcutList = _KeyboardShortcutManager.shortcuts[shortcutId];
        } else {
          throw new Error(`No shortcut with ID ${shortcutId} exists!`);
        }
      }
      for (const shortcut of shortcutList) {
        if (shortcut.matchesEvent(keyEvent)) {
          return true;
        }
      }
      return false;
    }
    /**
     * Registers a default keyboard shortcut that can be overridden by individual instances
     * of `ShortcutManager`. Note that `id` should be a globally unique identifier.
     *
     * Only the first call to this method for a given `id` has an effect.
     *
     * @example
     * ```ts
     * const shortcutId = 'io.github.personalizedrefrigerator.js-draw.select-all';
     *
     * // Associate two shortcuts with the same ID
     * const shortcut1 = KeyBinding.fromString('ctrlOrMeta+a');
     * const shortcut2 = KeyBinding.fromString('ctrlOrMeta+shift+a');
     * KeyboardShortcutManager.registerDefaultKeyboardShortcut(
     * 	shortcutId,
     * 	[ shortcut1, shortcut2 ],
     * 	"Select All",
     * );
     *
     * // Provide a localized description
     * KeyboardShortcutManager.provideShortcutDescription(
     * 	shotcutId,
     * 	'es',
     * 	'Seleccionar todo',
     * );
     * ```
     *
     * @internal
     */
    static registerDefaultKeyboardShortcut(id, shortcuts, defaultDescription) {
      if (id in _KeyboardShortcutManager.shortcuts) {
        return false;
      }
      const shortcutsAsShortcuts = shortcuts.map((shortcut) => {
        if (typeof shortcut === "string") {
          return KeyBinding.fromString(shortcut);
        }
        return shortcut;
      });
      _KeyboardShortcutManager.shortcuts[id] = [...shortcutsAsShortcuts];
      _KeyboardShortcutManager.shortcutDefaultDescriptions[id] = defaultDescription;
      return true;
    }
    /** Provides a localized description of a keyboard shortcut. @internal */
    static provideShortcutDescription(id, locale, description) {
      if (!(locale in _KeyboardShortcutManager.shortcutLocalizedDescriptions)) {
        _KeyboardShortcutManager.shortcutLocalizedDescriptions[locale] = /* @__PURE__ */ Object.create(null);
      }
      _KeyboardShortcutManager.shortcutLocalizedDescriptions[locale][id] = description;
    }
    /**
     * Gets all registered keyboard shortcut IDs.
     *
     * @see {@link getShortcutDescription}
     */
    static getAllShortcutIds() {
      const ids = [];
      for (const id in this.shortcuts) {
        ids.push(id);
      }
      return ids;
    }
    /**
     * Get the default keybindings associated with a keyboard shortcut.
     *
     * Any keybinding in the resultant list, by default, can trigger the function associated
     * with the shortcut.
     */
    static getShortcutDefaultKeybindings(shortcutId) {
      if (!(shortcutId in _KeyboardShortcutManager.shortcuts)) {
        throw new Error(`No shortcut with ID ${shortcutId} exists!`);
      }
      return _KeyboardShortcutManager.shortcuts[shortcutId];
    }
    /**
     * Get a description of a keyboard shortcut.
     *
     * `localeList`, if given, attempts to
     */
    static getShortcutDescription(id, localeList) {
      const localizationTable = matchingLocalizationTable(localeList ?? [], this.shortcutLocalizedDescriptions, this.shortcutDefaultDescriptions);
      return localizationTable[id] ?? this.shortcutDefaultDescriptions[id] ?? null;
    }
  };
  KeyboardShortcutManager.shortcuts = /* @__PURE__ */ Object.create(null);
  KeyboardShortcutManager.shortcutDefaultDescriptions = /* @__PURE__ */ Object.create(null);
  KeyboardShortcutManager.shortcutLocalizedDescriptions = /* @__PURE__ */ Object.create(null);
  var KeyboardShortcutManager_default = KeyboardShortcutManager;

  // node_modules/js-draw/dist/mjs/tools/SelectionTool/keybindings.mjs
  var selectAllKeyboardShortcut = "jsdraw.tools.SelectionTool.selectAll";
  KeyboardShortcutManager_default.registerDefaultKeyboardShortcut(selectAllKeyboardShortcut, ["CtrlOrMeta+KeyA"], "Select all");
  var duplicateSelectionShortcut = "jsdraw.tools.SelectionTool.duplicateSelection";
  KeyboardShortcutManager_default.registerDefaultKeyboardShortcut(duplicateSelectionShortcut, ["CtrlOrMeta+KeyD"], "Duplicate selection");
  var sendToBackSelectionShortcut = "jsdraw.tools.SelectionTool.sendToBack";
  KeyboardShortcutManager_default.registerDefaultKeyboardShortcut(sendToBackSelectionShortcut, ["End"], "Send to back");
  var translateLeftSelectionShortcutId = "jsdraw.tools.SelectionTool.translateLeft";
  KeyboardShortcutManager_default.registerDefaultKeyboardShortcut(translateLeftSelectionShortcutId, ["KeyA", "KeyH", "ArrowLeft"], "Move selection left");
  var translateRightSelectionShortcutId = "jsdraw.tools.SelectionTool.translateRight";
  KeyboardShortcutManager_default.registerDefaultKeyboardShortcut(translateRightSelectionShortcutId, ["KeyD", "KeyL", "ArrowRight"], "Move selection right");
  var translateUpSelectionShortcutId = "jsdraw.tools.SelectionTool.translateUp";
  KeyboardShortcutManager_default.registerDefaultKeyboardShortcut(translateUpSelectionShortcutId, ["KeyQ", "KeyK", "ArrowUp"], "Move selection up");
  var translateDownSelectionShortcutId = "jsdraw.tools.SelectionTool.translateDown";
  KeyboardShortcutManager_default.registerDefaultKeyboardShortcut(translateDownSelectionShortcutId, ["KeyE", "KeyJ", "ArrowDown"], "Move selection down");
  var rotateCounterClockwiseSelectionShortcutId = "jsdraw.tools.SelectionTool.rotateCCW";
  KeyboardShortcutManager_default.registerDefaultKeyboardShortcut(rotateCounterClockwiseSelectionShortcutId, ["Shift+KeyR"], "Rotate selection counter clockwise");
  var rotateClockwiseSelectionShortcutId = "jsdraw.tools.SelectionTool.rotateCW";
  KeyboardShortcutManager_default.registerDefaultKeyboardShortcut(rotateClockwiseSelectionShortcutId, ["KeyR"], "Rotate selection clockwise");
  var shrinkXSelectionShortcutId = "jsdraw.tools.SelectionTool.shrink.x";
  KeyboardShortcutManager_default.registerDefaultKeyboardShortcut(shrinkXSelectionShortcutId, ["KeyI"], "Decrease width");
  var stretchXSelectionShortcutId = "jsdraw.tools.SelectionTool.stretch.x";
  KeyboardShortcutManager_default.registerDefaultKeyboardShortcut(stretchXSelectionShortcutId, ["Shift+KeyI"], "Increase width");
  var shrinkYSelectionShortcutId = "jsdraw.tools.SelectionTool.shrink.y";
  KeyboardShortcutManager_default.registerDefaultKeyboardShortcut(shrinkYSelectionShortcutId, ["KeyO"], "Decrease height");
  var stretchYSelectionShortcutId = "jsdraw.tools.SelectionTool.stretch.y";
  KeyboardShortcutManager_default.registerDefaultKeyboardShortcut(stretchYSelectionShortcutId, ["Shift+KeyO"], "Increase height");
  var shrinkXYSelectionShortcutId = "jsdraw.tools.SelectionTool.shrink.xy";
  KeyboardShortcutManager_default.registerDefaultKeyboardShortcut(shrinkXYSelectionShortcutId, ["Comma"], "Decrease selection size");
  var stretchXYSelectionShortcutId = "jsdraw.tools.SelectionTool.stretch.xy";
  KeyboardShortcutManager_default.registerDefaultKeyboardShortcut(stretchXYSelectionShortcutId, ["Period"], "Increase selection size");

  // node_modules/js-draw/dist/mjs/tools/keybindings.mjs
  var undoKeyboardShortcutId = "jsdraw.tools.undo";
  var redoKeyboardShortcutId = "jsdaw.tools.redo";
  KeyboardShortcutManager_default.registerDefaultKeyboardShortcut(undoKeyboardShortcutId, ["CtrlOrMeta+KeyZ"], "Undo");
  KeyboardShortcutManager_default.registerDefaultKeyboardShortcut(redoKeyboardShortcutId, ["CtrlOrMeta+Shift+KeyZ", "CtrlOrMeta+KeyY"], "Redo");
  var increaseSizeKeyboardShortcutId = "jsdraw.tools.increaseSize";
  KeyboardShortcutManager_default.registerDefaultKeyboardShortcut(increaseSizeKeyboardShortcutId, ["Equal", "Shift+Equal"], "Increase pen/eraser size");
  var decreaseSizeKeyboardShortcutId = "jsdraw.tools.decreaseSize";
  KeyboardShortcutManager_default.registerDefaultKeyboardShortcut(decreaseSizeKeyboardShortcutId, ["Minus", "Shift+Minus"], "Decrease pen/eraser size");
  var snapToGridKeyboardShortcutId = "jsdraw.tools.snapToGrid";
  KeyboardShortcutManager_default.registerDefaultKeyboardShortcut(snapToGridKeyboardShortcutId, ["Control", "Meta"], "Snap to grid (press and hold)");
  var lineLockKeyboardShortcutId = "jsdraw.tools.lockToLine";
  KeyboardShortcutManager_default.registerDefaultKeyboardShortcut(lineLockKeyboardShortcutId, ["Shift"], "Snap to XY axes (press and hold)");
  var toggleFindVisibleShortcutId = "js-draw.tools.FindTool.toggleVisible";
  KeyboardShortcutManager_default.registerDefaultKeyboardShortcut(toggleFindVisibleShortcutId, ["CtrlOrMeta+KeyF"], "Shows/hides the find tool");
  var moveLeftKeyboardShortcutId = "jsdraw.tools.PanZoom.moveLeft";
  KeyboardShortcutManager_default.registerDefaultKeyboardShortcut(moveLeftKeyboardShortcutId, ["ArrowLeft", "KeyH", "KeyA"], "Pan left");
  var moveRightKeyboardShortcutId = "jsdraw.tools.PanZoom.moveRight";
  KeyboardShortcutManager_default.registerDefaultKeyboardShortcut(moveRightKeyboardShortcutId, ["ArrowRight", "KeyL", "KeyD"], "Pan right");
  var moveUpKeyboardShortcutId = "jsdraw.tools.PanZoom.moveUp";
  KeyboardShortcutManager_default.registerDefaultKeyboardShortcut(moveUpKeyboardShortcutId, ["ArrowUp", "KeyK", "KeyQ"], "Pan up");
  var moveDownKeyboardShortcutId = "jsdraw.tools.PanZoom.moveDown";
  KeyboardShortcutManager_default.registerDefaultKeyboardShortcut(moveDownKeyboardShortcutId, ["ArrowDown", "KeyJ", "KeyE"], "Pan down");
  var rotateClockwiseKeyboardShortcutId = "jsdraw.tools.PanZoom.rotateViewClockwise";
  KeyboardShortcutManager_default.registerDefaultKeyboardShortcut(rotateClockwiseKeyboardShortcutId, ["Shift+KeyR"], "Rotate viewport clockwise");
  var rotateCounterClockwiseKeyboardShortcutId = "jsdraw.tools.PanZoom.rotateViewCounterClockwise";
  KeyboardShortcutManager_default.registerDefaultKeyboardShortcut(rotateCounterClockwiseKeyboardShortcutId, ["KeyR"], "Rotate viewport counter-clockwise");
  var zoomInKeyboardShortcutId = "jsdraw.tools.PanZoom.zoomIn";
  KeyboardShortcutManager_default.registerDefaultKeyboardShortcut(zoomInKeyboardShortcutId, ["KeyW"], "Zoom in");
  var zoomOutKeyboardShortcutId = "jsdraw.tools.PanZoom.zoomOut";
  KeyboardShortcutManager_default.registerDefaultKeyboardShortcut(zoomOutKeyboardShortcutId, ["KeyS"], "Zoom out");

  // node_modules/js-draw/dist/mjs/tools/PanZoom.mjs
  var PanZoomMode;
  (function(PanZoomMode2) {
    PanZoomMode2[PanZoomMode2["OneFingerTouchGestures"] = 1] = "OneFingerTouchGestures";
    PanZoomMode2[PanZoomMode2["TwoFingerTouchGestures"] = 2] = "TwoFingerTouchGestures";
    PanZoomMode2[PanZoomMode2["RightClickDrags"] = 4] = "RightClickDrags";
    PanZoomMode2[PanZoomMode2["SinglePointerGestures"] = 8] = "SinglePointerGestures";
    PanZoomMode2[PanZoomMode2["Keyboard"] = 16] = "Keyboard";
    PanZoomMode2[PanZoomMode2["RotationLocked"] = 32] = "RotationLocked";
  })(PanZoomMode || (PanZoomMode = {}));
  var InertialScroller = class {
    constructor(initialVelocity, scrollBy, onComplete) {
      this.initialVelocity = initialVelocity;
      this.scrollBy = scrollBy;
      this.onComplete = onComplete;
      this.running = false;
      this.start();
    }
    async start() {
      if (this.running) {
        return;
      }
      this.currentVelocity = this.initialVelocity;
      let lastTime = performance.now();
      this.running = true;
      const maxSpeed = 5e3;
      const minSpeed = 200;
      if (this.currentVelocity.magnitude() > maxSpeed) {
        this.currentVelocity = this.currentVelocity.normalized().times(maxSpeed);
      }
      while (this.running && this.currentVelocity.magnitude() > minSpeed) {
        const nowTime = performance.now();
        const dt = (nowTime - lastTime) / 1e3;
        this.currentVelocity = this.currentVelocity.times(Math.pow(1 / 8, dt));
        this.scrollBy(this.currentVelocity.times(dt));
        await untilNextAnimationFrame_default();
        lastTime = nowTime;
      }
      if (this.running) {
        this.stop();
      }
    }
    getCurrentVelocity() {
      if (!this.running) {
        return null;
      }
      return this.currentVelocity;
    }
    stop() {
      if (this.running) {
        this.running = false;
        this.onComplete();
      }
    }
  };
  var PanZoom = class extends BaseTool_default {
    constructor(editor, mode, description) {
      super(editor.notifier, description);
      this.editor = editor;
      this.mode = mode;
      this.transform = null;
      this.initialRotationSnapAngle = 0.22;
      this.afterRotationStartSnapAngle = 0.07;
      this.pinchZoomStartThreshold = 1.08;
      this.lastPointerDownTimestamp = 0;
      this.initialTouchAngle = 0;
      this.initialViewportRotation = 0;
      this.initialViewportScale = 0;
      this.isScaling = false;
      this.isRotating = false;
      this.inertialScroller = null;
      this.velocity = null;
    }
    // The pan/zoom tool can be used in a read-only editor.
    canReceiveInputInReadOnlyEditor() {
      return true;
    }
    // Returns information about the pointers in a gesture
    computePinchData(p1, p2) {
      if (p1.id < p2.id) {
        const tmp = p1;
        p1 = p2;
        p2 = tmp;
      }
      const screenBetween = p2.screenPos.minus(p1.screenPos);
      const angle = screenBetween.angle();
      const dist = screenBetween.magnitude();
      const canvasCenter = p2.canvasPos.plus(p1.canvasPos).times(0.5);
      const screenCenter = p2.screenPos.plus(p1.screenPos).times(0.5);
      return { canvasCenter, screenCenter, angle, dist };
    }
    allPointersAreOfType(pointers, kind) {
      return pointers.every((pointer) => pointer.device === kind);
    }
    onPointerDown({ allPointers: pointers, current: currentPointer }) {
      let handlingGesture = false;
      const inertialScrollerVelocity = this.inertialScroller?.getCurrentVelocity() ?? Vec2.zero;
      this.inertialScroller?.stop();
      this.velocity = inertialScrollerVelocity;
      this.lastPointerDownTimestamp = currentPointer.timeStamp;
      const isRightClick = this.allPointersAreOfType(pointers, PointerDevice.RightButtonMouse);
      const allAreTouch = this.allPointersAreOfType(pointers, PointerDevice.Touch);
      const allAreUnknown = this.allPointersAreOfType(pointers, PointerDevice.Other);
      const allAreProbablyTouch = allAreTouch || allAreUnknown;
      if (allAreProbablyTouch && pointers.length === 2 && this.mode & PanZoomMode.TwoFingerTouchGestures) {
        const { screenCenter, angle, dist } = this.computePinchData(pointers[0], pointers[1]);
        this.lastTouchDist = dist;
        this.startTouchDist = dist;
        this.lastScreenCenter = screenCenter;
        this.initialTouchAngle = angle;
        this.initialViewportRotation = this.editor.viewport.getRotationAngle();
        this.initialViewportScale = this.editor.viewport.getScaleFactor();
        this.isScaling = false;
        this.isRotating = Math.abs(Math.sin(this.initialViewportRotation * 2)) > 1e-3;
        handlingGesture = true;
      } else if (pointers.length === 1 && (this.mode & PanZoomMode.OneFingerTouchGestures && allAreTouch || isRightClick && this.mode & PanZoomMode.RightClickDrags || this.mode & PanZoomMode.SinglePointerGestures)) {
        this.lastScreenCenter = pointers[0].screenPos;
        this.isScaling = false;
        handlingGesture = true;
      }
      if (handlingGesture) {
        this.lastTimestamp = performance.now();
        this.transform ??= Viewport.transformBy(Mat33.identity);
        this.editor.display.setDraftMode(true);
      }
      return handlingGesture;
    }
    updateVelocity(currentCenter) {
      const deltaPos = currentCenter.minus(this.lastScreenCenter);
      let deltaTime = (performance.now() - this.lastTimestamp) / 1e3;
      if (deltaPos.magnitude() === 0 && deltaTime < 0.1) {
        return;
      }
      if (deltaTime === 0) {
        return;
      }
      deltaTime = Math.max(deltaTime, 0.01);
      const currentVelocity = deltaPos.times(1 / deltaTime);
      let smoothedVelocity = currentVelocity;
      if (this.velocity) {
        smoothedVelocity = this.velocity.lerp(currentVelocity, 0.5);
      }
      this.velocity = smoothedVelocity;
    }
    // Returns the change in position of the center of the given group of pointers.
    // Assumes this.lastScreenCenter has been set appropriately.
    getCenterDelta(screenCenter) {
      const delta = this.editor.viewport.screenToCanvasTransform.transformVec3(screenCenter.minus(this.lastScreenCenter));
      return delta;
    }
    //  Snaps `angle` to common desired rotations. For example, if `touchAngle` corresponds
    // to a viewport rotation of 90.1 degrees, this function returns a rotation delta that,
    // when applied to the viewport, rotates the viewport to 90.0 degrees.
    //
    // Returns a snapped rotation delta that, when applied to the viewport, rotates the viewport,
    // from its position on the last touchDown event, by `touchAngle - initialTouchAngle`.
    toSnappedRotationDelta(touchAngle) {
      const deltaAngle = touchAngle - this.initialTouchAngle;
      let fullRotation = deltaAngle + this.initialViewportRotation;
      const snapToMultipleOf = Math.PI / 2;
      const roundedFullRotation = Math.round(fullRotation / snapToMultipleOf) * snapToMultipleOf;
      const maxSnapAngle = this.isRotating ? this.afterRotationStartSnapAngle : this.initialRotationSnapAngle;
      if (Math.abs(fullRotation - roundedFullRotation) < maxSnapAngle) {
        fullRotation = roundedFullRotation;
        if (fullRotation !== 0) {
          fullRotation += 1e-4;
        }
      }
      return fullRotation - this.editor.viewport.getRotationAngle();
    }
    /**
     * Given a scale update, `scaleFactor`, returns a new scale factor snapped
     * to a power of two (if within some tolerance of that scale).
     */
    toSnappedScaleFactor(touchDist) {
      const newScale = this.initialViewportScale * touchDist / this.startTouchDist;
      const currentScale = this.editor.viewport.getScaleFactor();
      const logNewScale = Math.log(newScale) / Math.log(10);
      const roundedLogNewScale = Math.round(logNewScale);
      const logTolerance = 0.04;
      if (Math.abs(roundedLogNewScale - logNewScale) < logTolerance) {
        return Math.pow(10, roundedLogNewScale) / currentScale;
      }
      return touchDist / this.lastTouchDist;
    }
    handleTwoFingerMove(allPointers) {
      const { screenCenter, canvasCenter, angle, dist } = this.computePinchData(allPointers[0], allPointers[1]);
      const delta = this.getCenterDelta(screenCenter);
      let deltaRotation;
      if (this.isRotationLocked()) {
        deltaRotation = 0;
      } else {
        deltaRotation = this.toSnappedRotationDelta(angle);
      }
      if (Math.abs(deltaRotation) > 1e-8) {
        this.isRotating = true;
      }
      this.updateVelocity(screenCenter);
      if (!this.isScaling) {
        const initialScaleFactor = dist / this.startTouchDist;
        const upperBound = this.pinchZoomStartThreshold;
        const lowerBound = 1 / this.pinchZoomStartThreshold;
        if (initialScaleFactor > upperBound || initialScaleFactor < lowerBound) {
          this.isScaling = true;
        }
      }
      let scaleFactor = 1;
      if (this.isScaling) {
        scaleFactor = this.toSnappedScaleFactor(dist);
        this.lastTouchDist = dist;
      }
      const transformUpdate = Mat33.translation(delta).rightMul(Mat33.scaling2D(scaleFactor, canvasCenter)).rightMul(Mat33.zRotation(deltaRotation, canvasCenter));
      this.lastScreenCenter = screenCenter;
      this.transform = Viewport.transformBy(this.transform.transform.rightMul(transformUpdate));
      return transformUpdate;
    }
    handleOneFingerMove(pointer) {
      const delta = this.getCenterDelta(pointer.screenPos);
      const transformUpdate = Mat33.translation(delta);
      this.transform = Viewport.transformBy(this.transform.transform.rightMul(transformUpdate));
      this.updateVelocity(pointer.screenPos);
      this.lastScreenCenter = pointer.screenPos;
      return transformUpdate;
    }
    onPointerMove({ allPointers }) {
      this.transform ??= Viewport.transformBy(Mat33.identity);
      let transformUpdate = Mat33.identity;
      if (allPointers.length === 2) {
        transformUpdate = this.handleTwoFingerMove(allPointers);
      } else if (allPointers.length === 1) {
        transformUpdate = this.handleOneFingerMove(allPointers[0]);
      }
      Viewport.transformBy(transformUpdate).apply(this.editor);
      this.lastTimestamp = performance.now();
    }
    onPointerUp(event) {
      const onComplete = () => {
        if (this.transform) {
          this.transform.unapply(this.editor);
          this.editor.dispatch(this.transform, false);
        }
        this.editor.display.setDraftMode(false);
        this.transform = null;
        this.velocity = Vec2.zero;
      };
      const minInertialScrollDt = 30;
      const shouldInertialScroll = event.current.device === PointerDevice.Touch && event.allPointers.length === 1 && this.velocity !== null && event.current.timeStamp - this.lastPointerDownTimestamp > minInertialScrollDt;
      if (shouldInertialScroll && this.velocity !== null) {
        const oldVelocity = this.velocity;
        this.updateVelocity(event.current.screenPos);
        if (oldVelocity.magnitude() < this.velocity.magnitude()) {
          this.velocity = oldVelocity;
        }
        this.inertialScroller?.stop();
        this.inertialScroller = new InertialScroller(this.velocity, (scrollDelta) => {
          if (!this.transform) {
            return;
          }
          const canvasDelta = this.editor.viewport.screenToCanvasTransform.transformVec3(scrollDelta);
          this.transform.unapply(this.editor);
          this.transform = Viewport.transformBy(this.transform.transform.rightMul(Mat33.translation(canvasDelta)));
          this.transform.apply(this.editor);
        }, onComplete);
      } else {
        onComplete();
      }
    }
    onGestureCancel() {
      this.inertialScroller?.stop();
      this.velocity = Vec2.zero;
      this.transform?.unapply(this.editor);
      this.editor.display.setDraftMode(false);
      this.transform = null;
    }
    // Applies [transformUpdate] to the editor. This stacks on top of the
    // current transformation, if it exists.
    updateTransform(transformUpdate, announce = false) {
      let newTransform = transformUpdate;
      if (this.transform) {
        newTransform = this.transform.transform.rightMul(transformUpdate);
      }
      this.transform?.unapply(this.editor);
      this.transform = Viewport.transformBy(newTransform);
      this.transform.apply(this.editor);
      if (announce) {
        this.editor.announceForAccessibility(this.transform.description(this.editor, this.editor.localization));
      }
    }
    /**
     * Updates the current transform and clears it. Use this method for events that are not part of
     * a larger gesture (i.e. have no start and end event). For example, this would be used for `onwheel`
     * events, but not for `onpointer` events.
     */
    applyAndFinalizeTransform(transformUpdate) {
      this.updateTransform(transformUpdate, true);
      this.transform = null;
    }
    onWheel({ delta, screenPos }) {
      this.inertialScroller?.stop();
      this.transform = Viewport.transformBy(Mat33.identity);
      const canvasPos = this.editor.viewport.screenToCanvas(screenPos);
      const toCanvas = this.editor.viewport.screenToCanvasTransform;
      const translation = toCanvas.transformVec3(Vec3.of(-delta.x, -delta.y, 0));
      let pinchAmount = delta.z;
      pinchAmount = Math.atan(pinchAmount / 2) * 2;
      const pinchZoomScaleFactor = 1.04;
      const transformUpdate = Mat33.scaling2D(Math.max(0.4, Math.min(Math.pow(pinchZoomScaleFactor, -pinchAmount), 4)), canvasPos).rightMul(Mat33.translation(translation));
      this.applyAndFinalizeTransform(transformUpdate);
      return true;
    }
    onKeyPress(event) {
      this.inertialScroller?.stop();
      if (!(this.mode & PanZoomMode.Keyboard)) {
        return false;
      }
      this.transform = Viewport.transformBy(Mat33.identity);
      let translation = Vec2.zero;
      let scale = 1;
      let rotation = 0;
      const shortcucts = this.editor.shortcuts;
      if (shortcucts.matchesShortcut(moveLeftKeyboardShortcutId, event)) {
        translation = Vec2.of(-1, 0);
      } else if (shortcucts.matchesShortcut(moveRightKeyboardShortcutId, event)) {
        translation = Vec2.of(1, 0);
      } else if (shortcucts.matchesShortcut(moveUpKeyboardShortcutId, event)) {
        translation = Vec2.of(0, -1);
      } else if (shortcucts.matchesShortcut(moveDownKeyboardShortcutId, event)) {
        translation = Vec2.of(0, 1);
      } else if (shortcucts.matchesShortcut(zoomInKeyboardShortcutId, event)) {
        scale = 1 / 2;
      } else if (shortcucts.matchesShortcut(zoomOutKeyboardShortcutId, event)) {
        scale = 2;
      } else if (shortcucts.matchesShortcut(rotateClockwiseKeyboardShortcutId, event)) {
        rotation = 1;
      } else if (shortcucts.matchesShortcut(rotateCounterClockwiseKeyboardShortcutId, event)) {
        rotation = -1;
      } else {
        return false;
      }
      translation = translation.times(30);
      rotation *= Math.PI / 8;
      translation = translation.times(-1);
      rotation = rotation * -1;
      scale = 1 / scale;
      if (rotation !== 0) {
        rotation += 1e-4;
      }
      if (this.isRotationLocked()) {
        rotation = 0;
      }
      const toCanvas = this.editor.viewport.screenToCanvasTransform;
      translation = toCanvas.transformVec3(translation);
      const transformCenter = this.editor.viewport.visibleRect.center;
      const transformUpdate = Mat33.scaling2D(scale, transformCenter).rightMul(Mat33.zRotation(rotation, transformCenter)).rightMul(Mat33.translation(translation));
      this.applyAndFinalizeTransform(transformUpdate);
      return true;
    }
    isRotationLocked() {
      return !!(this.mode & PanZoomMode.RotationLocked);
    }
    /**
     * Changes the types of gestures used by this pan/zoom tool.
     *
     * @see {@link PanZoomMode} {@link setMode}
     *
     * @example
     * ```ts,runnable
     * import { Editor, PanZoomTool, PanZoomMode } from 'js-draw';
     *
     * const editor = new Editor(document.body);
     *
     * // By default, there are multiple PanZoom tools that handle different events.
     * // This gets all PanZoomTools.
     * const panZoomToolList = editor.toolController.getMatchingTools(PanZoomTool);
     *
     * // The first PanZoomTool is the highest priority -- by default,
     * // this tool is responsible for handling multi-finger touch gestures.
     * //
     * // Lower-priority PanZoomTools handle one-finger touch gestures and
     * // key-presses.
     * const panZoomTool = panZoomToolList[0];
     *
     * // Lock rotation for multi-finger touch gestures.
     * panZoomTool.setModeEnabled(PanZoomMode.RotationLocked, true);
     * ```
     */
    setModeEnabled(mode, enabled) {
      let newMode = this.mode;
      if (enabled) {
        newMode |= mode;
      } else {
        newMode &= ~mode;
      }
      this.setMode(newMode);
    }
    /**
     * Sets all modes for this tool using a bitmask.
     *
     * @see {@link setModeEnabled}
     *
     * @example
     * ```ts
     * tool.setMode(PanZoomMode.RotationLocked|PanZoomMode.TwoFingerTouchGestures);
     * ```
     */
    setMode(mode) {
      if (mode !== this.mode) {
        this.mode = mode;
        this.editor.notifier.dispatch(EditorEventType.ToolUpdated, {
          kind: EditorEventType.ToolUpdated,
          tool: this
        });
      }
    }
    /**
     * Returns a bitmask indicating the currently-enabled modes.
     * @see {@link setModeEnabled}
     */
    getMode() {
      return this.mode;
    }
  };

  // node_modules/js-draw/dist/mjs/rendering/RenderingStyle.mjs
  var cloneStyle = (style) => {
    return {
      fill: style.fill,
      stroke: style.stroke ? {
        ...style.stroke
      } : void 0
    };
  };
  var stylesEqual = (a, b) => {
    const result = a === b || a.fill.eq(b.fill) && a.stroke == void 0 === (b.stroke == void 0) && (a.stroke?.color?.eq(b.stroke?.color) ?? true) && a.stroke?.width === b.stroke?.width;
    return result ?? false;
  };
  var styleToJSON = (style) => {
    const stroke = !style.stroke ? void 0 : {
      color: style.stroke.color.toHexString(),
      width: style.stroke.width
    };
    return {
      fill: style.fill.toHexString(),
      stroke
    };
  };
  var styleFromJSON = (json) => {
    const stroke = json.stroke ? {
      color: Color4.fromHex(json.stroke.color),
      width: json.stroke.width
    } : void 0;
    return {
      fill: Color4.fromHex(json.fill),
      stroke
    };
  };

  // node_modules/js-draw/dist/mjs/rendering/TextRenderingStyle.mjs
  var cloneTextStyle = (style) => {
    return {
      ...style,
      renderingStyle: cloneStyle(style.renderingStyle)
    };
  };
  var textStyleFromJSON = (json) => {
    if (typeof json === "string") {
      json = JSON.parse(json);
    }
    if (typeof json.fontFamily !== "string") {
      throw new Error("Serialized textStyle missing string fontFamily attribute!");
    }
    const style = {
      renderingStyle: styleFromJSON(json.renderingStyle),
      size: json.size,
      fontWeight: json.fontWeight,
      fontVariant: json.fontVariant,
      fontFamily: json.fontFamily
    };
    return style;
  };
  var textStyleToJSON = (style) => {
    return {
      ...style,
      renderingStyle: styleToJSON(style.renderingStyle)
    };
  };

  // node_modules/js-draw/dist/mjs/components/RestylableComponent.mjs
  var serializeComponentStyle = (style) => {
    const result = {};
    if (style.color) {
      result.color = style.color.toHexString();
    }
    if (style.textStyle) {
      result.textStyle = textStyleToJSON(style.textStyle);
    }
    return result;
  };
  var deserializeComponentStyle = (json) => {
    const color = json.color ? Color4.fromHex(json.color) : void 0;
    const textStyle = json.textStyle ? textStyleFromJSON(json.textStyle) : void 0;
    return {
      color,
      textStyle
    };
  };
  var createRestyleComponentCommand = (initialStyle, newStyle, component) => {
    return new DefaultRestyleComponentCommand(initialStyle, newStyle, component.getId(), component);
  };
  var isRestylableComponent = (component) => {
    const hasMethods = "getStyle" in component && "updateStyle" in component && "forceStyle" in component;
    if (!hasMethods) {
      return false;
    }
    if (!("isRestylableComponent" in component) || !component["isRestylableComponent"]) {
      return false;
    }
    return true;
  };
  var defaultRestyleComponentCommandId = "default-restyle-element";
  var DefaultRestyleComponentCommand = class extends UnresolvedSerializableCommand {
    constructor(originalStyle, newStyle, componentID, component) {
      super(defaultRestyleComponentCommandId, componentID, component);
      this.originalStyle = originalStyle;
      this.newStyle = newStyle;
    }
    getComponent(editor) {
      this.resolveComponent(editor.image);
      const component = this.component;
      if (!component || !component["forceStyle"] || !component["updateStyle"]) {
        throw new Error("this.component is missing forceStyle and/or updateStyle methods!");
      }
      return component;
    }
    apply(editor) {
      this.getComponent(editor).forceStyle(this.newStyle, editor);
    }
    unapply(editor) {
      this.getComponent(editor).forceStyle(this.originalStyle, editor);
    }
    description(editor, localizationTable) {
      return localizationTable.restyledElement(this.getComponent(editor).description(localizationTable));
    }
    serializeToJSON() {
      return {
        id: this.componentID,
        originalStyle: serializeComponentStyle(this.originalStyle),
        newStyle: serializeComponentStyle(this.newStyle)
      };
    }
  };
  (() => {
    SerializableCommand_default.register(defaultRestyleComponentCommandId, (json, _editor) => {
      const origStyle = deserializeComponentStyle(json.originalStyle);
      const newStyle = deserializeComponentStyle(json.newStyle);
      const id = json.id;
      if (typeof json.id !== "string") {
        throw new Error(`json.id is of type ${typeof json.id}, not string.`);
      }
      return new DefaultRestyleComponentCommand(origStyle, newStyle, id);
    });
  })();

  // node_modules/js-draw/dist/mjs/rendering/RenderablePathSpec.mjs
  var pathFromRenderable = (renderable) => {
    if (renderable.path) {
      return renderable.path;
    }
    return new Path(renderable.startPoint, renderable.commands);
  };
  var pathToRenderable = (path, style) => {
    return {
      startPoint: path.startPoint,
      style,
      commands: path.parts,
      path
    };
  };
  var pathIncluded = (renderablePath, path) => {
    if (renderablePath.path) {
      return renderablePath;
    }
    return {
      ...renderablePath,
      path
    };
  };
  var simplifyPathToFullScreenOrEmpty = (renderablePath, visibleRect, options = {
    fastCheck: true,
    expensiveCheck: true
  }) => {
    const path = pathFromRenderable(renderablePath);
    const strokeWidth = renderablePath.style.stroke?.width ?? 0;
    const onlyStroked = strokeWidth > 0 && renderablePath.style.fill.a === 0;
    const styledPathBBox = path.bbox.grownBy(strokeWidth);
    const isOnlyStrokedAndCouldFillScreen = onlyStroked && strokeWidth > visibleRect.maxDimension && styledPathBBox.containsRect(visibleRect);
    if (options.fastCheck && isOnlyStrokedAndCouldFillScreen && renderablePath.style.stroke) {
      const strokeRadius = strokeWidth / 2;
      for (const point of path.startEndPoints()) {
        if (visibleRect.isWithinRadiusOf(strokeRadius, point)) {
          return {
            rectangle: visibleRect,
            path: pathToRenderable(Path.fromRect(visibleRect), {
              fill: renderablePath.style.stroke.color
            }),
            fullScreen: true
          };
        }
      }
    }
    if (options.expensiveCheck && isOnlyStrokedAndCouldFillScreen && renderablePath.style.stroke && strokeWidth > visibleRect.maxDimension * 3) {
      const signedDist = path.signedDistance(visibleRect.center, strokeWidth / 2);
      const margin = strokeWidth / 6;
      if (signedDist < -visibleRect.maxDimension / 2 - margin) {
        return {
          path: pathToRenderable(Path.fromRect(visibleRect), {
            fill: renderablePath.style.stroke.color
          }),
          rectangle: visibleRect,
          fullScreen: true
        };
      } else if (signedDist > visibleRect.maxDimension / 2 + margin) {
        return {
          path: pathToRenderable(Path.empty, { fill: Color4.transparent }),
          rectangle: Rect2.empty,
          fullScreen: false
        };
      }
    }
    return null;
  };
  var visualEquivalent = (renderablePath, visibleRect) => {
    const path = pathFromRenderable(renderablePath);
    const strokeWidth = renderablePath.style.stroke?.width ?? 0;
    const onlyStroked = strokeWidth > 0 && renderablePath.style.fill.a === 0;
    const styledPathBBox = path.bbox.grownBy(strokeWidth);
    let rectangleSimplification = simplifyPathToFullScreenOrEmpty(renderablePath, visibleRect, {
      fastCheck: true,
      expensiveCheck: false
    });
    if (rectangleSimplification) {
      return rectangleSimplification.path;
    }
    const expandedRect = visibleRect.grownBy(strokeWidth).transformedBoundingBox(Mat33.scaling2D(4, visibleRect.center));
    if (expandedRect.containsRect(styledPathBBox)) {
      return pathIncluded(renderablePath, path);
    }
    const parts = [];
    let startPoint = path.startPoint;
    for (const part of path.parts) {
      const partBBox = Path.computeBBoxForSegment(startPoint, part).grownBy(strokeWidth);
      let endPoint;
      if (part.kind === PathCommandType.LineTo || part.kind === PathCommandType.MoveTo) {
        endPoint = part.point;
      } else {
        endPoint = part.endPoint;
      }
      const intersectsVisible = partBBox.intersects(visibleRect);
      if (intersectsVisible) {
        parts.push(part);
      } else if (onlyStroked || part.kind === PathCommandType.MoveTo) {
        parts.push({
          kind: PathCommandType.MoveTo,
          point: endPoint
        });
      } else {
        parts.push({
          kind: PathCommandType.LineTo,
          point: endPoint
        });
      }
      startPoint = endPoint;
    }
    const newPath = new Path(path.startPoint, parts);
    const newStyle = renderablePath.style;
    rectangleSimplification = simplifyPathToFullScreenOrEmpty(renderablePath, visibleRect, {
      fastCheck: false,
      expensiveCheck: true
    });
    if (rectangleSimplification) {
      return rectangleSimplification.path;
    }
    return pathToRenderable(newPath, newStyle);
  };

  // node_modules/js-draw/dist/mjs/components/Stroke.mjs
  var Stroke = class _Stroke extends AbstractComponent_default {
    /**
     * Creates a `Stroke` from the given `parts`. All parts should have the
     * same color.
     *
     * @example
     * ```ts
     * // A path that starts at (1,1), moves to the right by (2, 0),
     * // then moves down and right by (3, 3)
     * const path = Path.fromString('m1,1 2,0 3,3');
     *
     * const stroke = new Stroke([
     *     // Fill with red
     *     pathToRenderable(path, { fill: Color4.red })
     * ]);
     * ```
     */
    constructor(parts, initialZIndex) {
      super("stroke", initialZIndex);
      this.isRestylableComponent = true;
      this.simplifiedPath = null;
      this.approximateRenderingTime = 0;
      this.parts = [];
      for (const section of parts) {
        const path = pathFromRenderable(section);
        const pathBBox = this.bboxForPart(path.bbox, section.style);
        if (!this.contentBBox) {
          this.contentBBox = pathBBox;
        } else {
          this.contentBBox = this.contentBBox.union(pathBBox);
        }
        this.parts.push({
          path,
          // To implement RenderablePathSpec
          startPoint: path.startPoint,
          style: section.style,
          commands: path.parts
        });
        this.approximateRenderingTime += path.parts.length;
      }
      this.contentBBox ??= Rect2.empty;
    }
    /**
     * Creates a new `Stroke` from a {@link Path} and `style`. Strokes created
     * with this method have transparent fill.
     *
     * Example:
     * ```ts,runnable
     * import { Editor, Stroke, Color4 } from 'js-draw';
     * const editor = new Editor(document.body);
     * ---visible---
     * const stroke = Stroke.fromStroked('m0,0 l10,10', { width: 10, color: Color4.red });
     * editor.dispatch(editor.image.addComponent(stroke));
     * ```
     * Notice that `path` can be a string that specifies an SVG path
     *
     * @see fromFilled
     */
    static fromStroked(path, style) {
      if (typeof path === "string") {
        path = Path.fromString(path);
      }
      return new _Stroke([pathToRenderable(path, { fill: Color4.transparent, stroke: style })]);
    }
    /** @see fromStroked */
    static fromFilled(path, fill) {
      if (typeof path === "string") {
        path = Path.fromString(path);
      }
      return new _Stroke([pathToRenderable(path, { fill })]);
    }
    getStyle() {
      if (this.parts.length === 0) {
        return {};
      }
      const firstPart = this.parts[0];
      if (firstPart.style.stroke === void 0 || firstPart.style.stroke.width === 0) {
        return {
          color: firstPart.style.fill
        };
      }
      return {
        color: firstPart.style.stroke.color
      };
    }
    updateStyle(style) {
      return createRestyleComponentCommand(this.getStyle(), style, this);
    }
    forceStyle(style, editor) {
      if (!style.color) {
        return;
      }
      this.parts = this.parts.map((part) => {
        const newStyle = {
          ...part.style,
          stroke: part.style.stroke ? {
            ...part.style.stroke
          } : void 0
        };
        if (newStyle.stroke && newStyle.stroke.width > 0) {
          newStyle.stroke.color = style.color;
        } else {
          newStyle.fill = style.color;
        }
        return {
          path: part.path,
          startPoint: part.startPoint,
          commands: part.commands,
          style: newStyle
        };
      });
      if (editor) {
        editor.image.queueRerenderOf(this);
        editor.queueRerender();
      }
    }
    /** @beta -- May fail for concave `path`s */
    withRegionErased(eraserPath, viewport) {
      const polyline = eraserPath.polylineApproximation();
      const isPointInsideEraser = (point) => {
        return eraserPath.closedContainsPoint(point);
      };
      const newStrokes = [];
      let failedAssertions = false;
      for (const part of this.parts) {
        const path = part.path;
        const makeStroke = (path2) => {
          if (part.style.fill.a > 0) {
            if (path2.parts.length < 1 || path2.parts.length === 1 && path2.parts[0].kind === PathCommandType.LineTo) {
              return null;
            } else {
              path2 = path2.asClosed();
            }
          }
          if (isNaN(path2.getExactBBox().area)) {
            console.warn("Prevented creating a stroke with NaN area");
            failedAssertions = true;
            return null;
          }
          return new _Stroke([pathToRenderable(path2, part.style)], this.getZIndex());
        };
        const intersectionPoints = [];
        for (const segment of polyline) {
          intersectionPoints.push(...path.intersection(segment));
        }
        let isErasingFromEdge = false;
        if (intersectionPoints.length === 0 && part.style.stroke && part.style.stroke.width > eraserPath.bbox.minDimension * 0.3 && part.style.stroke.width < eraserPath.bbox.maxDimension * 30) {
          for (const segment of polyline) {
            intersectionPoints.push(...path.intersection(segment, part.style.stroke.width / 2));
          }
          isErasingFromEdge = true;
        }
        intersectionPoints.sort(compareCurveIndices);
        const isInsideJustBeforeFirst = (() => {
          if (intersectionPoints.length === 0) {
            return false;
          }
          if (isErasingFromEdge) {
            return intersectionPoints[0].curveIndex === 0 && intersectionPoints[0].parameterValue <= 0;
          }
          const justBeforeFirstIntersection = stepCurveIndexBy(intersectionPoints[0], -1e-10);
          return isPointInsideEraser(path.at(justBeforeFirstIntersection));
        })();
        let intersectionCount = isInsideJustBeforeFirst ? 1 : 0;
        const addNewPath = (path2, knownToBeInside) => {
          const component = makeStroke(path2);
          let isInside = intersectionCount % 2 === 1;
          intersectionCount++;
          if (knownToBeInside !== void 0) {
            isInside = knownToBeInside;
          }
          if (knownToBeInside === void 0 && !isInside && eraserPath.closedContainsPoint(path2.getExactBBox().center)) {
            isInside = !isInside;
          }
          if (!component) {
            return;
          }
          failedAssertions ||= isInside && path2.getExactBBox().maxDimension > eraserPath.getExactBBox().maxDimension * 2;
          if (!isInside) {
            newStrokes.push(component);
          }
        };
        if (part.style.fill.a === 0) {
          const shouldEraseCompletely = eraserPath.getExactBBox().maxDimension / 10 > path.getExactBBox().maxDimension;
          if (!shouldEraseCompletely) {
            const split = path.splitAt(intersectionPoints, {
              mapNewPoint: (p) => viewport.roundPoint(p)
            });
            for (const splitPart of split) {
              addNewPath(splitPart);
            }
          }
        } else if (intersectionPoints.length >= 2 && intersectionPoints.length % 2 === 0) {
          const parts = path.splitAt(intersectionPoints, {
            mapNewPoint: (p) => viewport.roundPoint(p)
          });
          for (let i = 0; i < Math.floor(parts.length / 2); i++) {
            addNewPath(parts[i].union(parts[parts.length - i - 1]).asClosed());
          }
          if (parts.length % 2 !== 0) {
            addNewPath(parts[Math.floor(parts.length / 2)].asClosed());
          }
        } else {
          addNewPath(path, false);
        }
      }
      if (failedAssertions) {
        return [this];
      }
      return newStrokes;
    }
    intersects(line) {
      for (const part of this.parts) {
        const strokeWidth = part.style.stroke?.width;
        const strokeRadius = strokeWidth ? strokeWidth / 2 : void 0;
        if (part.path.intersection(line, strokeRadius).length > 0) {
          return true;
        }
      }
      return false;
    }
    keyPoints() {
      return this.parts.map((part) => {
        return part.startPoint;
      }).flat();
    }
    intersectsRect(rect) {
      if (!rect.intersects(this.getBBox())) {
        return false;
      }
      for (const part of this.parts) {
        const interiorRect = rect.grownBy(-(part.style.stroke?.width ?? 0));
        if (interiorRect.area === 0) {
          continue;
        }
        for (const point of part.path.startEndPoints()) {
          if (interiorRect.containsPoint(point)) {
            return true;
          }
        }
      }
      return super.intersectsRect(rect);
    }
    computeSimplifiedPathFor(visibleRect) {
      const simplifiedParts = [];
      let occludes = false;
      let skipSimplification = false;
      for (const part of this.parts) {
        if (skipSimplification || // Simplification currently only works for stroked paths
        !part.style.stroke || // One of the main purposes of this is to check for occlusion.
        // We can't occlude things if the stroke is partially transparent.
        part.style.stroke.color.a < 0.99) {
          simplifiedParts.push(part);
          continue;
        }
        const mapping = simplifyPathToFullScreenOrEmpty(part, visibleRect);
        if (mapping) {
          simplifiedParts.push(mapping.path);
          if (mapping.fullScreen) {
            occludes = true;
            skipSimplification = true;
          }
        } else {
          simplifiedParts.push(part);
        }
      }
      return {
        forVisibleRect: visibleRect,
        parts: simplifiedParts,
        occludes
      };
    }
    occludesEverythingBelowWhenRenderedInRect(rect) {
      if (!this.getBBox().containsRect(rect)) {
        return false;
      }
      if (!this.simplifiedPath || !this.simplifiedPath.forVisibleRect.eq(rect)) {
        this.simplifiedPath = this.computeSimplifiedPathFor(rect);
      }
      return this.simplifiedPath.occludes;
    }
    render(canvas, visibleRect) {
      canvas.startObject(this.getBBox());
      let parts = this.parts;
      if (visibleRect && this.simplifiedPath?.forVisibleRect?.containsRect(visibleRect)) {
        parts = this.simplifiedPath.parts;
      } else {
        this.simplifiedPath = null;
      }
      for (const part of parts) {
        const bbox = this.bboxForPart(part.path.bbox, part.style);
        if (visibleRect) {
          if (!bbox.intersects(visibleRect)) {
            continue;
          }
          const muchBiggerThanVisible = bbox.size.x > visibleRect.size.x * 3 || bbox.size.y > visibleRect.size.y * 3;
          if (muchBiggerThanVisible && !part.path.roughlyIntersects(visibleRect, part.style.stroke?.width ?? 0)) {
            continue;
          }
        }
        canvas.drawPath(part);
      }
      canvas.endObject(this.getLoadSaveData());
    }
    getProportionalRenderingTime() {
      return this.approximateRenderingTime;
    }
    // Grows the bounding box for a given stroke part based on that part's style.
    bboxForPart(origBBox, style) {
      if (!style.stroke) {
        return origBBox;
      }
      return origBBox.grownBy(style.stroke.width / 2);
    }
    getExactBBox() {
      let bbox = null;
      for (const { path, style } of this.parts) {
        const partBBox = this.bboxForPart(path.getExactBBox(), style);
        bbox ??= partBBox;
        bbox = bbox.union(partBBox);
      }
      return bbox ?? Rect2.empty;
    }
    applyTransformation(affineTransfm) {
      this.contentBBox = Rect2.empty;
      let isFirstPart = true;
      this.parts = this.parts.map((part) => {
        const newPath = part.path.transformedBy(affineTransfm);
        const newStyle = {
          ...part.style,
          stroke: part.style.stroke ? {
            ...part.style.stroke
          } : void 0
        };
        if (newStyle.stroke) {
          const scaleFactor = affineTransfm.getScaleFactor();
          newStyle.stroke.width *= scaleFactor;
        }
        const newBBox = this.bboxForPart(newPath.bbox, newStyle);
        if (isFirstPart) {
          this.contentBBox = newBBox;
          isFirstPart = false;
        } else {
          this.contentBBox = this.contentBBox.union(newBBox);
        }
        return {
          path: newPath,
          startPoint: newPath.startPoint,
          commands: newPath.parts,
          style: newStyle
        };
      });
    }
    /**
     * @returns A list of the parts that make up this path. Many paths only have one part.
     *
     * Each part (a {@link RenderablePathSpec}) contains information about the style and geometry
     * of that part of the stroke. Use the `.path` property to do collision detection and other
     * operations involving the stroke's geometry.
     *
     * Note that many of {@link Path}'s methods (e.g. {@link Path.intersection}) take a
     * `strokeWidth` parameter that can be gotten from {@link RenderablePathSpec.style} `.stroke.width`.
     */
    getParts() {
      return [...this.parts];
    }
    /**
     * @returns the {@link Path.union} of all paths that make up this stroke.
     */
    getPath() {
      let result = null;
      for (const part of this.parts) {
        if (result) {
          result = result.union(part.path);
        } else {
          result ??= part.path;
        }
      }
      return result ?? Path.empty;
    }
    description(localization7) {
      return localization7.stroke;
    }
    createClone() {
      return new _Stroke(this.parts);
    }
    serializeToJSON() {
      return this.parts.map((part) => {
        return {
          style: styleToJSON(part.style),
          path: part.path.serialize()
        };
      });
    }
    /** @internal */
    static deserializeFromJSON(json) {
      if (typeof json === "string") {
        json = JSON.parse(json);
      }
      if (typeof json !== "object" || typeof json.length !== "number") {
        throw new Error(`${json} is missing required field, parts, or parts is of the wrong type.`);
      }
      const pathSpec = json.map((part) => {
        const style = styleFromJSON(part.style);
        return pathToRenderable(Path.fromString(part.path), style);
      });
      return new _Stroke(pathSpec);
    }
  };
  AbstractComponent_default.registerComponent("stroke", Stroke.deserializeFromJSON);

  // node_modules/js-draw/dist/mjs/components/util/StrokeSmoother.mjs
  var StrokeSmoother = class {
    constructor(startPoint, minFitAllowed, maxFitAllowed, onCurveAdded) {
      this.startPoint = startPoint;
      this.minFitAllowed = minFitAllowed;
      this.maxFitAllowed = maxFitAllowed;
      this.onCurveAdded = onCurveAdded;
      this.isFirstSegment = true;
      this.lastExitingVec = null;
      this.currentCurve = null;
      this.lastPoint = this.startPoint;
      this.buffer = [this.startPoint.pos];
      this.momentum = Vec2.zero;
      this.currentCurve = null;
      this.curveStartWidth = startPoint.width;
      this.bbox = new Rect2(this.startPoint.pos.x, this.startPoint.pos.y, 0, 0);
    }
    getBBox() {
      return this.bbox;
    }
    preview() {
      if (!this.currentCurve) {
        return null;
      }
      return this.currentSegmentToPath();
    }
    // Returns the distance between the start, control, and end points of the curve.
    approxCurrentCurveLength() {
      if (!this.currentCurve) {
        return 0;
      }
      const startPt = this.currentCurve.p0;
      const controlPt = this.currentCurve.p1;
      const endPt = this.currentCurve.p2;
      const toControlDist = startPt.distanceTo(controlPt);
      const toEndDist = endPt.distanceTo(controlPt);
      return toControlDist + toEndDist;
    }
    finalizeCurrentCurve() {
      if (!this.currentCurve) {
        return;
      }
      this.onCurveAdded(this.currentSegmentToPath());
      const lastPoint = this.buffer[this.buffer.length - 1];
      this.lastExitingVec = this.currentCurve.p2.minus(this.currentCurve.p1);
      console.assert(this.lastExitingVec.magnitude() !== 0, "lastExitingVec has zero length!");
      this.buffer = [this.buffer[this.buffer.length - 2], lastPoint];
      this.currentCurve = null;
      this.isFirstSegment = false;
    }
    // Returns [upper curve, connector, lower curve]
    currentSegmentToPath() {
      if (this.currentCurve == null) {
        throw new Error("Invalid State: currentCurve is null!");
      }
      const startVec = this.currentCurve.normal(0).normalized();
      if (!isFinite(startVec.magnitude())) {
        throw new Error(`startVec(${startVec}) is NaN or \u221E`);
      }
      const startPt = this.currentCurve.at(0);
      const endPt = this.currentCurve.at(1);
      const controlPoint = this.currentCurve.p1;
      return {
        startPoint: startPt,
        controlPoint,
        endPoint: endPt,
        startWidth: this.curveStartWidth,
        endWidth: this.curveEndWidth
      };
    }
    // Compute the direction of the velocity at the end of this.buffer
    computeExitingVec() {
      return this.momentum.normalized().times(this.lastPoint.width / 2);
    }
    addPoint(newPoint) {
      if (this.lastPoint) {
        const fuzzEq = 1e-10;
        const deltaTime = newPoint.time - this.lastPoint.time;
        if (newPoint.pos.eq(this.lastPoint.pos, fuzzEq) || deltaTime === 0) {
          return;
        } else if (isNaN(newPoint.pos.magnitude())) {
          console.warn("Discarding NaN point.", newPoint);
          return;
        }
        const threshold = Math.min(this.lastPoint.width, newPoint.width) / 3;
        const shouldSnapToInitial = this.startPoint.pos.distanceTo(newPoint.pos) < threshold && this.isFirstSegment;
        if (shouldSnapToInitial) {
          return;
        }
        const deltaTimeSeconds = deltaTime / 1e3;
        const velocity = newPoint.pos.minus(this.lastPoint.pos).times(1 / deltaTimeSeconds);
        this.momentum = velocity;
      }
      const lastPoint = this.lastPoint ?? newPoint;
      this.lastPoint = newPoint;
      this.buffer.push(newPoint.pos);
      const pointRadius = newPoint.width;
      const prevEndWidth = this.curveEndWidth;
      this.curveEndWidth = pointRadius;
      this.bbox = this.bbox.grownToPoint(newPoint.pos, pointRadius);
      if (this.currentCurve === null) {
        const p1 = lastPoint.pos;
        const p2 = lastPoint.pos.plus(this.lastExitingVec ?? Vec2.unitX);
        const p3 = newPoint.pos;
        this.currentCurve = new QuadraticBezier(p1, p2, p3);
        console.assert(!isNaN(p1.magnitude()) && !isNaN(p2.magnitude()) && !isNaN(p3.magnitude()), "Expected !NaN");
        if (this.isFirstSegment) {
          this.curveStartWidth = (this.curveStartWidth + pointRadius) / 2;
        } else {
          this.curveStartWidth = prevEndWidth;
        }
      }
      let enteringVec = this.lastExitingVec;
      if (!enteringVec) {
        let sampleIdx = Math.ceil(this.buffer.length / 2);
        if (sampleIdx === 0 || sampleIdx >= this.buffer.length) {
          sampleIdx = this.buffer.length - 1;
        }
        enteringVec = this.buffer[sampleIdx].minus(this.buffer[0]);
      }
      let exitingVec = this.computeExitingVec();
      const maxRelativeLength = 1.7;
      const segmentStart = this.buffer[0];
      const segmentEnd = newPoint.pos;
      const startEndDist = segmentEnd.distanceTo(segmentStart);
      const maxControlPointDist = maxRelativeLength * startEndDist;
      if (maxControlPointDist === 0 || exitingVec.magnitude() === 0 || !isFinite(exitingVec.magnitude())) {
        return;
      }
      console.assert(isFinite(enteringVec.magnitude()), "Pre-normalized enteringVec has NaN or \u221E magnitude!");
      enteringVec = enteringVec.normalized();
      exitingVec = exitingVec.normalized();
      console.assert(isFinite(enteringVec.magnitude()), "Normalized enteringVec has NaN or \u221E magnitude!");
      const lineFromStart = new LineSegment2(segmentStart, segmentStart.plus(enteringVec.times(maxControlPointDist)));
      const lineFromEnd = new LineSegment2(segmentEnd.minus(exitingVec.times(maxControlPointDist)), segmentEnd);
      const intersection = lineFromEnd.intersection(lineFromStart);
      let controlPoint = null;
      if (intersection) {
        controlPoint = intersection.point;
      }
      if (!controlPoint) {
        controlPoint = segmentStart.lerp(segmentEnd, 0.5).lerp(segmentStart.plus(enteringVec.times(startEndDist)), 0.1);
      }
      if (segmentStart.eq(controlPoint) || segmentEnd.eq(controlPoint)) {
        controlPoint = segmentStart.plus(enteringVec.times(startEndDist / 5));
      }
      console.assert(!segmentStart.eq(controlPoint, 1e-11), "Start and control points are equal!");
      console.assert(!controlPoint.eq(segmentEnd, 1e-11), "Control and end points are equal!");
      const prevCurve = this.currentCurve;
      this.currentCurve = new QuadraticBezier(segmentStart, controlPoint, segmentEnd);
      if (isNaN(this.currentCurve.normal(0).magnitude())) {
        console.error("NaN normal at 0. Curve:", this.currentCurve);
        this.currentCurve = prevCurve;
      }
      const curveMatchesPoints = (curve) => {
        const minFit = Math.min(Math.max(Math.min(this.curveStartWidth, this.curveEndWidth) / 4, this.minFitAllowed), this.maxFitAllowed);
        const maxNonMatchingDistSum = minFit;
        let nonMatchingDistSum = 0;
        for (const point of this.buffer) {
          let dist = curve.approximateDistance(point);
          if (dist > minFit) {
            dist = curve.distance(point);
            nonMatchingDistSum += Math.max(0, dist - minFit);
            if (nonMatchingDistSum > maxNonMatchingDistSum) {
              return false;
            }
          }
        }
        return true;
      };
      if (this.buffer.length > 3 && this.approxCurrentCurveLength() > this.curveStartWidth / 2) {
        if (!curveMatchesPoints(this.currentCurve)) {
          this.currentCurve = prevCurve;
          this.curveEndWidth = prevEndWidth;
          this.lastPoint = lastPoint;
          this.finalizeCurrentCurve();
          return;
        }
      }
    }
  };

  // node_modules/js-draw/dist/mjs/components/builders/autocorrect/makeShapeFitAutocorrect.mjs
  var makeShapeFitAutocorrect = (sourceFactory) => {
    return (startPoint, viewport) => {
      return new ShapeFitBuilder(sourceFactory, startPoint, viewport);
    };
  };
  var makeShapeFitAutocorrect_default = makeShapeFitAutocorrect;
  var makeLineTemplate = (startPoint, points, _bbox) => {
    const templatePoints = [startPoint, points[points.length - 1]];
    return { points: templatePoints };
  };
  var makeRectangleTemplate = (_startPoint, _points, bbox) => {
    return { points: [...bbox.corners, bbox.corners[0]] };
  };
  var ShapeFitBuilder = class {
    constructor(sourceFactory, startPoint, viewport) {
      this.sourceFactory = sourceFactory;
      this.startPoint = startPoint;
      this.viewport = viewport;
      this.builder = sourceFactory(startPoint, viewport);
      this.points = [startPoint];
      if (this.builder.inkTrailStyle) {
        this.inkTrailStyle = this.builder.inkTrailStyle.bind(this.builder);
      }
    }
    getBBox() {
      return this.builder.getBBox();
    }
    build() {
      return this.builder.build();
    }
    preview(renderer) {
      this.builder.preview(renderer);
    }
    addPoint(point) {
      this.points.push(point);
      this.builder.addPoint(point);
    }
    async autocorrectShape() {
      const startPoint = this.viewport.canvasToScreen(this.startPoint.pos);
      const points = this.points.map((point) => this.viewport.canvasToScreen(point.pos));
      const bbox = Rect2.bboxOf(points);
      const snappedStartPoint = this.viewport.canvasToScreen(this.viewport.snapToGrid(this.startPoint.pos));
      const snappedPoints = this.points.map((point) => this.viewport.canvasToScreen(this.viewport.snapToGrid(point.pos)));
      const snappedBBox = Rect2.bboxOf(snappedPoints);
      if (bbox.maxDimension < 32) {
        return null;
      }
      const maxError = Math.min(30, bbox.maxDimension / 4);
      const templates = [
        {
          ...makeLineTemplate(snappedStartPoint, snappedPoints, snappedBBox),
          toleranceMultiplier: 0.5
        },
        makeLineTemplate(startPoint, points, bbox),
        {
          ...makeRectangleTemplate(snappedStartPoint, snappedPoints, snappedBBox),
          toleranceMultiplier: 0.6
        },
        makeRectangleTemplate(startPoint, points, bbox)
      ];
      const selectTemplate = (maximumAllowedError) => {
        for (const template2 of templates) {
          const templatePoints = template2.points;
          const acceptMaximumSquareError = maximumAllowedError * maximumAllowedError * (template2.toleranceMultiplier ?? 1);
          const templateAt = (index) => {
            while (index < 0) {
              index += templatePoints.length;
            }
            index %= templatePoints.length;
            return templatePoints[index];
          };
          let closestToFirst = null;
          let closestToFirstSqrDist = Infinity;
          let templateStartIndex = 0;
          for (let i = 0; i < templatePoints.length; i++) {
            const current = templatePoints[i];
            const currentSqrDist = current.squareDistanceTo(startPoint);
            if (!closestToFirst || currentSqrDist < closestToFirstSqrDist) {
              closestToFirstSqrDist = currentSqrDist;
              closestToFirst = current;
              templateStartIndex = i;
            }
          }
          let maximumSqrError = 0;
          let templateIndex = templateStartIndex;
          for (const point of points) {
            let minimumCurrentSqrError = Infinity;
            let minimumErrorAtIndex = templateIndex;
            const windowRadius = 6;
            for (let i = -windowRadius; i <= windowRadius; i++) {
              const index = templateIndex + i;
              const prevTemplatePoint = templateAt(index - 1);
              const currentTemplatePoint = templateAt(index);
              const nextTemplatePoint = templateAt(index + 1);
              const prevToCurrent = new LineSegment2(prevTemplatePoint, currentTemplatePoint);
              const currentToNext = new LineSegment2(currentTemplatePoint, nextTemplatePoint);
              const prevToCurrentDist = prevToCurrent.distance(point);
              const nextToCurrentDist = currentToNext.distance(point);
              const error = Math.min(prevToCurrentDist, nextToCurrentDist);
              const squareError = error * error;
              if (squareError < minimumCurrentSqrError) {
                minimumCurrentSqrError = squareError;
                minimumErrorAtIndex = index;
              }
            }
            templateIndex = minimumErrorAtIndex;
            maximumSqrError = Math.max(minimumCurrentSqrError, maximumSqrError);
            if (maximumSqrError > acceptMaximumSquareError) {
              break;
            }
          }
          if (maximumSqrError < acceptMaximumSquareError) {
            return templatePoints;
          }
        }
        return null;
      };
      const template = selectTemplate(maxError);
      if (!template) {
        return null;
      }
      const lastDataPoint = this.points[this.points.length - 1];
      const startWidth = this.startPoint.width;
      const endWidth = lastDataPoint.width;
      const startColor = this.startPoint.color;
      const endColor = lastDataPoint.color;
      const startTime = this.startPoint.time;
      const endTime = lastDataPoint.time;
      const templateIndexToStrokeDataPoint = (index) => {
        const prevPoint = template[Math.max(0, Math.floor(index))];
        const nextPoint = template[Math.min(Math.ceil(index), template.length - 1)];
        const point = prevPoint.lerp(nextPoint, index - Math.floor(index));
        const fractionToEnd = index / template.length;
        return {
          pos: this.viewport.screenToCanvas(point),
          width: startWidth * (1 - fractionToEnd) + endWidth * fractionToEnd,
          color: startColor.mix(endColor, fractionToEnd),
          time: startTime * (1 - fractionToEnd) + endTime * fractionToEnd
        };
      };
      const builder = this.sourceFactory(templateIndexToStrokeDataPoint(0), this.viewport);
      const preventSmoothing = template.length < 10;
      for (let i = 0; i < template.length; i++) {
        if (preventSmoothing) {
          builder.addPoint(templateIndexToStrokeDataPoint(i - 1e-3));
        }
        builder.addPoint(templateIndexToStrokeDataPoint(i));
        if (preventSmoothing) {
          builder.addPoint(templateIndexToStrokeDataPoint(i + 1e-3));
        }
      }
      return builder.build();
    }
  };

  // node_modules/js-draw/dist/mjs/components/builders/FreehandLineBuilder.mjs
  var makeFreehandLineBuilder = makeShapeFitAutocorrect_default((initialPoint, viewport) => {
    const maxSmoothingDist = viewport.getSizeOfPixelOnCanvas() * 3;
    const minSmoothingDist = viewport.getSizeOfPixelOnCanvas();
    return new FreehandLineBuilder(initialPoint, minSmoothingDist, maxSmoothingDist, viewport);
  });
  var FreehandLineBuilder = class {
    constructor(startPoint, minFitAllowed, maxFitAllowed, viewport) {
      this.startPoint = startPoint;
      this.minFitAllowed = minFitAllowed;
      this.viewport = viewport;
      this.isFirstSegment = true;
      this.parts = [];
      this.widthAverageNumSamples = 1;
      this.curveFitter = new StrokeSmoother(startPoint, minFitAllowed, maxFitAllowed, (curve) => this.addCurve(curve));
      this.averageWidth = startPoint.width;
      this.bbox = new Rect2(this.startPoint.pos.x, this.startPoint.pos.y, 0, 0);
    }
    getBBox() {
      return this.bbox;
    }
    getRenderingStyle() {
      return {
        fill: Color4.transparent,
        stroke: this.inkTrailStyle()
      };
    }
    inkTrailStyle() {
      return {
        color: this.startPoint.color,
        width: this.roundDistance(this.averageWidth)
      };
    }
    previewCurrentPath() {
      const path = this.parts.slice();
      const commands = [...path, ...this.curveToPathCommands(this.curveFitter.preview())];
      const startPoint = this.startPoint.pos;
      return {
        startPoint,
        commands,
        style: this.getRenderingStyle()
      };
    }
    previewFullPath() {
      const preview = this.previewCurrentPath();
      if (preview) {
        return [preview];
      }
      return null;
    }
    previewStroke() {
      const pathPreview = this.previewFullPath();
      if (pathPreview) {
        return new Stroke(pathPreview);
      }
      return null;
    }
    preview(renderer) {
      const paths = this.previewFullPath();
      if (paths) {
        const approxBBox = this.viewport.visibleRect;
        renderer.startObject(approxBBox);
        for (const path of paths) {
          renderer.drawPath(path);
        }
        renderer.endObject();
      }
    }
    build() {
      this.curveFitter.finalizeCurrentCurve();
      return this.previewStroke();
    }
    getMinFit() {
      let minFit = Math.min(this.minFitAllowed, this.averageWidth / 3);
      if (minFit < 1e-10) {
        minFit = this.minFitAllowed;
      }
      return minFit;
    }
    roundPoint(point) {
      const minFit = this.getMinFit();
      return Viewport_default.roundPoint(point, minFit);
    }
    roundDistance(dist) {
      const minFit = this.getMinFit();
      return Viewport_default.roundPoint(dist, minFit);
    }
    curveToPathCommands(curve) {
      if (!curve) {
        if (!this.isFirstSegment) {
          return [];
        }
        const width = Viewport_default.roundPoint(this.averageWidth / 10, Math.min(this.minFitAllowed, this.averageWidth / 10));
        const center = this.roundPoint(this.startPoint.pos);
        return [
          {
            kind: PathCommandType.QuadraticBezierTo,
            controlPoint: center.plus(Vec2.of(width, width)),
            // Bottom of the circle
            //    |
            //  -----
            //    |
            //    
            endPoint: center.plus(Vec2.of(0, width))
          },
          {
            kind: PathCommandType.QuadraticBezierTo,
            controlPoint: center.plus(Vec2.of(-width, width)),
            endPoint: center.plus(Vec2.of(-width, 0))
          },
          {
            kind: PathCommandType.QuadraticBezierTo,
            controlPoint: center.plus(Vec2.of(-width, -width)),
            endPoint: center.plus(Vec2.of(0, -width))
          },
          {
            kind: PathCommandType.QuadraticBezierTo,
            controlPoint: center.plus(Vec2.of(width, -width)),
            endPoint: center.plus(Vec2.of(width, 0))
          }
        ];
      }
      const result = [];
      if (this.isFirstSegment) {
        result.push({
          kind: PathCommandType.MoveTo,
          point: this.roundPoint(curve.startPoint)
        });
      }
      result.push({
        kind: PathCommandType.QuadraticBezierTo,
        controlPoint: this.roundPoint(curve.controlPoint),
        endPoint: this.roundPoint(curve.endPoint)
      });
      return result;
    }
    addCurve(curve) {
      const parts = this.curveToPathCommands(curve);
      this.parts.push(...parts);
      if (this.isFirstSegment) {
        this.isFirstSegment = false;
      }
    }
    addPoint(newPoint) {
      this.curveFitter.addPoint(newPoint);
      this.widthAverageNumSamples++;
      this.averageWidth = this.averageWidth * (this.widthAverageNumSamples - 1) / this.widthAverageNumSamples + newPoint.width / this.widthAverageNumSamples;
    }
  };

  // node_modules/js-draw/dist/mjs/tools/InputFilter/InputMapper.mjs
  var __classPrivateFieldSet6 = function(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var __classPrivateFieldGet6 = function(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var _InputMapper_listener;
  var InputMapper = class {
    constructor() {
      _InputMapper_listener.set(this, null);
    }
    // @internal
    setEmitListener(listener) {
      if (listener && typeof listener === "object") {
        __classPrivateFieldSet6(this, _InputMapper_listener, (event) => {
          return listener.onEvent(event) ?? false;
        }, "f");
      } else {
        __classPrivateFieldSet6(this, _InputMapper_listener, listener, "f");
      }
    }
    emit(event) {
      return __classPrivateFieldGet6(this, _InputMapper_listener, "f")?.call(this, event) ?? false;
    }
  };
  _InputMapper_listener = /* @__PURE__ */ new WeakMap();
  var InputMapper_default = InputMapper;

  // node_modules/js-draw/dist/mjs/tools/InputFilter/InputStabilizer.mjs
  var StabilizerType;
  (function(StabilizerType2) {
    StabilizerType2[StabilizerType2["IntertialStabilizer"] = 0] = "IntertialStabilizer";
  })(StabilizerType || (StabilizerType = {}));
  var defaultOptions = {
    kind: StabilizerType.IntertialStabilizer,
    mass: 0.4,
    // kg
    springConstant: 100,
    // N/m
    frictionCoefficient: 0.28,
    maxPointDist: 10,
    // screen units
    inertiaFraction: 0.75,
    minSimilarityToFinalize: 0,
    velocityDecayFactor: 0.1
  };
  var StylusInputStabilizer = class {
    constructor(start, updatePointer, options) {
      this.updatePointer = updatePointer;
      this.options = options;
      this.runLoop = true;
      this.lastUpdateTime = 0;
      this.velocity = Vec2.zero;
      this.strokePoint = start;
      this.targetPoint = start;
      this.targetInterval = 10;
      void this.loop();
    }
    async loop() {
      this.lastUpdateTime = performance.now();
      while (this.runLoop) {
        this.update(false);
        await untilNextAnimationFrame_default();
      }
    }
    setTarget(point) {
      this.targetPoint = point;
    }
    getNextVelocity(deltaTimeMs) {
      const toTarget = this.targetPoint.minus(this.strokePoint);
      const springForce = toTarget.times(this.options.springConstant);
      const gravityAccel = 10;
      const normalForceMagnitude = this.options.mass * gravityAccel;
      const frictionForce = this.velocity.normalizedOrZero().times(-this.options.frictionCoefficient * normalForceMagnitude);
      const acceleration = springForce.plus(frictionForce).times(1 / this.options.mass);
      const decayFactor = this.options.velocityDecayFactor;
      const springVelocity = this.velocity.times(1 - decayFactor).plus(acceleration.times(deltaTimeMs / 1e3));
      const toTargetVelocity = toTarget.normalizedOrZero().times(springVelocity.length());
      return toTargetVelocity.lerp(springVelocity, this.options.inertiaFraction);
    }
    update(force) {
      const nowTime = performance.now();
      const deltaTime = nowTime - this.lastUpdateTime;
      const reachedTarget = this.strokePoint.eq(this.targetPoint);
      if (deltaTime > this.targetInterval || force) {
        if (!reachedTarget) {
          let velocity;
          let deltaX;
          let parts = 1;
          do {
            velocity = this.getNextVelocity(deltaTime / parts);
            deltaX = velocity.times(deltaTime / 1e3);
            parts++;
          } while (deltaX.magnitude() > this.options.maxPointDist && parts < 10);
          for (let i = 0; i < parts; i++) {
            this.velocity = this.getNextVelocity(deltaTime / parts);
            deltaX = this.velocity.times(deltaTime / 1e3);
            this.strokePoint = this.strokePoint.plus(deltaX);
            if (i < parts - 1) {
              this.updatePointer(this.strokePoint, nowTime);
            }
          }
        }
        this.lastUpdateTime = nowTime;
        if (force || !reachedTarget) {
          return this.updatePointer(this.strokePoint, nowTime);
        }
      }
      return false;
    }
    /** Finalizes the current stroke. */
    finish() {
      this.runLoop = false;
      const toTarget = this.targetPoint.minus(this.strokePoint);
      if (this.velocity.dot(toTarget) > this.options.minSimilarityToFinalize) {
        this.updatePointer(this.targetPoint, performance.now());
      }
    }
    cancel() {
      this.runLoop = false;
    }
  };
  var InputStabilizer = class _InputStabilizer extends InputMapper_default {
    constructor(viewport, options = defaultOptions) {
      super();
      this.viewport = viewport;
      this.options = options;
      this.stabilizer = null;
      this.lastPointerEvent = null;
    }
    mapPointerEvent(event) {
      if (isPointerEvt(event) && event.kind !== InputEvtType.PointerUpEvt) {
        this.lastPointerEvent = event;
      }
      if (event.kind === InputEvtType.GestureCancelEvt || event.allPointers.length > 1 || this.stabilizer === null) {
        return this.emit(event);
      }
      this.stabilizer.setTarget(event.current.screenPos);
      if (event.kind === InputEvtType.PointerMoveEvt) {
        return this.stabilizer.update(true);
      } else if (event.kind === InputEvtType.PointerUpEvt) {
        this.stabilizer.finish();
        return this.emit(event);
      } else {
        return this.emit(event);
      }
    }
    // Assumes that there is exactly one pointer that is currently down.
    emitPointerMove(screenPoint, timeStamp) {
      if (!this.lastPointerEvent) {
        return false;
      }
      const pointer = this.lastPointerEvent.current.withScreenPosition(screenPoint, this.viewport).withTimestamp(timeStamp);
      const event = {
        kind: InputEvtType.PointerMoveEvt,
        current: pointer,
        allPointers: [pointer]
      };
      const handled = this.emit(event);
      return handled;
    }
    onEvent(event) {
      if (isPointerEvt(event) || event.kind === InputEvtType.GestureCancelEvt) {
        if (event.kind === InputEvtType.PointerDownEvt) {
          if (event.allPointers.length > 1) {
            this.stabilizer?.cancel();
            this.stabilizer = null;
          } else {
            this.stabilizer?.cancel();
            this.stabilizer = new StylusInputStabilizer(event.current.screenPos, (screenPoint, timeStamp) => this.emitPointerMove(screenPoint, timeStamp), this.options);
          }
        }
        const handled = this.mapPointerEvent(event);
        if (event.kind === InputEvtType.PointerUpEvt || event.kind === InputEvtType.GestureCancelEvt) {
          this.stabilizer?.cancel();
          this.stabilizer = null;
        }
        return handled;
      }
      return this.emit(event);
    }
    static fromEditor(editor) {
      return new _InputStabilizer(editor.viewport);
    }
  };

  // node_modules/js-draw/dist/mjs/tools/util/StationaryPenDetector.mjs
  var defaultStationaryDetectionConfig = {
    maxSpeed: 8.5,
    // screenPx/s
    maxRadius: 11,
    // screenPx
    minTimeSeconds: 0.5
    // s
  };
  var StationaryPenDetector = class {
    // Only handles one pen. As such, `startPointer` should be the same device/finger
    // as `updatedPointer` in `onPointerMove`.
    //
    // A new `StationaryPenDetector` should be created for each gesture.
    constructor(startPointer, config, onStationary) {
      this.config = config;
      this.onStationary = onStationary;
      this.timeout = null;
      this.stationaryStartPointer = startPointer;
      this.lastPointer = startPointer;
      this.averageVelocity = Vec2.zero;
      this.setStationaryTimeout(this.config.minTimeSeconds * 1e3);
    }
    // Returns true if stationary
    onPointerMove(currentPointer) {
      if (!this.stationaryStartPointer) {
        return;
      }
      if (currentPointer.id !== this.stationaryStartPointer.id) {
        return false;
      }
      const dxFromLast = currentPointer.screenPos.minus(this.lastPointer.screenPos);
      const dxFromStationaryStart = currentPointer.screenPos.minus(this.stationaryStartPointer.screenPos);
      let dtFromLast = (currentPointer.timeStamp - this.lastPointer.timeStamp) / 1e3;
      if (dtFromLast === 0) {
        dtFromLast = 1;
      }
      const currentVelocity = dxFromLast.times(1 / dtFromLast);
      this.averageVelocity = this.averageVelocity.lerp(currentVelocity, 0.5);
      const dtFromStart = currentPointer.timeStamp - this.stationaryStartPointer.timeStamp;
      const movedOutOfRadius = dxFromStationaryStart.length() > this.config.maxRadius;
      this.hasMovedOutOfRadius ||= movedOutOfRadius;
      if (movedOutOfRadius || this.averageVelocity.length() > this.config.maxSpeed || dtFromStart < this.config.minTimeSeconds) {
        this.stationaryStartPointer = currentPointer;
        this.lastPointer = currentPointer;
        this.setStationaryTimeout(this.config.minTimeSeconds * 1e3);
        return false;
      }
      const stationaryTimeoutMs = this.config.minTimeSeconds * 1e3 - dtFromStart;
      this.lastPointer = currentPointer;
      return stationaryTimeoutMs <= 0;
    }
    onPointerUp(pointer) {
      if (pointer.id !== this.stationaryStartPointer?.id) {
        this.cancelStationaryTimeout();
      }
    }
    destroy() {
      this.cancelStationaryTimeout();
      this.stationaryStartPointer = null;
    }
    getHasMovedOutOfRadius() {
      return this.hasMovedOutOfRadius;
    }
    cancelStationaryTimeout() {
      if (this.timeout !== null) {
        clearTimeout(this.timeout);
        this.timeout = null;
      }
    }
    setStationaryTimeout(timeoutMs) {
      if (this.timeout !== null) {
        return;
      }
      if (timeoutMs <= 0) {
        this.onStationary(this.lastPointer);
      } else {
        this.timeout = setTimeout(() => {
          this.timeout = null;
          if (!this.stationaryStartPointer) {
            return;
          }
          const timeSinceStationaryStart = performance.now() - this.stationaryStartPointer.timeStamp;
          const timeRemaining = this.config.minTimeSeconds * 1e3 - timeSinceStationaryStart;
          if (timeRemaining <= 0) {
            this.onStationary(this.lastPointer);
          } else {
            this.setStationaryTimeout(timeRemaining);
          }
        }, timeoutMs);
      }
    }
  };

  // node_modules/js-draw/dist/mjs/tools/Pen.mjs
  var Pen = class extends BaseTool_default {
    constructor(editor, description, style) {
      super(editor.notifier, description);
      this.editor = editor;
      this.builder = null;
      this.lastPoint = null;
      this.startPoint = null;
      this.currentDeviceType = null;
      this.currentPointerId = null;
      this.shapeAutocompletionEnabled = false;
      this.pressureSensitivityEnabled = true;
      this.autocorrectedShape = null;
      this.lastAutocorrectedShape = null;
      this.removedAutocorrectedShapeTime = 0;
      this.stationaryDetector = null;
      this.styleValue = ReactiveValue.fromInitialValue({
        factory: makeFreehandLineBuilder,
        color: Color4.blue,
        thickness: 4,
        ...style
      });
      this.styleValue.onUpdateAndNow((newValue) => {
        this.style = newValue;
        this.noteUpdated();
      });
      this.wetInkRenderer = this.editor.display.getWetInkRenderer();
    }
    getPressureMultiplier() {
      const thickness = this.style.thickness;
      return 1 / this.editor.viewport.getScaleFactor() * thickness;
    }
    // Converts a `pointer` to a `StrokeDataPoint`.
    toStrokePoint(pointer) {
      const minPressure = 0.3;
      const defaultPressure = 0.5;
      let pressure = Math.max(pointer.pressure ?? 1, minPressure);
      if (!isFinite(pressure)) {
        console.warn("Non-finite pressure!", pointer);
        pressure = minPressure;
      }
      console.assert(isFinite(pointer.canvasPos.length()), "Non-finite canvas position!");
      console.assert(isFinite(pointer.screenPos.length()), "Non-finite screen position!");
      console.assert(isFinite(pointer.timeStamp), "Non-finite timeStamp on pointer!");
      const pos = pointer.canvasPos;
      if (!this.getPressureSensitivityEnabled()) {
        pressure = defaultPressure;
      }
      return {
        pos,
        width: pressure * this.getPressureMultiplier(),
        color: this.style.color,
        time: pointer.timeStamp
      };
    }
    // Displays the stroke that is currently being built with the display's `wetInkRenderer`.
    previewStroke() {
      this.editor.clearWetInk();
      if (this.autocorrectedShape) {
        const visibleRect = this.editor.viewport.visibleRect;
        this.autocorrectedShape.render(this.wetInkRenderer, visibleRect);
      } else if (this.builder) {
        this.builder.preview(this.wetInkRenderer);
        if (this.builder.inkTrailStyle) {
          const trailStyle = this.builder.inkTrailStyle();
          const draftInkPresenter = this.wetInkRenderer.getDraftInkPresenter();
          draftInkPresenter.updateStyle(trailStyle);
        }
      }
    }
    // Throws if no stroke builder exists.
    addPointToStroke(point) {
      if (!this.builder) {
        throw new Error("No stroke is currently being generated.");
      }
      this.builder.addPoint(point);
      this.lastPoint = point;
      this.previewStroke();
    }
    onPointerDown(event) {
      if (this.builder && !this.eventCanCancelStroke(event)) {
        return true;
      }
      const { current, allPointers } = event;
      const isEraser = current.device === PointerDevice.Eraser;
      const isPen = current.device === PointerDevice.Pen;
      if (allPointers.length === 1 && !isEraser || isPen) {
        this.startPoint = this.toStrokePoint(current);
        this.builder = this.style.factory(this.startPoint, this.editor.viewport);
        this.currentDeviceType = current.device;
        this.currentPointerId = current.id;
        if (this.shapeAutocompletionEnabled) {
          this.stationaryDetector = new StationaryPenDetector(current, defaultStationaryDetectionConfig, (pointer) => this.autocorrectShape(pointer));
        } else {
          this.stationaryDetector = null;
        }
        this.lastAutocorrectedShape = null;
        this.removedAutocorrectedShapeTime = 0;
        if (this.builder.inkTrailStyle) {
          this.wetInkRenderer.getDraftInkPresenter().setEnabled(current.id, true);
        }
        return true;
      }
      return false;
    }
    eventCanCancelStroke(event) {
      const lastInputTime = this.lastPoint?.time ?? 0;
      if (event.current.timeStamp - lastInputTime > 1e3) {
        return true;
      }
      const isPenStroke = this.currentDeviceType === PointerDevice.Pen;
      const isTouchEvent = event.current.device === PointerDevice.Touch;
      if (isPenStroke && isTouchEvent) {
        return false;
      }
      return true;
    }
    eventCanBeDeliveredToNonActiveTool(event) {
      return this.eventCanCancelStroke(event);
    }
    onPointerMove({ current }) {
      if (!this.builder)
        return;
      if (current.device !== this.currentDeviceType)
        return;
      if (current.id !== this.currentPointerId)
        return;
      const isStationary = this.stationaryDetector?.onPointerMove(current);
      if (!isStationary) {
        this.addPointToStroke(this.toStrokePoint(current));
        if (this.autocorrectedShape) {
          this.removedAutocorrectedShapeTime = performance.now();
          this.autocorrectedShape = null;
          this.editor.announceForAccessibility(this.editor.localization.autocorrectionCanceled);
        }
      }
    }
    onPointerUp({ current }) {
      if (!this.builder)
        return false;
      if (current.id !== this.currentPointerId) {
        return true;
      }
      this.stationaryDetector?.onPointerUp(current);
      const currentPoint = this.toStrokePoint(current);
      const strokePoint = {
        ...currentPoint,
        width: this.lastPoint?.width ?? currentPoint.width
      };
      this.addPointToStroke(strokePoint);
      this.finalizeStroke();
      return false;
    }
    postGestureCleanup() {
      if (this.currentPointerId !== null) {
        this.wetInkRenderer.getDraftInkPresenter().setEnabled(this.currentPointerId, false);
      }
      this.builder = null;
      this.lastPoint = null;
      this.autocorrectedShape = null;
      this.lastAutocorrectedShape = null;
      this.editor.clearWetInk();
      this.stationaryDetector?.destroy();
      this.stationaryDetector = null;
    }
    onGestureCancel() {
      this.postGestureCleanup();
    }
    removedAutocorrectedShapeRecently() {
      return this.removedAutocorrectedShapeTime > performance.now() - 320;
    }
    async autocorrectShape(_lastPointer) {
      if (!this.builder || !this.builder.autocorrectShape)
        return;
      if (!this.shapeAutocompletionEnabled)
        return;
      if (this.autocorrectedShape)
        return;
      const correctedShape = await this.builder.autocorrectShape();
      if (!this.builder || !correctedShape) {
        return;
      }
      const bboxArea = correctedShape.getBBox().area;
      if (bboxArea === 0 || !isFinite(bboxArea)) {
        return;
      }
      const shapeDescription = correctedShape.description(this.editor.localization);
      this.editor.announceForAccessibility(this.editor.localization.autocorrectedTo(shapeDescription));
      this.autocorrectedShape = correctedShape;
      this.lastAutocorrectedShape = correctedShape;
      this.previewStroke();
    }
    finalizeStroke() {
      if (this.builder) {
        if (this.lastAutocorrectedShape && this.removedAutocorrectedShapeRecently()) {
          this.autocorrectedShape = this.lastAutocorrectedShape;
        }
        const stroke = this.autocorrectedShape ?? this.builder.build();
        this.previewStroke();
        if (stroke.getBBox().area > 0) {
          if (stroke === this.autocorrectedShape) {
            this.editor.announceForAccessibility(this.editor.localization.autocorrectedTo(stroke.description(this.editor.localization)));
          }
          const canFlatten = true;
          const action = EditorImage_default.addComponent(stroke, canFlatten);
          this.editor.dispatch(action);
        } else {
          console.warn("Pen: Not adding empty stroke", stroke, "to the canvas.");
        }
      }
      this.postGestureCleanup();
    }
    noteUpdated() {
      this.editor.notifier.dispatch(EditorEventType.ToolUpdated, {
        kind: EditorEventType.ToolUpdated,
        tool: this
      });
    }
    setColor(color) {
      if (color.toHexString() !== this.style.color.toHexString()) {
        this.styleValue.set({
          ...this.style,
          color
        });
      }
    }
    setThickness(thickness) {
      if (thickness !== this.style.thickness) {
        this.styleValue.set({
          ...this.style,
          thickness
        });
      }
    }
    /**
     * Changes the type of stroke created by the pen. The given `factory` can be one of the built-in
     * stroke factories (e.g. {@link makeFreehandLineBuilder}) or a custom stroke factory.
     *
     * Example:
     * [[include:doc-pages/inline-examples/changing-pen-types.md]]
     */
    setStrokeFactory(factory) {
      if (factory !== this.style.factory) {
        this.styleValue.set({
          ...this.style,
          factory
        });
      }
    }
    setHasStabilization(hasStabilization) {
      const hasInputMapper = !!this.getInputMapper();
      if (hasStabilization === hasInputMapper) {
        return;
      }
      if (hasInputMapper) {
        this.setInputMapper(null);
      } else {
        this.setInputMapper(new InputStabilizer(this.editor.viewport));
      }
      this.noteUpdated();
    }
    setStrokeAutocorrectEnabled(enabled) {
      if (enabled !== this.shapeAutocompletionEnabled) {
        this.shapeAutocompletionEnabled = enabled;
        this.noteUpdated();
      }
    }
    getStrokeAutocorrectionEnabled() {
      return this.shapeAutocompletionEnabled;
    }
    setPressureSensitivityEnabled(enabled) {
      if (enabled !== this.pressureSensitivityEnabled) {
        this.pressureSensitivityEnabled = enabled;
        this.noteUpdated();
      }
    }
    getPressureSensitivityEnabled() {
      return this.pressureSensitivityEnabled;
    }
    getThickness() {
      return this.style.thickness;
    }
    getColor() {
      return this.style.color;
    }
    getStrokeFactory() {
      return this.style.factory;
    }
    getStyleValue() {
      return this.styleValue;
    }
    onKeyPress(event) {
      const shortcuts = this.editor.shortcuts;
      const isCtrlZ = shortcuts.matchesShortcut(undoKeyboardShortcutId, event);
      if (this.builder && isCtrlZ) {
        this.finalizeStroke();
        return false;
      }
      let newThickness;
      if (shortcuts.matchesShortcut(decreaseSizeKeyboardShortcutId, event)) {
        newThickness = this.getThickness() * 2 / 3;
      } else if (shortcuts.matchesShortcut(increaseSizeKeyboardShortcutId, event)) {
        newThickness = this.getThickness() * 3 / 2;
      }
      if (newThickness !== void 0) {
        newThickness = Math.min(Math.max(1, newThickness), 256);
        this.setThickness(newThickness);
        return true;
      }
      return false;
    }
  };

  // node_modules/js-draw/dist/mjs/tools/ToolEnabledGroup.mjs
  var ToolEnabledGroup = class {
    constructor() {
    }
    notifyEnabled(tool) {
      if (tool !== this.activeTool) {
        this.activeTool?.setEnabled(false);
        this.activeTool = tool;
      }
    }
  };

  // node_modules/js-draw/dist/mjs/components/util/describeComponentList.mjs
  var describeComponentList_default = (localizationTable, elems) => {
    if (elems.length === 0) {
      return null;
    }
    const description = elems[0].description(localizationTable);
    for (const elem of elems) {
      if (elem.description(localizationTable) !== description) {
        return null;
      }
    }
    return description;
  };

  // node_modules/js-draw/dist/mjs/commands/Erase.mjs
  var Erase = class extends SerializableCommand_default {
    constructor(toRemove) {
      super("erase");
      this.toRemove = toRemove.map((elem) => elem);
      this.applied = false;
    }
    apply(editor) {
      for (const part of this.toRemove) {
        const parent = editor.image.findParent(part);
        if (parent) {
          parent.remove();
          editor.image.onDestroyElement(part);
        }
      }
      this.applied = true;
      editor.queueRerender();
    }
    unapply(editor) {
      for (const part of this.toRemove) {
        if (!editor.image.findParent(part)) {
          EditorImage_default.addComponent(part).apply(editor);
        }
      }
      this.applied = false;
      editor.queueRerender();
    }
    onDrop(editor) {
      if (this.applied) {
        for (const part of this.toRemove) {
          editor.image.onDestroyElement(part);
        }
      }
    }
    description(_editor, localizationTable) {
      if (this.toRemove.length === 0) {
        return localizationTable.erasedNoElements;
      }
      const description = describeComponentList_default(localizationTable, this.toRemove) ?? localizationTable.elements;
      return localizationTable.eraseAction(description, this.toRemove.length);
    }
    serializeToJSON() {
      const elems = this.toRemove.map((elem) => elem.serialize());
      return elems;
    }
  };
  (() => {
    SerializableCommand_default.register("erase", (json, editor) => {
      if (!Array.isArray(json)) {
        throw new Error("seralized erase data must be an array");
      }
      const elems = json.map((elemData) => {
        const componentId2 = typeof elemData === "string" ? elemData : `${elemData.id}`;
        const component = editor.image.lookupElement(componentId2) ?? AbstractComponent_default.deserialize(elemData);
        return component;
      });
      return new Erase(elems);
    });
  })();
  var Erase_default = Erase;

  // node_modules/js-draw/dist/mjs/util/waitForAll.mjs
  var waitForAll = (results) => {
    if (results.some((command) => command && command["then"])) {
      return Promise.all(results).then(() => {
      });
    }
    return;
  };
  var waitForAll_default = waitForAll;

  // node_modules/js-draw/dist/mjs/commands/uniteCommands.mjs
  var NonSerializableUnion = class extends Command_default {
    constructor(commands, applyChunkSize, descriptionOverride) {
      super();
      this.commands = commands;
      this.applyChunkSize = applyChunkSize;
      this.descriptionOverride = descriptionOverride;
    }
    apply(editor) {
      if (this.applyChunkSize === void 0) {
        const results = this.commands.map((cmd) => cmd.apply(editor));
        return waitForAll_default(results);
      } else {
        return editor.asyncApplyCommands(this.commands, this.applyChunkSize);
      }
    }
    unapply(editor) {
      const commands = [...this.commands];
      commands.reverse();
      if (this.applyChunkSize === void 0) {
        const results = commands.map((cmd) => cmd.unapply(editor));
        return waitForAll_default(results);
      } else {
        return editor.asyncUnapplyCommands(commands, this.applyChunkSize, false);
      }
    }
    onDrop(editor) {
      this.commands.forEach((command) => command.onDrop(editor));
    }
    description(editor, localizationTable) {
      if (this.descriptionOverride) {
        return this.descriptionOverride;
      }
      const descriptions = [];
      let lastDescription = null;
      let duplicateDescriptionCount = 0;
      let handledCommandCount = 0;
      for (const part of this.commands) {
        const description = part.description(editor, localizationTable);
        if (description !== lastDescription && lastDescription !== null) {
          descriptions.push(localizationTable.unionOf(lastDescription, duplicateDescriptionCount));
          lastDescription = null;
          duplicateDescriptionCount = 0;
        }
        duplicateDescriptionCount++;
        handledCommandCount++;
        lastDescription ??= description;
        const maxDescriptionLength = 12;
        if (descriptions.length > maxDescriptionLength) {
          break;
        }
      }
      if (duplicateDescriptionCount > 1) {
        descriptions.push(localizationTable.unionOf(lastDescription, duplicateDescriptionCount));
      } else if (duplicateDescriptionCount === 1) {
        descriptions.push(lastDescription);
      }
      if (handledCommandCount < this.commands.length) {
        descriptions.push(localizationTable.andNMoreCommands(this.commands.length - handledCommandCount));
      }
      return descriptions.join(", ");
    }
  };
  var SerializableUnion = class extends SerializableCommand_default {
    constructor(commands, applyChunkSize, descriptionOverride) {
      super("union");
      this.commands = commands;
      this.applyChunkSize = applyChunkSize;
      this.descriptionOverride = descriptionOverride;
      this.nonserializableCommand = new NonSerializableUnion(commands, applyChunkSize, descriptionOverride);
    }
    serializeToJSON() {
      if (this.serializedData) {
        return this.serializedData;
      }
      return {
        applyChunkSize: this.applyChunkSize,
        data: this.commands.map((command) => command.serialize()),
        description: this.descriptionOverride
      };
    }
    apply(editor) {
      this.serializedData = this.serializeToJSON();
      return this.nonserializableCommand.apply(editor);
    }
    unapply(editor) {
      return this.nonserializableCommand.unapply(editor);
    }
    onDrop(editor) {
      this.nonserializableCommand.onDrop(editor);
    }
    description(editor, localizationTable) {
      return this.nonserializableCommand.description(editor, localizationTable);
    }
  };
  var uniteCommands = (commands, options) => {
    let allSerializable = true;
    for (const command of commands) {
      if (!(command instanceof SerializableCommand_default)) {
        allSerializable = false;
        break;
      }
    }
    let applyChunkSize;
    let description;
    if (typeof options === "number") {
      applyChunkSize = options;
    } else {
      applyChunkSize = options?.applyChunkSize;
      description = options?.description;
    }
    if (!allSerializable) {
      return new NonSerializableUnion(commands, applyChunkSize, description);
    } else {
      const castedCommands = commands;
      return new SerializableUnion(castedCommands, applyChunkSize, description);
    }
  };
  SerializableCommand_default.register("union", (data, editor) => {
    if (typeof data.data.length !== "number") {
      throw new Error("Unions of commands must serialize to lists of serialization data.");
    }
    const applyChunkSize = data.applyChunkSize;
    if (typeof applyChunkSize !== "number" && applyChunkSize !== void 0) {
      throw new Error("serialized applyChunkSize is neither undefined nor a number.");
    }
    const description = typeof data.description === "string" ? data.description : void 0;
    const commands = [];
    for (const part of data.data) {
      commands.push(SerializableCommand_default.deserialize(part, editor));
    }
    return uniteCommands(commands, { applyChunkSize, description });
  });
  var uniteCommands_default = uniteCommands;

  // node_modules/js-draw/dist/mjs/tools/Eraser.mjs
  var EraserMode;
  (function(EraserMode2) {
    EraserMode2["PartialStroke"] = "partial-stroke";
    EraserMode2["FullStroke"] = "full-stroke";
  })(EraserMode || (EraserMode = {}));
  var EraserSwitcher = class extends BaseTool_default {
    constructor(editor, eraser) {
      super(editor.notifier, editor.localization.changeTool);
      this.editor = editor;
      this.eraser = eraser;
    }
    onPointerDown(event) {
      if (event.allPointers.length === 1 && event.current.device === PointerDevice.Eraser) {
        const toolController = this.editor.toolController;
        const enabledPrimaryTools = toolController.getPrimaryTools().filter((tool) => tool.isEnabled());
        if (enabledPrimaryTools.length) {
          this.previousEnabledTool = enabledPrimaryTools[0];
        } else {
          this.previousEnabledTool = null;
        }
        this.previousEraserEnabledState = this.eraser.isEnabled();
        this.eraser.setEnabled(true);
        if (this.eraser.onPointerDown(event)) {
          return true;
        } else {
          this.restoreOriginalTool();
        }
      }
      return false;
    }
    onPointerMove(event) {
      this.eraser.onPointerMove(event);
    }
    restoreOriginalTool() {
      this.eraser.setEnabled(this.previousEraserEnabledState);
      if (this.previousEnabledTool) {
        this.previousEnabledTool.setEnabled(true);
      }
    }
    onPointerUp(event) {
      this.eraser.onPointerUp(event);
      this.restoreOriginalTool();
    }
    onGestureCancel(event) {
      this.eraser.onGestureCancel(event);
      this.restoreOriginalTool();
    }
  };
  var Eraser = class extends BaseTool_default {
    constructor(editor, description, options) {
      super(editor.notifier, description);
      this.editor = editor;
      this.lastPoint = null;
      this.isFirstEraseEvt = true;
      this.toAdd = /* @__PURE__ */ new Set();
      this.eraseCommands = [];
      this.addCommands = [];
      this.thickness = options?.thickness ?? 10;
      this.thicknessValue = ReactiveValue.fromInitialValue(this.thickness);
      this.thicknessValue.onUpdate((value) => {
        this.thickness = value;
        this.editor.notifier.dispatch(EditorEventType.ToolUpdated, {
          kind: EditorEventType.ToolUpdated,
          tool: this
        });
      });
      this.modeValue = ReactiveValue.fromInitialValue(options?.mode ?? EraserMode.FullStroke);
      this.modeValue.onUpdate((_value) => {
        this.editor.notifier.dispatch(EditorEventType.ToolUpdated, {
          kind: EditorEventType.ToolUpdated,
          tool: this
        });
      });
    }
    /**
     * @returns a tool that briefly enables the eraser when a physical eraser is used.
     * This tool should be added to the tool list after the primary tools.
     */
    makeEraserSwitcherTool() {
      return new EraserSwitcher(this.editor, this);
    }
    clearPreview() {
      this.editor.clearWetInk();
    }
    getSizeOnCanvas() {
      return this.thickness / this.editor.viewport.getScaleFactor();
    }
    drawPreviewAt(point) {
      this.clearPreview();
      const size = this.getSizeOnCanvas();
      const renderer = this.editor.display.getWetInkRenderer();
      const rect = this.getEraserRect(point);
      const rect2 = this.getEraserRect(this.lastPoint ?? point);
      const fill = {
        fill: Color4.transparent,
        stroke: { width: size / 10, color: Color4.gray }
      };
      renderer.drawPath(pathToRenderable(Path.fromConvexHullOf([...rect.corners, ...rect2.corners]), fill));
    }
    /**
     * @returns the eraser rectangle in canvas coordinates.
     *
     * For now, all erasers are rectangles or points.
     */
    getEraserRect(centerPoint) {
      const size = this.getSizeOnCanvas();
      const halfSize = Vec2.of(size / 2, size / 2);
      return Rect2.fromCorners(centerPoint.minus(halfSize), centerPoint.plus(halfSize));
    }
    /** Erases in a line from the last point to the current. */
    eraseTo(currentPoint) {
      if (!this.isFirstEraseEvt && currentPoint.distanceTo(this.lastPoint) === 0) {
        return;
      }
      this.isFirstEraseEvt = false;
      const eraserRect = this.getEraserRect(currentPoint);
      const line = new LineSegment2(this.lastPoint, currentPoint);
      const region = Rect2.union(line.bbox, eraserRect);
      const intersectingElems = this.editor.image.getComponentsIntersecting(region).filter((component) => {
        return component.intersects(line) || component.intersectsRect(eraserRect);
      });
      const eraseableElems = intersectingElems.filter((elem) => elem.isSelectable());
      if (this.modeValue.get() === EraserMode.FullStroke) {
        this.toRemove.push(...eraseableElems);
        const newPartialCommands = eraseableElems.map((elem) => new Erase_default([elem]));
        newPartialCommands.forEach((cmd) => cmd.apply(this.editor));
        this.eraseCommands.push(...newPartialCommands);
      } else {
        const toErase = [];
        const toAdd = [];
        for (const targetElem of eraseableElems) {
          toErase.push(targetElem);
          if (!targetElem.withRegionErased) {
            continue;
          }
          const grownRect = eraserRect.grownBy(eraserRect.maxDimension / 3);
          if (grownRect.containsRect(targetElem.getExactBBox())) {
            continue;
          }
          const erasePath = Path.fromConvexHullOf([
            ...eraserRect.corners,
            ...this.getEraserRect(this.lastPoint ?? currentPoint).corners
          ].map((p) => this.editor.viewport.roundPoint(p)));
          toAdd.push(...targetElem.withRegionErased(erasePath, this.editor.viewport));
        }
        const eraseCommand = new Erase_default(toErase);
        const newAddCommands = toAdd.map((elem) => EditorImage_default.addComponent(elem));
        eraseCommand.apply(this.editor);
        newAddCommands.forEach((command) => command.apply(this.editor));
        const finalToErase = [];
        for (const item of toErase) {
          if (this.toAdd.has(item)) {
            this.toAdd.delete(item);
          } else {
            finalToErase.push(item);
          }
        }
        this.toRemove.push(...finalToErase);
        for (const item of toAdd) {
          this.toAdd.add(item);
        }
        this.eraseCommands.push(new Erase_default(finalToErase));
        this.addCommands.push(...newAddCommands);
      }
      this.drawPreviewAt(currentPoint);
      this.lastPoint = currentPoint;
    }
    onPointerDown(event) {
      if (event.allPointers.length === 1 || event.current.device === PointerDevice.Eraser) {
        this.lastPoint = event.current.canvasPos;
        this.toRemove = [];
        this.toAdd.clear();
        this.isFirstEraseEvt = true;
        this.drawPreviewAt(event.current.canvasPos);
        return true;
      }
      return false;
    }
    onPointerMove(event) {
      const currentPoint = event.current.canvasPos;
      this.eraseTo(currentPoint);
    }
    onPointerUp(event) {
      this.eraseTo(event.current.canvasPos);
      const commands = [];
      if (this.addCommands.length > 0) {
        this.addCommands.forEach((cmd) => cmd.unapply(this.editor));
        for (const item of this.toAdd) {
          if (this.toRemove.includes(item)) {
            this.toAdd.delete(item);
            this.toRemove = this.toRemove.filter((other) => other !== item);
          }
        }
        for (const item of this.toRemove) {
          if (this.toAdd.has(item)) {
            this.toAdd.delete(item);
            this.toRemove = this.toRemove.filter((other) => other !== item);
          }
        }
        commands.push(...[...this.toAdd].map((a) => EditorImage_default.addComponent(a)));
        this.addCommands = [];
      }
      if (this.eraseCommands.length > 0) {
        this.eraseCommands.forEach((cmd) => cmd.unapply(this.editor));
        this.eraseCommands = [];
        const command = new Erase_default(this.toRemove);
        commands.push(command);
      }
      if (commands.length === 1) {
        this.editor.dispatch(commands[0]);
      } else {
        this.editor.dispatch(uniteCommands_default(commands));
      }
      this.clearPreview();
    }
    onGestureCancel(_event) {
      this.addCommands.forEach((cmd) => cmd.unapply(this.editor));
      this.eraseCommands.forEach((cmd) => cmd.unapply(this.editor));
      this.eraseCommands = [];
      this.addCommands = [];
      this.clearPreview();
    }
    onKeyPress(event) {
      const shortcuts = this.editor.shortcuts;
      let newThickness;
      if (shortcuts.matchesShortcut(decreaseSizeKeyboardShortcutId, event)) {
        newThickness = this.getThickness() * 2 / 3;
      } else if (shortcuts.matchesShortcut(increaseSizeKeyboardShortcutId, event)) {
        newThickness = this.getThickness() * 3 / 2;
      }
      if (newThickness !== void 0) {
        newThickness = Math.min(Math.max(1, newThickness), 200);
        this.setThickness(newThickness);
        return true;
      }
      return false;
    }
    /** Returns the side-length of the tip of this eraser. */
    getThickness() {
      return this.thickness;
    }
    /** Sets the side-length of this' tip. */
    setThickness(thickness) {
      this.thicknessValue.set(thickness);
    }
    /**
     * Returns a {@link MutableReactiveValue} that can be used to watch
     * this tool's thickness.
     */
    getThicknessValue() {
      return this.thicknessValue;
    }
    /** @returns An object that allows switching between a full stroke and a partial stroke eraser. */
    getModeValue() {
      return this.modeValue;
    }
  };

  // node_modules/js-draw/dist/mjs/components/TextComponent.mjs
  var componentTypeId = "text";
  var TextTransformMode;
  (function(TextTransformMode2) {
    TextTransformMode2[TextTransformMode2["ABSOLUTE_XY"] = 0] = "ABSOLUTE_XY";
    TextTransformMode2[TextTransformMode2["RELATIVE_XY"] = 1] = "RELATIVE_XY";
    TextTransformMode2[TextTransformMode2["RELATIVE_X_ABSOLUTE_Y"] = 2] = "RELATIVE_X_ABSOLUTE_Y";
    TextTransformMode2[TextTransformMode2["RELATIVE_Y_ABSOLUTE_X"] = 3] = "RELATIVE_Y_ABSOLUTE_X";
  })(TextTransformMode || (TextTransformMode = {}));
  var defaultTextStyle = {
    fontFamily: "sans",
    size: 12,
    renderingStyle: { fill: Color4.purple }
  };
  var TextComponent = class _TextComponent extends AbstractComponent_default {
    /**
     * Creates a new text object from a list of component text or child TextComponents.
     *
     * @see {@link fromLines}
     */
    constructor(textObjects, transform, style = defaultTextStyle, transformMode = TextTransformMode.ABSOLUTE_XY) {
      super(componentTypeId);
      this.textObjects = textObjects;
      this.transform = transform;
      this.style = style;
      this.transformMode = transformMode;
      this.isRestylableComponent = true;
      this.recomputeBBox();
      const hasDirectContent = textObjects.some((obj) => typeof obj === "string");
      if (!hasDirectContent && textObjects.length > 0) {
        this.style = textObjects[0].getTextStyle();
      }
    }
    static applyTextStyles(ctx, style) {
      const hasSpaces = style.fontFamily.match(/\s/);
      const isQuoted = style.fontFamily.match(/^".*"$/);
      const fontFamily = hasSpaces && !isQuoted ? `"${style.fontFamily.replace(/["]/g, '\\"')}"` : style.fontFamily;
      ctx.font = [
        style.fontStyle ?? "",
        style.fontWeight ?? "",
        (style.size ?? 12) + "px",
        `${fontFamily}`
      ].join(" ");
      ctx.textAlign = "left";
    }
    // Roughly estimate the bounding box of `text`. Use if no CanvasRenderingContext2D is available.
    static estimateTextDimens(text, style) {
      const widthEst = text.length * style.size;
      const heightEst = style.size;
      return new Rect2(0, -heightEst * 2 / 3, widthEst, heightEst);
    }
    // Returns a set of TextMetrics for the given text, if a canvas is available.
    static getTextMetrics(text, style) {
      _TextComponent.textMeasuringCtx ??= document.createElement("canvas").getContext("2d") ?? null;
      if (!_TextComponent.textMeasuringCtx) {
        return null;
      }
      const ctx = _TextComponent.textMeasuringCtx;
      _TextComponent.applyTextStyles(ctx, style);
      return ctx.measureText(text);
    }
    // Returns the bounding box of `text`. This is approximate if no Canvas is available.
    static getTextDimens(text, style) {
      const metrics = this.getTextMetrics(text, style);
      if (!metrics) {
        return this.estimateTextDimens(text, style);
      }
      const textY = -metrics.actualBoundingBoxAscent;
      const textHeight = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;
      return new Rect2(0, textY, metrics.width, textHeight);
    }
    static getFontHeight(style) {
      return style.size;
    }
    computeUntransformedBBoxOfPart(part) {
      if (typeof part === "string") {
        return _TextComponent.getTextDimens(part, this.style);
      } else {
        return part.contentBBox;
      }
    }
    recomputeBBox() {
      let bbox = null;
      const cursor = new _TextComponent.TextCursor(this.transform, this.style);
      for (const textObject of this.textObjects) {
        const transform = cursor.update(textObject).transform;
        const currentBBox = this.computeUntransformedBBoxOfPart(textObject).transformedBoundingBox(transform);
        bbox ??= currentBBox;
        bbox = bbox.union(currentBBox);
      }
      this.contentBBox = bbox ?? Rect2.empty;
    }
    /**
     * Renders a TextComponent or a TextComponent child onto a `canvas`.
     *
     * `visibleRect` can be provided as a performance optimization. If not the top-level
     * text node, `baseTransform` (specifies the transformation of the parent text component
     * in canvas space) should also be provided.
     *
     * Note that passing a `baseTransform` is preferable to transforming `visibleRect`. At high
     * zoom levels, transforming `visibleRect` by the inverse of the parent transform can lead to
     * inaccuracy due to precision loss.
     */
    renderInternal(canvas, visibleRect, baseTransform = Mat33.identity) {
      const cursor = new _TextComponent.TextCursor(this.transform, this.style);
      for (const textObject of this.textObjects) {
        const { transform, bbox } = cursor.update(textObject);
        if (visibleRect && !visibleRect.intersects(bbox.transformedBoundingBox(baseTransform))) {
          continue;
        }
        if (typeof textObject === "string") {
          canvas.drawText(textObject, transform, this.style);
        } else {
          canvas.pushTransform(transform);
          textObject.renderInternal(canvas, visibleRect, baseTransform.rightMul(transform));
          canvas.popTransform();
        }
      }
    }
    render(canvas, visibleRect) {
      canvas.startObject(this.contentBBox);
      this.renderInternal(canvas, visibleRect);
      canvas.endObject(this.getLoadSaveData());
    }
    getProportionalRenderingTime() {
      return this.textObjects.length;
    }
    intersects(lineSegment) {
      const cursor = new _TextComponent.TextCursor(this.transform, this.style);
      for (const subObject of this.textObjects) {
        const invTransform = cursor.update(subObject).transform.inverse();
        const transformedLine = lineSegment.transformedBy(invTransform);
        if (typeof subObject === "string") {
          const textBBox = _TextComponent.getTextDimens(subObject, this.style);
          if (textBBox.getEdges().some((edge) => transformedLine.intersection(edge) !== null)) {
            return true;
          }
        } else {
          if (subObject.intersects(transformedLine)) {
            return true;
          }
        }
      }
      return false;
    }
    getStyle() {
      return {
        color: this.style.renderingStyle.fill,
        // Make a copy
        textStyle: {
          ...this.style,
          renderingStyle: {
            ...this.style.renderingStyle
          }
        }
      };
    }
    updateStyle(style) {
      return createRestyleComponentCommand(this.getStyle(), style, this);
    }
    forceStyle(style, editor) {
      if (style.textStyle) {
        this.style = cloneTextStyle(style.textStyle);
      } else if (style.color) {
        this.style = {
          ...this.style,
          renderingStyle: {
            ...this.style.renderingStyle,
            fill: style.color
          }
        };
      } else {
        return;
      }
      for (const child of this.textObjects) {
        if (child instanceof _TextComponent) {
          child.forceStyle(style, editor);
        }
      }
      if (editor) {
        editor.image.queueRerenderOf(this);
        editor.queueRerender();
      }
    }
    // See {@link getStyle}
    getTextStyle() {
      return cloneTextStyle(this.style);
    }
    getBaselinePos() {
      return this.transform.transformVec2(Vec2.zero);
    }
    getTransform() {
      return this.transform;
    }
    applyTransformation(affineTransfm) {
      this.transform = affineTransfm.rightMul(this.transform);
      this.recomputeBBox();
    }
    createClone() {
      const clonedTextObjects = this.textObjects.map((obj) => {
        if (typeof obj === "string") {
          return obj;
        } else {
          return obj.createClone();
        }
      });
      return new _TextComponent(clonedTextObjects, this.transform, this.style);
    }
    getText() {
      const result = [];
      for (const textObject of this.textObjects) {
        if (typeof textObject === "string") {
          result.push(textObject);
        } else {
          result.push(textObject.getText());
        }
      }
      return result.join("\n");
    }
    description(localizationTable) {
      return localizationTable.text(this.getText());
    }
    // Do not rely on the output of `serializeToJSON` taking any particular format.
    serializeToJSON() {
      const serializableStyle = textStyleToJSON(this.style);
      const serializedTextObjects = this.textObjects.map((text) => {
        if (typeof text === "string") {
          return {
            text
          };
        } else {
          return {
            json: text.serializeToJSON()
          };
        }
      });
      return {
        textObjects: serializedTextObjects,
        transform: this.transform.toArray(),
        style: serializableStyle
      };
    }
    // @internal
    static deserializeFromString(json) {
      if (typeof json === "string") {
        json = JSON.parse(json);
      }
      const style = textStyleFromJSON(json.style);
      const textObjects = json.textObjects.map((data) => {
        if ((data.text ?? null) !== null) {
          return data.text;
        }
        return _TextComponent.deserializeFromString(data.json);
      });
      json.transform = json.transform.filter((elem) => typeof elem === "number");
      if (json.transform.length !== 9) {
        throw new Error(`Unable to deserialize transform, ${json.transform}.`);
      }
      const transformData = json.transform;
      const transform = new Mat33(...transformData);
      return new _TextComponent(textObjects, transform, style);
    }
    /**
     * Creates a `TextComponent` from `lines`.
     *
     * @example
     * ```ts
     * const textStyle = {
     *   size: 12,
     *   fontFamily: 'serif',
     *   renderingStyle: { fill: Color4.black },
     * };
     *
     * const text = TextComponent.fromLines('foo\nbar'.split('\n'), Mat33.identity, textStyle);
     * ```
     */
    static fromLines(lines, transform, style) {
      let lastComponent = null;
      const components = [];
      const lineMargin = Math.round(this.getFontHeight(style));
      let position = Vec2.zero;
      for (const line of lines) {
        if (lastComponent) {
          position = position.plus(Vec2.unitY.times(lineMargin));
        }
        const component = new _TextComponent([line], Mat33.translation(position), style);
        components.push(component);
        lastComponent = component;
      }
      return new _TextComponent(components, transform, style);
    }
  };
  TextComponent.textMeasuringCtx = null;
  TextComponent.TextCursor = class {
    constructor(parentTransform = Mat33.identity, parentStyle) {
      this.parentTransform = parentTransform;
      this.parentStyle = parentStyle;
      this.transform = Mat33.identity;
    }
    /**
     * Based on previous calls to `update`, returns the transformation and bounding box (relative
     * to the parent element, or if none, the canvas) of the given `element`. Note that
     * this is computed in part using the `parentTransform` provivded to this cursor's constructor.
     *
     * Warning: There may be edge cases here that are not taken into account.
     */
    update(elem) {
      let elementTransform = Mat33.identity;
      let elemInternalTransform = Mat33.identity;
      let textSize;
      if (typeof elem === "string") {
        textSize = TextComponent.getTextDimens(elem, this.parentStyle);
      } else {
        elemInternalTransform = elem.transform;
        textSize = elem.getBBox();
      }
      const positioning = typeof elem === "string" ? TextTransformMode.RELATIVE_XY : elem.transformMode;
      if (positioning === TextTransformMode.RELATIVE_XY) {
        elementTransform = this.transform.rightMul(elementTransform);
      } else if (positioning === TextTransformMode.RELATIVE_X_ABSOLUTE_Y || positioning === TextTransformMode.RELATIVE_Y_ABSOLUTE_X) {
        const transform2 = this.transform.mapEntries((component, [row, col]) => {
          if (positioning === TextTransformMode.RELATIVE_X_ABSOLUTE_Y) {
            return row === 1 && col === 2 ? 0 : component;
          } else if (positioning === TextTransformMode.RELATIVE_Y_ABSOLUTE_X) {
            return row === 0 && col === 2 ? 0 : component;
          }
          throw new Error("Unreachable");
          return 0;
        });
        elementTransform = transform2.rightMul(elementTransform);
      }
      const endShiftTransform = Mat33.translation(Vec2.of(textSize.width, 0));
      this.transform = elementTransform.rightMul(elemInternalTransform).rightMul(endShiftTransform);
      const transform = this.parentTransform.rightMul(elementTransform);
      return {
        transform,
        bbox: textSize.transformedBoundingBox(transform)
      };
    }
  };
  var TextComponent_default = TextComponent;
  AbstractComponent_default.registerComponent(componentTypeId, (data) => TextComponent.deserializeFromString(data));

  // node_modules/js-draw/dist/mjs/rendering/renderers/AbstractRenderer.mjs
  var defaultDraftInkPresenter = { setEnabled: () => {
  }, updateStyle: () => {
  } };
  var AbstractRenderer = class {
    constructor(viewport) {
      this.viewport = viewport;
      this.selfTransform = null;
      this.transformStack = [];
      this.objectLevel = 0;
      this.currentPaths = null;
    }
    /**
     * this.canvasToScreen, etc. should be used instead of the corresponding
     * methods on `Viewport`, because the viewport may not accurately reflect
     * what is rendered.
     */
    getViewport() {
      return this.viewport;
    }
    setDraftMode(_draftMode) {
    }
    /**
     * Returns an API that can be used to accelerate inking.
     */
    getDraftInkPresenter() {
      return defaultDraftInkPresenter;
    }
    flushPath() {
      if (!this.currentPaths) {
        return;
      }
      let lastStyle = null;
      for (const path of this.currentPaths) {
        const { startPoint, commands, style } = path;
        if (!lastStyle || !stylesEqual(lastStyle, style)) {
          if (lastStyle) {
            this.endPath(lastStyle);
          }
          this.beginPath(startPoint);
          lastStyle = style;
        } else {
          this.moveTo(startPoint);
        }
        for (const command of commands) {
          if (command.kind === PathCommandType.LineTo) {
            this.lineTo(command.point);
          } else if (command.kind === PathCommandType.MoveTo) {
            this.moveTo(command.point);
          } else if (command.kind === PathCommandType.CubicBezierTo) {
            this.traceCubicBezierCurve(command.controlPoint1, command.controlPoint2, command.endPoint);
          } else if (command.kind === PathCommandType.QuadraticBezierTo) {
            this.traceQuadraticBezierCurve(command.controlPoint, command.endPoint);
          }
        }
      }
      if (lastStyle) {
        this.endPath(lastStyle);
      }
      this.currentPaths = [];
    }
    /**
     * Draws a styled path. If within an object started by {@link startObject},
     * the resultant path may not be visible until {@link endObject} is called.
     */
    drawPath(path) {
      if (this.objectLevel === 0 || this.currentPaths === null) {
        this.currentPaths = [path];
        this.flushPath();
        this.currentPaths = null;
      } else {
        this.currentPaths.push(path);
      }
    }
    // Strokes a rectangle. Boundary lines have width [lineWidth] and are filled with [lineFill].
    // This is equivalent to `drawPath(Path.fromRect(...).toRenderable(...))`.
    drawRect(rect, lineWidth, lineFill) {
      const path = Path.fromRect(rect, lineWidth);
      this.drawPath(pathToRenderable(path, lineFill));
    }
    /** Draws a filled rectangle. */
    fillRect(rect, fill) {
      const path = Path.fromRect(rect);
      this.drawPath(pathToRenderable(path, { fill }));
    }
    /**
     * This should be called whenever a new object is being drawn.
     *
     * @param _boundingBox The bounding box of the object to be drawn.
     * @param _clip Whether content outside `_boundingBox` should be drawn. Renderers
     *              that override this method are not required to support `_clip`.
     */
    startObject(_boundingBox, _clip) {
      if (this.objectLevel > 0) {
        this.flushPath();
      }
      this.currentPaths = [];
      this.objectLevel++;
    }
    /**
     * Notes the end of an object.
     * @param _loaderData - a map from strings to JSON-ifyable objects
     * and contains properties attached to the object by whatever loader loaded the image. This
     * is used to preserve attributes not supported by js-draw when loading/saving an image.
     * Renderers may ignore this.
     *
     * @param _objectTags - a list of labels (e.g. `className`s) to be attached to the object.
     * Renderers may ignore this.
     */
    endObject(_loaderData, _objectTags) {
      this.flushPath();
      this.currentPaths = null;
      this.objectLevel--;
      if (this.objectLevel < 0) {
        throw new Error("More objects have ended than have been started (negative object nesting level)!");
      }
    }
    getNestingLevel() {
      return this.objectLevel;
    }
    // Returns true iff other can be rendered onto this without data loss.
    canRenderFromWithoutDataLoss(_other) {
      return false;
    }
    // MUST throw if other and this are not of the same base class.
    renderFromOtherOfSameType(_renderTo, other) {
      throw new Error(`Unable to render from ${other}: Not implemented`);
    }
    // Set a transformation to apply to things before rendering,
    // replacing the viewport's transform.
    setTransform(transform) {
      this.selfTransform = transform;
    }
    pushTransform(transform) {
      this.flushPath();
      this.transformStack.push(this.selfTransform);
      this.setTransform(this.getCanvasToScreenTransform().rightMul(transform));
    }
    popTransform() {
      if (this.transformStack.length === 0) {
        throw new Error("Unable to pop more transforms than have been pushed!");
      }
      this.flushPath();
      this.setTransform(this.transformStack.pop() ?? null);
    }
    // Get the matrix that transforms a vector on the canvas to a vector on this'
    // rendering target.
    getCanvasToScreenTransform() {
      if (this.selfTransform) {
        return this.selfTransform;
      }
      return this.viewport.canvasToScreenTransform;
    }
    canvasToScreen(vec) {
      return this.getCanvasToScreenTransform().transformVec2(vec);
    }
    getSizeOfCanvasPixelOnScreen() {
      return this.getCanvasToScreenTransform().transformVec3(Vec2.unitX).length();
    }
    /**
     * @internal
     */
    overrideVisibleRect(rect) {
      this.visibleRectOverride = rect;
    }
    // Returns the region in canvas space that is visible within the viewport this
    // canvas is rendering to.
    //
    // Note that in some cases this might not be the same as the `visibleRect` given
    // to components in their `render` method.
    getVisibleRect() {
      return this.visibleRectOverride ?? this.viewport.visibleRect;
    }
  };

  // node_modules/js-draw/dist/mjs/rendering/renderers/CanvasRenderer.mjs
  var CanvasRenderer = class _CanvasRenderer extends AbstractRenderer {
    /**
     * Creates a new `CanvasRenderer` that renders to the given rendering context.
     * The `viewport` is used to determine the translation/rotation/scaling of the content
     * to draw.
     */
    constructor(ctx, viewport) {
      super(viewport);
      this.ctx = ctx;
      this.ignoreObjectsAboveLevel = null;
      this.ignoringObject = false;
      this.currentObjectBBox = null;
      this.clipLevels = [];
      this.setDraftMode(false);
    }
    transformBy(transformBy) {
      this.ctx.transform(
        transformBy.a1,
        transformBy.b1,
        // a, b
        transformBy.a2,
        transformBy.b2,
        // c, d
        transformBy.a3,
        transformBy.b3
      );
    }
    canRenderFromWithoutDataLoss(other) {
      return other instanceof _CanvasRenderer;
    }
    renderFromOtherOfSameType(transformBy, other) {
      if (!(other instanceof _CanvasRenderer)) {
        throw new Error(`${other} cannot be rendered onto ${this}`);
      }
      transformBy = this.getCanvasToScreenTransform().rightMul(transformBy);
      this.ctx.save();
      this.transformBy(transformBy);
      this.ctx.drawImage(other.ctx.canvas, 0, 0);
      this.ctx.restore();
    }
    // Set parameters for lower/higher quality rendering
    setDraftMode(draftMode) {
      if (draftMode) {
        this.minSquareCurveApproxDist = 9;
        this.minRenderSizeBothDimens = 1;
        this.minRenderSizeAnyDimen = 0.1;
      } else {
        this.minSquareCurveApproxDist = 0.5;
        this.minRenderSizeBothDimens = 0.1;
        this.minRenderSizeAnyDimen = 1e-6;
      }
    }
    displaySize() {
      return Vec2.of(this.ctx.canvas.clientWidth, this.ctx.canvas.clientHeight);
    }
    clear() {
      this.ctx.save();
      this.ctx.resetTransform();
      this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);
      this.ctx.restore();
    }
    beginPath(startPoint) {
      startPoint = this.canvasToScreen(startPoint);
      this.ctx.beginPath();
      this.ctx.moveTo(startPoint.x, startPoint.y);
    }
    endPath(style) {
      if (style.fill.a > 0) {
        this.ctx.fillStyle = style.fill.toHexString();
        this.ctx.fill();
      }
      if (style.stroke) {
        this.ctx.strokeStyle = style.stroke.color.toHexString();
        this.ctx.lineWidth = this.getSizeOfCanvasPixelOnScreen() * style.stroke.width;
        this.ctx.lineCap = "round";
        this.ctx.lineJoin = "round";
        this.ctx.stroke();
        this.ctx.lineWidth = 1;
      }
      this.ctx.closePath();
    }
    lineTo(point) {
      point = this.canvasToScreen(point);
      this.ctx.lineTo(point.x, point.y);
    }
    moveTo(point) {
      point = this.canvasToScreen(point);
      this.ctx.moveTo(point.x, point.y);
    }
    traceCubicBezierCurve(p1, p2, p3) {
      p1 = this.canvasToScreen(p1);
      p2 = this.canvasToScreen(p2);
      p3 = this.canvasToScreen(p3);
      const delta1 = p2.minus(p1);
      const delta2 = p3.minus(p2);
      if (delta1.magnitudeSquared() < this.minSquareCurveApproxDist && delta2.magnitudeSquared() < this.minSquareCurveApproxDist) {
        this.ctx.lineTo(p3.x, p3.y);
      } else {
        this.ctx.bezierCurveTo(p1.x, p1.y, p2.x, p2.y, p3.x, p3.y);
      }
    }
    traceQuadraticBezierCurve(controlPoint, endPoint) {
      controlPoint = this.canvasToScreen(controlPoint);
      endPoint = this.canvasToScreen(endPoint);
      const delta = controlPoint.minus(endPoint);
      if (delta.magnitudeSquared() < this.minSquareCurveApproxDist) {
        this.ctx.lineTo(endPoint.x, endPoint.y);
      } else {
        this.ctx.quadraticCurveTo(controlPoint.x, controlPoint.y, endPoint.x, endPoint.y);
      }
    }
    drawPath(path) {
      if (this.ignoringObject) {
        return;
      }
      const visibleRect = this.getVisibleRect();
      if (this.currentObjectBBox?.containsRect(visibleRect)) {
        path = visualEquivalent(path, visibleRect);
      }
      super.drawPath(path);
    }
    drawText(text, transform, style) {
      this.ctx.save();
      transform = this.getCanvasToScreenTransform().rightMul(transform);
      this.transformBy(transform);
      TextComponent_default.applyTextStyles(this.ctx, style);
      if (style.renderingStyle.fill.a !== 0) {
        this.ctx.fillStyle = style.renderingStyle.fill.toHexString();
        this.ctx.fillText(text, 0, 0);
      }
      if (style.renderingStyle.stroke) {
        this.ctx.strokeStyle = style.renderingStyle.stroke.color.toHexString();
        this.ctx.lineWidth = style.renderingStyle.stroke.width;
        this.ctx.strokeText(text, 0, 0);
      }
      this.ctx.restore();
    }
    drawImage(image) {
      if (image.image.width === 0 || image.image.height === 0) {
        return;
      }
      this.ctx.save();
      const transform = this.getCanvasToScreenTransform().rightMul(image.transform);
      this.transformBy(transform);
      this.ctx.drawImage(image.image, 0, 0);
      this.ctx.restore();
    }
    startObject(boundingBox, clip) {
      if (this.isTooSmallToRender(boundingBox)) {
        this.ignoreObjectsAboveLevel = this.getNestingLevel();
        this.ignoringObject = true;
      }
      super.startObject(boundingBox);
      this.currentObjectBBox = boundingBox;
      if (!this.ignoringObject && clip) {
        const clippedIsOutsideScreen = boundingBox.containsRect(this.getVisibleRect());
        if (!clippedIsOutsideScreen) {
          this.clipLevels.push(this.objectLevel);
          this.ctx.save();
          this.ctx.beginPath();
          for (const corner of boundingBox.corners) {
            const screenCorner = this.canvasToScreen(corner);
            this.ctx.lineTo(screenCorner.x, screenCorner.y);
          }
          this.ctx.clip();
        }
      }
    }
    endObject() {
      const objectLevel = this.objectLevel;
      this.currentObjectBBox = null;
      super.endObject();
      if (!this.ignoringObject && this.clipLevels.length > 0) {
        if (this.clipLevels[this.clipLevels.length - 1] === objectLevel) {
          this.ctx.restore();
          this.clipLevels.pop();
        }
      }
      if (this.ignoreObjectsAboveLevel !== null && this.getNestingLevel() <= this.ignoreObjectsAboveLevel) {
        this.ignoreObjectsAboveLevel = null;
        this.ignoringObject = false;
      }
    }
    /**
     * Returns a reference to the underlying `CanvasRenderingContext2D`.
     * This can be used to render custom content not supported by {@link AbstractRenderer}.
     * However, such content won't support {@link SVGRenderer} or {@link TextOnlyRenderer}
     * by default.
     *
     * Use with caution.
     */
    drawWithRawRenderingContext(callback) {
      this.ctx.save();
      this.transformBy(this.getCanvasToScreenTransform());
      callback(this.ctx);
      this.ctx.restore();
    }
    // @internal
    drawPoints(...points) {
      const pointRadius = 10;
      for (let i = 0; i < points.length; i++) {
        const point = this.canvasToScreen(points[i]);
        this.ctx.beginPath();
        this.ctx.arc(point.x, point.y, pointRadius, 0, Math.PI * 2);
        this.ctx.fillStyle = Color4.ofRGBA(0.5 + Math.sin(i) / 2, 1, 0.5 + Math.cos(i * 0.2) / 4, 0.5).toHexString();
        this.ctx.lineWidth = 2;
        this.ctx.fill();
        this.ctx.stroke();
        this.ctx.closePath();
        this.ctx.textAlign = "center";
        this.ctx.textBaseline = "middle";
        this.ctx.fillStyle = "black";
        this.ctx.fillText(`${i}`, point.x, point.y, pointRadius * 2);
      }
    }
    // @internal
    isTooSmallToRender(rect) {
      const diagonal = rect.size.times(this.getSizeOfCanvasPixelOnScreen());
      const bothDimenMinSize = this.minRenderSizeBothDimens;
      const bothTooSmall = Math.abs(diagonal.x) < bothDimenMinSize && Math.abs(diagonal.y) < bothDimenMinSize;
      const anyDimenMinSize = this.minRenderSizeAnyDimen;
      const anyTooSmall = Math.abs(diagonal.x) < anyDimenMinSize || Math.abs(diagonal.y) < anyDimenMinSize;
      return bothTooSmall || anyTooSmall;
    }
    // @internal
    static fromViewport(exportViewport, options = {}) {
      const canvas = document.createElement("canvas");
      const exportRectSize = exportViewport.getScreenRectSize();
      let canvasSize = options.canvasSize ?? exportRectSize;
      if (options.maxCanvasDimen && canvasSize.maximumEntryMagnitude() > options.maxCanvasDimen) {
        canvasSize = canvasSize.times(options.maxCanvasDimen / canvasSize.maximumEntryMagnitude());
      }
      canvas.width = canvasSize.x;
      canvas.height = canvasSize.y;
      const ctx = canvas.getContext("2d");
      const scaleFactor = Math.min(canvasSize.x / exportRectSize.x, canvasSize.y / exportRectSize.y);
      ctx.scale(scaleFactor, scaleFactor);
      return { renderer: new _CanvasRenderer(ctx, exportViewport), element: canvas };
    }
  };

  // node_modules/js-draw/dist/mjs/components/BackgroundComponent.mjs
  var BackgroundType;
  (function(BackgroundType2) {
    BackgroundType2[BackgroundType2["SolidColor"] = 0] = "SolidColor";
    BackgroundType2[BackgroundType2["Grid"] = 1] = "Grid";
    BackgroundType2[BackgroundType2["None"] = 2] = "None";
  })(BackgroundType || (BackgroundType = {}));
  var imageBackgroundCSSClassName = "js-draw-image-background";
  var imageBackgroundGridSizeCSSPrefix = "js-draw-image-background-grid-";
  var imageBackgroundNonAutomaticSecondaryColorCSSClassName = "js-draw-image-background-non-automatic-secondary-color";
  var backgroundTypeToClassNameMap = {
    [BackgroundType.Grid]: "js-draw-image-background-grid",
    [BackgroundType.SolidColor]: imageBackgroundCSSClassName,
    [BackgroundType.None]: ""
  };
  var BackgroundComponent = class _BackgroundComponent extends AbstractComponent_default {
    constructor(backgroundType, mainColor) {
      super("image-background", 0);
      this.backgroundType = backgroundType;
      this.mainColor = mainColor;
      this.viewportSizeChangeListener = null;
      this.autoresizeChangedListener = null;
      this.fillsScreen = false;
      this.gridSize = Viewport_default.getGridSize(2);
      this.gridStrokeWidth = 0.7;
      this.secondaryColor = null;
      this.isRestylableComponent = true;
      this.contentBBox = Rect2.empty;
    }
    static ofGrid(backgroundColor, gridSize, gridColor, gridStrokeWidth) {
      const background = new _BackgroundComponent(BackgroundType.Grid, backgroundColor);
      if (gridSize !== void 0) {
        background.gridSize = gridSize;
      }
      if (gridColor !== void 0) {
        background.secondaryColor = gridColor;
      }
      if (gridStrokeWidth !== void 0) {
        background.gridStrokeWidth = gridStrokeWidth;
      }
      return background;
    }
    getBackgroundType() {
      return this.backgroundType;
    }
    // @internal
    getMainColor() {
      return this.mainColor;
    }
    // @internal
    getSecondaryColor() {
      return this.secondaryColor;
    }
    // @internal
    getGridSize() {
      return this.gridSize;
    }
    getStyle() {
      let color = this.mainColor;
      if (this.backgroundType === BackgroundType.None) {
        color = void 0;
      }
      return {
        color
      };
    }
    updateStyle(style) {
      return createRestyleComponentCommand(this.getStyle(), style, this);
    }
    // @internal
    forceStyle(style, editor) {
      const fill = style.color;
      if (!fill) {
        return;
      }
      this.mainColor = fill;
      if (fill.eq(Color4.transparent) && this.backgroundType === BackgroundType.SolidColor) {
        this.backgroundType = BackgroundType.None;
      } else if (this.backgroundType === BackgroundType.None) {
        this.backgroundType = BackgroundType.SolidColor;
      }
      if (editor) {
        editor.image.queueRerenderOf(this);
        editor.queueRerender();
      }
    }
    onAddToImage(image) {
      if (this.viewportSizeChangeListener) {
        console.warn("onAddToImage called when background is already in an image");
        this.onRemoveFromImage();
      }
      this.viewportSizeChangeListener = image.notifier.on(EditorImageEventType.ExportViewportChanged, () => {
        this.recomputeBBox(image);
      });
      this.autoresizeChangedListener = image.notifier.on(EditorImageEventType.AutoresizeModeChanged, () => {
        this.recomputeBBox(image);
      });
      this.recomputeBBox(image);
    }
    onRemoveFromImage() {
      this.viewportSizeChangeListener?.remove();
      this.autoresizeChangedListener?.remove();
      this.viewportSizeChangeListener = null;
      this.autoresizeChangedListener = null;
    }
    recomputeBBox(image) {
      const importExportRect = image.getImportExportViewport().visibleRect;
      let needsRerender = false;
      if (!this.contentBBox.eq(importExportRect)) {
        this.contentBBox = importExportRect;
        needsRerender ||= !this.fillsScreen;
      }
      const imageAutoresizes = image.getAutoresizeEnabled();
      if (imageAutoresizes !== this.fillsScreen) {
        this.fillsScreen = imageAutoresizes;
        needsRerender = true;
      }
      if (needsRerender) {
        image.queueRerenderOf(this);
      }
    }
    generateGridPath(visibleRect) {
      const contentBBox = this.getFullBoundingBox(visibleRect);
      const targetRect = (visibleRect?.intersection(contentBBox) ?? contentBBox).grownBy(this.gridStrokeWidth / 2);
      const roundDownToGrid = (coord) => Math.floor(coord / this.gridSize) * this.gridSize;
      const roundUpToGrid = (coord) => Math.ceil(coord / this.gridSize) * this.gridSize;
      const startY = roundUpToGrid(targetRect.y);
      const endY = roundDownToGrid(targetRect.y + targetRect.h);
      const startX = roundUpToGrid(targetRect.x);
      const endX = roundDownToGrid(targetRect.x + targetRect.w);
      const result = [];
      const rowCount = (endY - startY) / this.gridSize;
      const colCount = (endX - startX) / this.gridSize;
      const maxGridCols = 1e3;
      const maxGridRows = 1e3;
      if (rowCount > maxGridRows || colCount > maxGridCols) {
        return Path.empty;
      }
      const startPoint = Vec2.of(targetRect.x, startY);
      for (let y = startY; y <= endY; y += this.gridSize) {
        result.push({
          kind: PathCommandType.MoveTo,
          point: Vec2.of(targetRect.x, y)
        });
        result.push({
          kind: PathCommandType.LineTo,
          point: Vec2.of(targetRect.x + targetRect.w, y)
        });
      }
      for (let x = startX; x <= endX; x += this.gridSize) {
        result.push({
          kind: PathCommandType.MoveTo,
          point: Vec2.of(x, targetRect.y)
        });
        result.push({
          kind: PathCommandType.LineTo,
          point: Vec2.of(x, targetRect.y + targetRect.h)
        });
      }
      return new Path(startPoint, result);
    }
    /**
     * @returns this background's bounding box if the screen size is taken into
     * account (which may be necessary if this component is configured to fill the
     * entire screen).
     */
    getFullBoundingBox(visibleRect) {
      return (this.fillsScreen ? visibleRect : this.contentBBox) ?? this.contentBBox;
    }
    render(canvas, visibleRect) {
      if (this.backgroundType === BackgroundType.None) {
        return;
      }
      const mustRender = !visibleRect;
      if (this.fillsScreen) {
        visibleRect ??= canvas.getVisibleRect();
      }
      const clip = this.backgroundType === BackgroundType.Grid;
      const contentBBox = this.getFullBoundingBox(visibleRect);
      canvas.startObject(contentBBox, clip);
      if (this.backgroundType === BackgroundType.SolidColor || this.backgroundType === BackgroundType.Grid) {
        const intersection = visibleRect?.intersection(contentBBox);
        if (intersection) {
          canvas.fillRect(intersection, this.mainColor);
        } else if (mustRender) {
          canvas.fillRect(contentBBox, this.mainColor);
        }
      }
      if (this.backgroundType === BackgroundType.Grid) {
        let gridColor = this.secondaryColor;
        gridColor ??= Color4.ofRGBA(1 - this.mainColor.r, 1 - this.mainColor.g, 1 - this.mainColor.b, 0.2);
        if (this.mainColor.a === 0) {
          gridColor = Color4.ofRGBA(0.5, 0.5, 0.5, 0.2);
        }
        const style = {
          fill: Color4.transparent,
          stroke: { width: this.gridStrokeWidth, color: gridColor }
        };
        canvas.drawPath(pathToRenderable(this.generateGridPath(visibleRect), style));
      }
      const backgroundTypeCSSClass = backgroundTypeToClassNameMap[this.backgroundType];
      const classNames = [imageBackgroundCSSClassName];
      if (backgroundTypeCSSClass !== imageBackgroundCSSClassName) {
        classNames.push(backgroundTypeCSSClass);
        const gridSizeStr = toRoundedString(this.gridSize).replace(/[.]/g, "p");
        classNames.push(imageBackgroundGridSizeCSSPrefix + gridSizeStr);
      }
      if (this.secondaryColor !== null) {
        classNames.push(imageBackgroundNonAutomaticSecondaryColorCSSClassName);
      }
      canvas.endObject(this.getLoadSaveData(), classNames);
    }
    intersects(lineSegment) {
      return this.contentBBox.getEdges().some((edge) => edge.intersects(lineSegment));
    }
    isSelectable() {
      return false;
    }
    isBackground() {
      return true;
    }
    getSizingMode() {
      return this.fillsScreen ? ComponentSizingMode.FillScreen : ComponentSizingMode.BoundingBox;
    }
    serializeToJSON() {
      return {
        mainColor: this.mainColor.toHexString(),
        secondaryColor: this.secondaryColor?.toHexString(),
        backgroundType: this.backgroundType,
        gridSize: this.gridSize,
        gridStrokeWidth: this.gridStrokeWidth
      };
    }
    applyTransformation(_affineTransfm) {
    }
    description(localizationTable) {
      if (this.backgroundType === BackgroundType.SolidColor) {
        return localizationTable.filledBackgroundWithColor(this.mainColor.toString());
      } else if (this.backgroundType === BackgroundType.None) {
        return localizationTable.emptyBackground;
      } else if (this.backgroundType === BackgroundType.Grid) {
        return localizationTable.gridBackground;
      } else {
        const exhaustivenessCheck = this.backgroundType;
        return exhaustivenessCheck;
      }
    }
    createClone() {
      return new _BackgroundComponent(this.backgroundType, this.mainColor);
    }
    // @internal
    static deserializeFromJSON(json) {
      if (typeof json === "string") {
        json = JSON.parse(json);
      }
      if (typeof json.mainColor !== "string") {
        throw new Error("Error deserializing \u2014 mainColor must be of type string.");
      }
      let backgroundType;
      const jsonBackgroundType = json.backgroundType;
      if (jsonBackgroundType === BackgroundType.None || jsonBackgroundType === BackgroundType.Grid || jsonBackgroundType === BackgroundType.SolidColor) {
        backgroundType = jsonBackgroundType;
      } else {
        const exhaustivenessCheck = jsonBackgroundType;
        return exhaustivenessCheck;
      }
      const mainColor = Color4.fromHex(json.mainColor);
      const secondaryColor = json.secondaryColor ? Color4.fromHex(json.secondaryColor) : null;
      const gridSize = json.gridSize ?? void 0;
      const gridStrokeWidth = json.gridStrokeWidth ?? void 0;
      const result = new _BackgroundComponent(backgroundType, mainColor);
      result.secondaryColor = secondaryColor;
      if (gridSize) {
        result.gridSize = gridSize;
      }
      if (gridStrokeWidth) {
        result.gridStrokeWidth = gridStrokeWidth;
      }
      return result;
    }
  };
  AbstractComponent_default.registerComponent("image-background", BackgroundComponent.deserializeFromJSON);

  // node_modules/js-draw/dist/mjs/util/dom/waitForImageLoaded.mjs
  var waitForImageLoad = async (image) => {
    if (!image.complete) {
      await new Promise((resolve, reject) => {
        image.onload = (event) => resolve(event);
        image.onerror = (event) => reject(event);
        image.onabort = (event) => reject(event);
      });
    }
  };
  var waitForImageLoaded_default = waitForImageLoad;

  // node_modules/js-draw/dist/mjs/components/ImageComponent.mjs
  var ImageComponent = class _ImageComponent extends AbstractComponent_default {
    constructor(image) {
      super("image-component");
      this.image = {
        ...image,
        label: image.label ?? image.image.getAttribute("alt") ?? image.image.getAttribute("aria-label") ?? void 0
      };
      const isHTMLImageElem = (elem) => {
        return elem.getAttribute("src") !== void 0;
      };
      if (isHTMLImageElem(image.image) && !image.image.complete) {
        image.image.onload = () => this.recomputeBBox();
      }
      this.recomputeBBox();
    }
    getImageRect() {
      return new Rect2(0, 0, this.image.image.width, this.image.image.height);
    }
    recomputeBBox() {
      this.contentBBox = this.getImageRect();
      this.contentBBox = this.contentBBox.transformedBoundingBox(this.image.transform);
    }
    /**
     * Load from an image. Waits for the image to load if incomplete.
     *
     * The image, `elem`, must not [taint](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image#security_and_tainted_canvases)
     * an HTMLCanvasElement when rendered.
     */
    static async fromImage(elem, transform) {
      await waitForImageLoaded_default(elem);
      let width, height;
      if (typeof elem.width === "number" && typeof elem.height === "number" && elem.width !== 0 && elem.height !== 0) {
        width = elem.width;
        height = elem.height;
      } else {
        width = elem.clientWidth;
        height = elem.clientHeight;
      }
      let image;
      let url = elem.src ?? "";
      if (!url.startsWith("data:image/")) {
        const canvas = document.createElement("canvas");
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext("2d");
        ctx.drawImage(elem, 0, 0, canvas.width, canvas.height);
        url = canvas.toDataURL();
        image = canvas;
      } else {
        image = new Image();
        image.src = url;
        image.width = width;
        image.height = height;
      }
      image.setAttribute("alt", elem.getAttribute("alt") ?? "");
      image.setAttribute("aria-label", elem.getAttribute("aria-label") ?? "");
      return new _ImageComponent({
        image,
        base64Url: url,
        transform
      });
    }
    render(canvas, _visibleRect) {
      canvas.startObject(this.contentBBox);
      canvas.drawImage(this.image);
      canvas.endObject(this.getLoadSaveData());
    }
    // A *very* rough estimate of how long it takes to render this component
    getProportionalRenderingTime() {
      return 10;
    }
    intersects(lineSegment) {
      const rect = this.getImageRect();
      const edges = rect.getEdges().map((edge) => edge.transformedBy(this.image.transform));
      for (const edge of edges) {
        if (edge.intersects(lineSegment)) {
          return true;
        }
      }
      return false;
    }
    applyTransformation(affineTransfm) {
      this.image.transform = affineTransfm.rightMul(this.image.transform);
      this.recomputeBBox();
    }
    description(localizationTable) {
      return this.image.label ? localizationTable.imageNode(this.image.label) : localizationTable.unlabeledImageNode;
    }
    getAltText() {
      return this.image.label;
    }
    // The base64 image URL of this image.
    getURL() {
      return this.image.base64Url;
    }
    getTransformation() {
      return this.image.transform;
    }
    createClone() {
      return new _ImageComponent({
        ...this.image
      });
    }
    serializeToJSON() {
      return {
        src: this.image.base64Url,
        label: this.image.label,
        // Store the width and height for bounding box computations while the image is loading.
        width: this.image.image.width,
        height: this.image.image.height,
        transform: this.image.transform.toArray()
      };
    }
    static deserializeFromJSON(data) {
      if (!(typeof data.src === "string")) {
        throw new Error(`${data} has invalid format! Expected src property.`);
      }
      assertIsNumberArray(data.transform);
      assertIsNumber(data.width);
      assertIsNumber(data.height);
      const image = new Image();
      image.src = data.src;
      image.width = data.width;
      image.height = data.height;
      const transform = new Mat33(...data.transform);
      return new _ImageComponent({
        image,
        base64Url: data.src,
        label: data.label,
        transform
      });
    }
  };
  AbstractComponent_default.registerComponent("image-component", ImageComponent.deserializeFromJSON);

  // node_modules/js-draw/dist/mjs/components/SVGGlobalAttributesObject.mjs
  var componentKind = "svg-global-attributes";
  var SVGGlobalAttributesObject = class _SVGGlobalAttributesObject extends AbstractComponent_default {
    // Does not modify `attrs`
    constructor(attrs) {
      super(componentKind);
      this.contentBBox = Rect2.empty;
      const attrsManagedByRenderer = ["viewBox", "width", "height"];
      this.attrs = attrs.filter(([attr, _value]) => {
        return !attrsManagedByRenderer.includes(attr);
      });
    }
    render(canvas, _visibleRect) {
      if (!(canvas instanceof SVGRenderer)) {
        return;
      }
      for (const [attr, value] of this.attrs) {
        canvas.setRootSVGAttribute(attr, value);
      }
    }
    intersects(_lineSegment) {
      return false;
    }
    applyTransformation(_affineTransfm) {
    }
    isSelectable() {
      return false;
    }
    getSizingMode() {
      return ComponentSizingMode.Anywhere;
    }
    createClone() {
      return new _SVGGlobalAttributesObject(this.attrs);
    }
    description(localization7) {
      return localization7.svgObject;
    }
    serializeToJSON() {
      return JSON.stringify(this.attrs);
    }
    static deserializeFromString(_data) {
      return new _SVGGlobalAttributesObject([]);
    }
  };
  AbstractComponent_default.registerComponent(componentKind, SVGGlobalAttributesObject.deserializeFromString);

  // node_modules/js-draw/dist/mjs/components/UnknownSVGObject.mjs
  var componentId = "unknown-svg-object";
  var UnknownSVGObject = class _UnknownSVGObject extends AbstractComponent_default {
    constructor(svgObject) {
      super(componentId);
      this.svgObject = svgObject;
      this.contentBBox = Rect2.of(svgObject.getBoundingClientRect());
    }
    render(canvas, _visibleRect) {
      if (!(canvas instanceof SVGRenderer)) {
        return;
      }
      canvas.startObject(this.contentBBox);
      canvas.drawSVGElem(this.svgObject);
      canvas.endObject(this.getLoadSaveData());
    }
    intersects(lineSegment) {
      return this.contentBBox.getEdges().some((edge) => edge.intersection(lineSegment) !== null);
    }
    applyTransformation(_affineTransfm) {
    }
    isSelectable() {
      return false;
    }
    getSizingMode() {
      return ComponentSizingMode.Anywhere;
    }
    createClone() {
      return new _UnknownSVGObject(this.svgObject.cloneNode(true));
    }
    description(localization7) {
      return localization7.svgObject;
    }
    serializeToJSON() {
      return JSON.stringify({
        html: this.svgObject.outerHTML
      });
    }
  };
  AbstractComponent_default.registerComponent(componentId, null);

  // node_modules/js-draw/dist/mjs/SVGLoader/utils/determineFontSize.mjs
  var determineFontSize = (elem, computedStyles, supportedStyleAttrs) => {
    const fontSizeExp = /^([-0-9.e]+)px/i;
    let fontSizeMatch = fontSizeExp.exec(elem.style?.fontSize ?? "");
    if (!fontSizeMatch && elem.tagName.toLowerCase() === "tspan" && elem.parentElement) {
      fontSizeMatch = fontSizeExp.exec(elem.parentElement.style?.fontSize ?? "");
    }
    if (!fontSizeMatch && computedStyles) {
      fontSizeMatch = fontSizeExp.exec(computedStyles.fontSize);
    }
    let fontSize = 12;
    if (fontSizeMatch) {
      supportedStyleAttrs.add("fontSize");
      fontSize = parseFloat(fontSizeMatch[1]);
    }
    return fontSize;
  };
  var determineFontSize_default = determineFontSize;

  // node_modules/js-draw/dist/mjs/SVGLoader/SVGLoader.mjs
  var defaultSVGViewRect = new Rect2(0, 0, 500, 500);
  var svgAttributesDataKey = "svgAttrs";
  var svgStyleAttributesDataKey = "svgStyleAttrs";
  var svgLoaderAttributeContainerID = "svgContainerID";
  var svgLoaderAutoresizeClassName = "js-draw--autoresize";
  var SVGLoaderLoadMethod;
  (function(SVGLoaderLoadMethod2) {
    SVGLoaderLoadMethod2["IFrame"] = "iframe";
    SVGLoaderLoadMethod2["DOMParser"] = "domparser";
  })(SVGLoaderLoadMethod || (SVGLoaderLoadMethod = {}));
  var supportedStrokeFillStyleAttrs = ["stroke", "fill", "stroke-width"];
  var SVGLoader = class _SVGLoader {
    constructor(source, onFinish, options) {
      this.source = source;
      this.onFinish = onFinish;
      this.onAddComponent = null;
      this.onProgress = null;
      this.onDetermineExportRect = null;
      this.processedCount = 0;
      this.totalToProcess = 0;
      this.containerGroupIDs = [];
      this.encounteredIDs = [];
      this.plugins = options.plugins ?? [];
      this.storeUnknown = !(options.sanitize ?? false);
      this.disableUnknownObjectWarnings = !!options.disableUnknownObjectWarnings;
    }
    // If [computedStyles] is given, it is preferred to directly accessing node's style object.
    getStyle(node, computedStyles) {
      let fill = Color4.transparent;
      let stroke;
      const fillAttribute = node.getAttribute("fill") ?? (computedStyles?.fill || node.style?.fill);
      if (fillAttribute) {
        try {
          fill = Color4.fromString(fillAttribute);
        } catch {
          console.error("Unknown fill color,", fillAttribute);
        }
      }
      const strokeAttribute = node.getAttribute("stroke") ?? computedStyles?.stroke ?? node.style?.stroke ?? "";
      const strokeWidthAttr = node.getAttribute("stroke-width") ?? computedStyles?.strokeWidth ?? node.style?.strokeWidth ?? "";
      if (strokeAttribute && strokeWidthAttr) {
        try {
          let width = parseFloat(strokeWidthAttr ?? "1");
          if (!isFinite(width)) {
            width = 0;
          }
          const strokeColor = Color4.fromString(strokeAttribute);
          if (strokeColor.a > 0) {
            stroke = {
              width,
              color: strokeColor
            };
          }
        } catch (e) {
          console.error("Error parsing stroke data:", e);
        }
      }
      const style = {
        fill,
        stroke
      };
      return style;
    }
    strokeDataFromElem(node) {
      const result = [];
      const pathData = node.getAttribute("d") ?? "";
      const style = this.getStyle(node);
      const parts = pathData.split("M");
      let isFirst = true;
      for (const part of parts) {
        const isNoOpMoveTo = /^[0-9., \t\n]+$/.exec(part);
        if (part !== "" && !isNoOpMoveTo) {
          const current = !isFirst ? `M${part}` : part;
          const path = Path.fromString(current);
          const spec = pathToRenderable(path, style);
          result.push(spec);
        }
        isFirst = false;
      }
      return result;
    }
    attachUnrecognisedAttrs(elem, node, supportedAttrs, supportedStyleAttrs) {
      if (!this.storeUnknown) {
        return;
      }
      for (const attr of node.getAttributeNames()) {
        if (supportedAttrs.has(attr) || attr === "style" && supportedStyleAttrs) {
          continue;
        }
        elem.attachLoadSaveData(svgAttributesDataKey, [
          attr,
          node.getAttribute(attr)
        ]);
      }
      if (supportedStyleAttrs && node.style) {
        for (let i = 0; i < node.style.length; i++) {
          const attr = node.style[i];
          if (attr === "" || !attr) {
            continue;
          }
          if (supportedStyleAttrs.has(attr)) {
            continue;
          }
          elem.attachLoadSaveData(svgStyleAttributesDataKey, {
            key: attr,
            value: node.style.getPropertyValue(attr),
            priority: node.style.getPropertyPriority(attr)
          });
        }
      }
    }
    // Adds a stroke with a single path
    async addPath(node) {
      let elem;
      try {
        const strokeData = this.strokeDataFromElem(node);
        elem = new Stroke(strokeData);
        this.attachUnrecognisedAttrs(elem, node, /* @__PURE__ */ new Set([...supportedStrokeFillStyleAttrs, "d"]), new Set(supportedStrokeFillStyleAttrs));
      } catch (e) {
        console.error("Invalid path in node", node, "\nError:", e, "\nAdding as an unknown object.");
        if (this.storeUnknown) {
          elem = new UnknownSVGObject(node);
        } else {
          return;
        }
      }
      await this.addComponent(elem);
    }
    async addBackground(node) {
      if (node.classList.contains(backgroundTypeToClassNameMap[BackgroundType.Grid])) {
        let foregroundStr;
        let backgroundStr;
        let gridStrokeWidthStr;
        if (node.tagName.toLowerCase() === "g") {
          if (node.children.length !== 2) {
            await this.addUnknownNode(node);
            return;
          }
          const background = node.children[0];
          const grid = node.children[1];
          backgroundStr = background.getAttribute("fill");
          foregroundStr = grid.getAttribute("stroke");
          gridStrokeWidthStr = grid.getAttribute("stroke-width");
        } else {
          backgroundStr = node.getAttribute("fill");
          foregroundStr = node.getAttribute("stroke");
          gridStrokeWidthStr = node.getAttribute("stroke-width");
        }
        backgroundStr ??= Color4.transparent.toHexString();
        if (!foregroundStr) {
          await this.addUnknownNode(node);
          return;
        }
        let gridSize = void 0;
        for (const className of node.classList) {
          if (className.startsWith(imageBackgroundGridSizeCSSPrefix)) {
            const sizeStr = className.substring(imageBackgroundGridSizeCSSPrefix.length);
            gridSize = parseFloat(sizeStr.replace(/p/g, "."));
          }
        }
        let gridStrokeWidth = void 0;
        if (gridStrokeWidthStr) {
          gridStrokeWidth = parseFloat(gridStrokeWidthStr);
        }
        const backgroundColor = Color4.fromString(backgroundStr);
        let foregroundColor = Color4.fromString(foregroundStr);
        if (!node.classList.contains(imageBackgroundNonAutomaticSecondaryColorCSSClassName)) {
          foregroundColor = void 0;
        }
        const elem = BackgroundComponent.ofGrid(backgroundColor, gridSize, foregroundColor, gridStrokeWidth);
        await this.addComponent(elem);
      } else if (node.tagName.toLowerCase() === "path") {
        const fill = Color4.fromString(node.getAttribute("fill") ?? node.style.fill ?? "black");
        const elem = new BackgroundComponent(BackgroundType.SolidColor, fill);
        await this.addComponent(elem);
      } else {
        await this.addUnknownNode(node);
      }
    }
    getComputedStyle(element) {
      try {
        return window.getComputedStyle(element);
      } catch (error) {
        console.warn("Error computing style", error);
        return void 0;
      }
    }
    // If given, 'supportedAttrs' will have x, y, etc. attributes that were used in computing the transform added to it,
    // to prevent storing duplicate transform information when saving the component.
    getTransform(elem, supportedAttrs, computedStyles) {
      const highpTransformAttribute = "data-highp-transform";
      const rawTransformData = elem.getAttribute(highpTransformAttribute);
      let transform;
      if (rawTransformData) {
        try {
          transform = Mat33.fromCSSMatrix(rawTransformData);
          supportedAttrs?.push(highpTransformAttribute);
        } catch (e) {
          console.warn(`Unable to parse raw transform data, ${rawTransformData}. Falling back to CSS data. Error:`, e);
        }
      }
      if (!transform) {
        computedStyles ??= this.getComputedStyle(elem);
        let transformProperty = computedStyles?.transform;
        if (!transformProperty || transformProperty === "none") {
          transformProperty = elem.style?.transform || "none";
        }
        try {
          transform = Mat33.fromCSSMatrix(elem.style.transform);
        } catch (_e) {
          console.warn("matrix parse error", _e);
          transform = Mat33.fromCSSMatrix(transformProperty);
        }
        const elemX = elem.getAttribute("x");
        const elemY = elem.getAttribute("y");
        if (elemX || elemY) {
          const x = parseFloat(elemX ?? "0");
          const y = parseFloat(elemY ?? "0");
          if (!isNaN(x) && !isNaN(y)) {
            supportedAttrs?.push("x", "y");
            transform = transform.rightMul(Mat33.translation(Vec2.of(x, y)));
          }
        }
      }
      return transform;
    }
    makeText(elem) {
      const contentList = [];
      for (const child of elem.childNodes) {
        if (child.nodeType === Node.TEXT_NODE) {
          contentList.push(child.nodeValue ?? "");
        } else if (child.nodeType === Node.ELEMENT_NODE) {
          const subElem = child;
          if (subElem.tagName.toLowerCase() === "tspan") {
            contentList.push(this.makeText(subElem));
          } else {
            throw new Error(`Unrecognized text child element: ${subElem}`);
          }
        } else {
          throw new Error(`Unrecognized text child node: ${child}.`);
        }
      }
      if (contentList.length === 0) {
        contentList.push("");
      }
      const computedStyles = this.getComputedStyle(elem);
      const supportedStyleAttrs = /* @__PURE__ */ new Set([
        "fontFamily",
        "transform",
        ...supportedStrokeFillStyleAttrs
      ]);
      const style = {
        size: determineFontSize_default(elem, computedStyles, supportedStyleAttrs),
        fontFamily: computedStyles?.fontFamily || elem.style?.fontFamily || "sans-serif",
        fontWeight: computedStyles?.fontWeight || elem.style?.fontWeight || void 0,
        fontStyle: computedStyles?.fontStyle || elem.style?.fontStyle || void 0,
        renderingStyle: this.getStyle(elem, computedStyles)
      };
      const supportedAttrs = [];
      let transform = this.getTransform(elem, supportedAttrs, computedStyles);
      let transformMode = TextTransformMode.ABSOLUTE_XY;
      const elemDX = elem.getAttribute("dx");
      if (elemDX) {
        transformMode = TextTransformMode.RELATIVE_X_ABSOLUTE_Y;
        transform = transform.rightMul(Mat33.translation(Vec2.of(parseFloat(elemDX), 0)));
        supportedAttrs.push("dx");
      }
      const elemDY = elem.getAttribute("dy");
      if (elemDY) {
        if (transformMode === TextTransformMode.RELATIVE_X_ABSOLUTE_Y) {
          transformMode = TextTransformMode.RELATIVE_XY;
        } else {
          transformMode = TextTransformMode.RELATIVE_Y_ABSOLUTE_X;
        }
        transform = transform.rightMul(Mat33.translation(Vec2.of(0, parseFloat(elemDY))));
        supportedAttrs.push("dy");
      }
      const result = new TextComponent_default(contentList, transform, style, transformMode);
      this.attachUnrecognisedAttrs(result, elem, new Set(supportedAttrs), new Set(supportedStyleAttrs));
      return result;
    }
    async addText(elem) {
      try {
        const textElem = this.makeText(elem);
        await this.addComponent(textElem);
      } catch (e) {
        console.error("Invalid text object in node", elem, ". Continuing.... Error:", e);
        this.addUnknownNode(elem);
      }
    }
    async addImage(elem) {
      const image = new Image();
      image.src = elem.getAttribute("xlink:href") ?? elem.href.baseVal;
      image.setAttribute("alt", elem.getAttribute("aria-label") ?? "");
      try {
        const supportedAttrs = [];
        const transform = this.getTransform(elem, supportedAttrs);
        const imageElem = await ImageComponent.fromImage(image, transform);
        this.attachUnrecognisedAttrs(imageElem, elem, new Set(supportedAttrs), /* @__PURE__ */ new Set(["transform"]));
        await this.addComponent(imageElem);
      } catch (e) {
        console.error("Error loading image:", e, ". Element: ", elem, ". Continuing...");
        await this.addUnknownNode(elem);
      }
    }
    async addUnknownNode(node) {
      if (this.storeUnknown) {
        const component = new UnknownSVGObject(node);
        await this.addComponent(component);
      }
    }
    async startGroup(node) {
      node = node.cloneNode(false);
      let id = node.id || `id-${this.encounteredIDs.length}`;
      let idSuffixCounter = 0;
      let suffix = "";
      while (this.encounteredIDs.includes(id + suffix)) {
        idSuffixCounter++;
        suffix = "--" + idSuffixCounter;
      }
      id += suffix;
      node.replaceChildren();
      node.id = id;
      const component = new UnknownSVGObject(node);
      this.addComponent(component);
      this.containerGroupIDs.push(node.id);
      this.encounteredIDs.push(node.id);
    }
    // Ends the most recent group started by .startGroup
    async endGroup() {
      this.containerGroupIDs.pop();
    }
    async addComponent(component) {
      if (this.containerGroupIDs.length > 0) {
        component.attachLoadSaveData(svgLoaderAttributeContainerID, [...this.containerGroupIDs]);
      }
      await this.onAddComponent?.(component);
    }
    updateViewBox(node) {
      const viewBoxAttr = node.getAttribute("viewBox");
      if (this.rootViewBox || !viewBoxAttr) {
        return;
      }
      const components = viewBoxAttr.split(/[ \t\n,]+/);
      const x = parseFloat(components[0]);
      const y = parseFloat(components[1]);
      const width = parseFloat(components[2]);
      const height = parseFloat(components[3]);
      if (isNaN(x) || isNaN(y) || isNaN(width) || isNaN(height)) {
        console.warn(`node ${node} has an unparsable viewbox. Viewbox: ${viewBoxAttr}. Match: ${components}.`);
        return;
      }
      const autoresize = node.classList.contains(svgLoaderAutoresizeClassName);
      this.rootViewBox = new Rect2(x, y, width, height);
      this.onDetermineExportRect?.(this.rootViewBox, { autoresize });
    }
    async updateSVGAttrs(node) {
      if (this.storeUnknown) {
        await this.onAddComponent?.(new SVGGlobalAttributesObject(this.getSourceAttrs(node)));
      }
    }
    async visit(node) {
      this.totalToProcess += node.childElementCount;
      let visitChildren = true;
      const visitPlugin = async () => {
        for (const plugin of this.plugins) {
          const processed = await plugin.visit(node, {
            addComponent: (component) => {
              return this.onAddComponent?.(component);
            }
          });
          if (processed) {
            visitChildren = false;
            return true;
          }
        }
        return false;
      };
      const visitBuiltIn = async () => {
        switch (node.tagName.toLowerCase()) {
          case "g":
            if (node.classList.contains(imageBackgroundCSSClassName)) {
              await this.addBackground(node);
              visitChildren = false;
            } else {
              await this.startGroup(node);
            }
            break;
          case "path":
            if (node.classList.contains(imageBackgroundCSSClassName)) {
              await this.addBackground(node);
            } else {
              await this.addPath(node);
            }
            break;
          case "text":
            await this.addText(node);
            visitChildren = false;
            break;
          case "image":
            await this.addImage(node);
            visitChildren = false;
            break;
          case "svg":
            this.updateViewBox(node);
            this.updateSVGAttrs(node);
            break;
          case "style":
            if (node.getAttribute("id") !== renderedStylesheetId) {
              await this.addUnknownNode(node);
            }
            break;
          default:
            if (!this.disableUnknownObjectWarnings) {
              console.warn("Unknown SVG element,", node, node.tagName);
              if (!(node instanceof SVGElement)) {
                console.warn("Element", node, "is not an SVGElement!", this.storeUnknown ? "Continuing anyway." : "Skipping.");
              }
            }
            await this.addUnknownNode(node);
            return;
        }
      };
      if (await visitPlugin()) {
        visitChildren = false;
      } else {
        await visitBuiltIn();
      }
      if (visitChildren) {
        for (const child of node.children) {
          await this.visit(child);
        }
        if (node.tagName.toLowerCase() === "g") {
          await this.endGroup();
        }
      }
      this.processedCount++;
      await this.onProgress?.(this.processedCount, this.totalToProcess);
    }
    // Get SVG element attributes (e.g. xlink=...)
    getSourceAttrs(node) {
      return node.getAttributeNames().map((attr) => {
        return [attr, node.getAttribute(attr)];
      });
    }
    async start(onAddComponent, onProgress, onDetermineExportRect = null) {
      this.onAddComponent = onAddComponent;
      this.onProgress = onProgress;
      this.onDetermineExportRect = onDetermineExportRect;
      this.totalToProcess = this.source.childElementCount;
      this.processedCount = 0;
      this.rootViewBox = null;
      await this.visit(this.source);
      const viewBox = this.rootViewBox;
      if (!viewBox) {
        this.onDetermineExportRect?.(defaultSVGViewRect);
      }
      this.onFinish?.();
      this.onFinish = null;
    }
    /**
     * Create an `SVGLoader` from the content of an SVG image. SVGs are loaded within a sandboxed
     * iframe with `sandbox="allow-same-origin"`
     * [thereby disabling JavaScript](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#sandbox).
     *
     * @see {@link Editor.loadFrom}
     * @param text - Textual representation of the SVG (e.g. `<svg viewbox='...'>...</svg>`).
     * @param options - if `true` or `false`, treated as the `sanitize` option -- don't store unknown attributes.
     */
    static fromString(text, options = false) {
      const domParserLoad = typeof options !== "boolean" && options?.loadMethod === SVGLoaderLoadMethod.DOMParser;
      const { svgElem, cleanUp } = (() => {
        if (!domParserLoad) {
          try {
            const sandbox = document.createElement("iframe");
            sandbox.src = "about:blank";
            sandbox.setAttribute("sandbox", "allow-same-origin");
            sandbox.setAttribute("csp", "default-src 'about:blank'");
            sandbox.style.display = "none";
            document.body.appendChild(sandbox);
            if (!sandbox.hasAttribute("sandbox")) {
              sandbox.remove();
              throw new Error("SVG loading iframe is not sandboxed.");
            }
            const sandboxDoc = sandbox.contentWindow?.document ?? sandbox.contentDocument;
            if (sandboxDoc == null)
              throw new Error("Unable to open a sandboxed iframe!");
            sandboxDoc.open();
            sandboxDoc.write(`
						<!DOCTYPE html>
						<html>
							<head>
								<title>SVG Loading Sandbox</title>
								<meta name='viewport' conent='width=device-width,initial-scale=1.0'/>
								<meta charset='utf-8'/>
							</head>
							<body style='font-size: 12px;'>
								<script>
									console.error('JavaScript should not be able to run here!');
									throw new Error(
										'The SVG sandbox is broken! Please double-check the sandboxing setting.'
									);
								<\/script>
							</body>
						</html>
					`);
            sandboxDoc.close();
            const svgElem3 = sandboxDoc.createElementNS("http://www.w3.org/2000/svg", "svg");
            svgElem3.innerHTML = text;
            sandboxDoc.body.appendChild(svgElem3);
            const cleanUp3 = () => {
              svgElem3.remove();
              sandbox.remove();
              sandbox.src = "";
            };
            return { svgElem: svgElem3, cleanUp: cleanUp3 };
          } catch (error) {
            console.warn("Failed loading SVG via a sandboxed iframe. Some styles may not be loaded correctly. Error: ", error);
          }
        }
        const parser = new DOMParser();
        const doc = parser.parseFromString(`<svg xmlns="http://www.w3.org/2000/svg">${text}</svg>`, "text/html");
        const svgElem2 = doc.querySelector("svg");
        const errorReportNode = doc.querySelector("parsererror");
        if (errorReportNode) {
          throw new Error("Parse error: " + errorReportNode.textContent);
        }
        const cleanUp2 = () => {
        };
        return { svgElem: svgElem2, cleanUp: cleanUp2 };
      })();
      let sanitize;
      let disableUnknownObjectWarnings;
      let plugins;
      if (typeof options === "boolean") {
        sanitize = options;
        disableUnknownObjectWarnings = false;
        plugins = [];
      } else {
        sanitize = options.sanitize ?? false;
        disableUnknownObjectWarnings = options.disableUnknownObjectWarnings ?? false;
        plugins = options.plugins;
      }
      return new _SVGLoader(svgElem, cleanUp, {
        sanitize,
        disableUnknownObjectWarnings,
        plugins
      });
    }
  };

  // node_modules/js-draw/dist/mjs/util/listPrefixMatch.mjs
  var listPrefixMatch = (a, b) => {
    const shorter = a.length < b.length ? a : b;
    const longer = shorter === a ? b : a;
    for (let i = 0; i < shorter.length; i++) {
      if (shorter[i] !== longer[i]) {
        return false;
      }
    }
    return true;
  };
  var listPrefixMatch_default = listPrefixMatch;

  // node_modules/js-draw/dist/mjs/rendering/renderers/SVGRenderer.mjs
  var renderedStylesheetId = "js-draw-style-sheet";
  var svgNameSpace = "http://www.w3.org/2000/svg";
  var defaultTextStyle2 = {
    fontWeight: "400",
    fontStyle: "normal"
  };
  var SVGRenderer = class _SVGRenderer extends AbstractRenderer {
    /**
     * Creates a renderer that renders onto `elem`. If `sanitize`, don't render potentially untrusted data.
     *
     * `viewport` is used to determine the translation/rotation/scaling/output size of the rendered
     * data.
     */
    constructor(elem, viewport, sanitize = false) {
      super(viewport);
      this.elem = elem;
      this.sanitize = sanitize;
      this.lastPathStyle = null;
      this.lastPathString = [];
      this.lastContainerIDList = [];
      this.objectElems = null;
      this.overwrittenAttrs = {};
      this.textContainer = null;
      this.textContainerTransform = null;
      this.textParentStyle = defaultTextStyle2;
      this.clear();
      this.addStyleSheet();
    }
    addStyleSheet() {
      if (!this.elem.querySelector(`#${renderedStylesheetId}`)) {
        const styleSheet = document.createElementNS("http://www.w3.org/2000/svg", "style");
        styleSheet.appendChild(document.createTextNode(`
				path {
					stroke-linecap: round;
					stroke-linejoin: round;
				}

				text {
					white-space: pre;
				}
			`.replace(/\s+/g, "")));
        styleSheet.setAttribute("id", renderedStylesheetId);
        this.elem.appendChild(styleSheet);
      }
    }
    // Sets an attribute on the root SVG element.
    setRootSVGAttribute(name, value) {
      if (this.sanitize) {
        return;
      }
      if (!(name in this.overwrittenAttrs)) {
        this.overwrittenAttrs[name] = this.elem.getAttribute(name);
      }
      if (value !== null) {
        this.elem.setAttribute(name, value);
      } else {
        this.elem.removeAttribute(name);
      }
    }
    displaySize() {
      return Vec2.of(this.elem.clientWidth, this.elem.clientHeight);
    }
    clear() {
      this.lastPathString = [];
      this.lastContainerIDList = [];
      if (!this.sanitize) {
        for (const attrName in this.overwrittenAttrs) {
          const value = this.overwrittenAttrs[attrName];
          if (value) {
            this.elem.setAttribute(attrName, value);
          } else {
            this.elem.removeAttribute(attrName);
          }
        }
        this.overwrittenAttrs = {};
      }
    }
    // Push `this.fullPath` to the SVG. Returns the path added to the SVG, if any.
    // @internal
    addPathToSVG() {
      if (!this.lastPathStyle || this.lastPathString.length === 0) {
        return null;
      }
      const pathElem = document.createElementNS(svgNameSpace, "path");
      pathElem.setAttribute("d", this.lastPathString.join(" "));
      const style = this.lastPathStyle;
      if (style.fill.a > 0) {
        pathElem.setAttribute("fill", style.fill.toHexString());
      } else {
        pathElem.setAttribute("fill", "none");
      }
      if (style.stroke) {
        pathElem.setAttribute("stroke", style.stroke.color.toHexString());
        pathElem.setAttribute("stroke-width", toRoundedString(style.stroke.width * this.getSizeOfCanvasPixelOnScreen()));
      }
      this.elem.appendChild(pathElem);
      this.objectElems?.push(pathElem);
      return pathElem;
    }
    drawPath(pathSpec) {
      const style = pathSpec.style;
      const path = pathFromRenderable(pathSpec).transformedBy(this.getCanvasToScreenTransform());
      if (this.lastPathString.length === 0 || !this.lastPathStyle || !stylesEqual(this.lastPathStyle, style)) {
        this.addPathToSVG();
        this.lastPathStyle = style;
        this.lastPathString = [];
      }
      this.lastPathString.push(path.toString());
    }
    // Apply [elemTransform] to [elem]. Uses both a `matrix` and `.x`, `.y` properties if `setXY` is true.
    // Otherwise, just uses a `matrix`.
    transformFrom(elemTransform, elem, inCanvasSpace = false) {
      const transform = !inCanvasSpace ? this.getCanvasToScreenTransform().rightMul(elemTransform) : elemTransform;
      if (!transform.eq(Mat33.identity)) {
        const matrixString = transform.toCSSMatrix();
        elem.style.transform = matrixString;
        elem.setAttribute("data-highp-transform", matrixString);
      } else {
        elem.style.transform = "";
      }
    }
    drawText(text, transform, style) {
      const applyTextStyles = (elem, style2) => {
        if (style2.fontFamily !== this.textParentStyle?.fontFamily) {
          elem.style.fontFamily = style2.fontFamily;
        }
        if (style2.fontVariant !== this.textParentStyle?.fontVariant) {
          elem.style.fontVariant = style2.fontVariant ?? "";
        }
        if (style2.fontWeight !== this.textParentStyle?.fontWeight) {
          elem.style.fontWeight = style2.fontWeight ?? "";
        }
        if (style2.fontStyle !== this.textParentStyle?.fontStyle) {
          elem.style.fontStyle = style2.fontStyle ?? "";
        }
        if (style2.size !== this.textParentStyle?.size) {
          elem.style.fontSize = style2.size + "px";
        }
        const fillString = style2.renderingStyle.fill.toHexString();
        elem.style.fill = fillString;
        if (style2.renderingStyle.stroke) {
          const strokeStyle = style2.renderingStyle.stroke;
          elem.style.stroke = strokeStyle.color.toHexString();
          elem.style.strokeWidth = strokeStyle.width + "px";
        }
      };
      transform = this.getCanvasToScreenTransform().rightMul(transform);
      if (!this.textContainer) {
        const container = document.createElementNS(svgNameSpace, "text");
        container.appendChild(document.createTextNode(text));
        this.transformFrom(transform, container, true);
        applyTextStyles(container, style);
        this.elem.appendChild(container);
        this.objectElems?.push(container);
        if (this.objectLevel > 0) {
          this.textContainer = container;
          this.textContainerTransform = transform;
          this.textParentStyle = { ...defaultTextStyle2, ...style };
        }
      } else {
        const elem = document.createElementNS(svgNameSpace, "tspan");
        elem.appendChild(document.createTextNode(text));
        this.textContainer.appendChild(elem);
        transform = this.textContainerTransform.inverse().rightMul(transform);
        const translation = transform.transformVec2(Vec2.zero);
        elem.setAttribute("x", `${toRoundedString(translation.x)}`);
        elem.setAttribute("y", `${toRoundedString(translation.y)}`);
        applyTextStyles(elem, style);
      }
    }
    drawImage(image) {
      let label = image.label ?? image.image.getAttribute("aria-label") ?? "";
      if (label === "") {
        label = image.image.getAttribute("alt") ?? "";
      }
      const svgImgElem = document.createElementNS(svgNameSpace, "image");
      svgImgElem.setAttribute("href", image.base64Url);
      svgImgElem.setAttribute("width", image.image.getAttribute("width") ?? "");
      svgImgElem.setAttribute("height", image.image.getAttribute("height") ?? "");
      svgImgElem.setAttribute("aria-label", label);
      this.transformFrom(image.transform, svgImgElem);
      this.elem.appendChild(svgImgElem);
      this.objectElems?.push(svgImgElem);
    }
    startObject(boundingBox) {
      super.startObject(boundingBox);
      this.lastPathString = [];
      this.lastPathStyle = null;
      this.textContainer = null;
      this.textParentStyle = defaultTextStyle2;
      this.objectElems = [];
    }
    endObject(loaderData, elemClassNames) {
      super.endObject(loaderData);
      this.addPathToSVG();
      if (!this.objectElems) {
        return;
      }
      if (loaderData && !this.sanitize) {
        for (const elem of this.objectElems) {
          const attrs = loaderData[svgAttributesDataKey];
          const styleAttrs = loaderData[svgStyleAttributesDataKey];
          if (attrs) {
            for (const [attr, value] of attrs) {
              elem.setAttribute(attr, value);
            }
          }
          if (styleAttrs) {
            for (const attr of styleAttrs) {
              elem.style.setProperty(attr.key, attr.value, attr.priority);
            }
          }
        }
        const containerIDData = loaderData[svgLoaderAttributeContainerID];
        let containerIDList = [];
        if (containerIDData && containerIDData[0]) {
          if (containerIDData[0].length) {
            containerIDList = containerIDData[0];
          }
        }
        if (containerIDList.length > 0 && // containerIDList must share a prefix with the last ID list
        // otherwise, the z order of elements may have been changed from
        // the original image.
        // In the case that the z order has been changed, keep the current
        // element as a child of the root to preserve z order.
        listPrefixMatch_default(this.lastContainerIDList, containerIDList) && // The component can add at most one more parent than the previous item.
        this.lastContainerIDList.length >= containerIDList.length - 1) {
          const containerID = containerIDList[containerIDList.length - 1];
          const containerCandidates = this.elem.querySelectorAll(`g#${containerID}`);
          if (containerCandidates.length >= 1) {
            const container = containerCandidates[0];
            if (container.children.length === 0 || this.lastContainerIDList.length >= containerIDList.length) {
              for (const elem of this.objectElems) {
                elem.remove();
                container.appendChild(elem);
              }
            } else {
              containerIDList = [];
            }
          }
        } else {
          containerIDList = [];
        }
        this.lastContainerIDList = containerIDList;
      }
      if (elemClassNames && this.objectElems) {
        if (this.objectElems.length === 1) {
          this.objectElems[0].classList.add(...elemClassNames);
        } else {
          const wrapper = document.createElementNS(svgNameSpace, "g");
          wrapper.classList.add(...elemClassNames);
          for (const elem of this.objectElems) {
            elem.remove();
            wrapper.appendChild(elem);
          }
          this.elem.appendChild(wrapper);
        }
      }
    }
    // Not implemented -- use drawPath instead.
    unimplementedMessage() {
      throw new Error("Not implemenented!");
    }
    beginPath(_startPoint) {
      this.unimplementedMessage();
    }
    endPath(_style) {
      this.unimplementedMessage();
    }
    lineTo(_point) {
      this.unimplementedMessage();
    }
    moveTo(_point) {
      this.unimplementedMessage();
    }
    traceCubicBezierCurve(_controlPoint1, _controlPoint2, _endPoint) {
      this.unimplementedMessage();
    }
    traceQuadraticBezierCurve(_controlPoint, _endPoint) {
      this.unimplementedMessage();
    }
    drawPoints(...points) {
      points.map((point) => {
        const elem = document.createElementNS(svgNameSpace, "circle");
        elem.setAttribute("cx", `${point.x}`);
        elem.setAttribute("cy", `${point.y}`);
        elem.setAttribute("r", "15");
        this.elem.appendChild(elem);
      });
    }
    /**
     * Adds a **copy** of the given element directly to the container
     * SVG element, **without applying transforms**.
     *
     * If `sanitize` is enabled, this does nothing.
     */
    drawSVGElem(elem) {
      if (this.sanitize) {
        return;
      }
      if (elem.tagName.toLowerCase() === "style" && elem.getAttribute("id") === renderedStylesheetId) {
        return;
      }
      const elemToDraw = elem.cloneNode(true);
      this.elem.appendChild(elemToDraw);
      this.objectElems?.push(elemToDraw);
    }
    /**
     * Allows rendering directly to the underlying SVG element. Rendered
     * content is added to a `<g>` element that's passed as `parent` to `callback`.
     *
     * **Note**: Unlike {@link drawSVGElem}, this method can be used even if `sanitize` is `true`.
     * In this case, it's the responsibility of `callback` to ensure that everything added
     * to `parent` is safe to render.
     */
    drawWithSVGParent(callback) {
      const parent = document.createElementNS(svgNameSpace, "g");
      this.transformFrom(Mat33.identity, parent, true);
      callback(parent, { sanitize: this.sanitize });
      this.elem.appendChild(parent);
      this.objectElems?.push(parent);
    }
    isTooSmallToRender(_rect) {
      return false;
    }
    /**
     * Creates a new SVG element and `SVGRenerer` with `width`, `height`, `viewBox`,
     * and other metadata attributes set for the given `Viewport`.
     *
     * If `options` is a `boolean`, it is interpreted as whether to sanitize (not add unknown
     * SVG entities to) the output.
     */
    static fromViewport(viewport, options = true) {
      let sanitize;
      let useViewBoxForPositioning;
      if (typeof options === "boolean") {
        sanitize = options;
        useViewBoxForPositioning = false;
      } else {
        sanitize = options.sanitize ?? true;
        useViewBoxForPositioning = options.useViewBoxForPositioning ?? false;
      }
      const svgNameSpace2 = "http://www.w3.org/2000/svg";
      const result = document.createElementNS(svgNameSpace2, "svg");
      const screenRectSize = viewport.getScreenRectSize();
      const visibleRect = viewport.visibleRect;
      let viewBoxComponents;
      if (useViewBoxForPositioning) {
        const exportRect = viewport.visibleRect;
        viewBoxComponents = [exportRect.x, exportRect.y, exportRect.w, exportRect.h];
        viewport = viewport.getTemporaryClone();
        viewport.resetTransform(Mat33.identity);
      } else {
        viewBoxComponents = [0, 0, screenRectSize.x, screenRectSize.y];
      }
      result.setAttribute("viewBox", viewBoxComponents.map((part) => toRoundedString(part)).join(" "));
      result.setAttribute("width", toRoundedString(screenRectSize.x));
      result.setAttribute("height", toRoundedString(screenRectSize.y));
      result.setAttribute("version", "1.1");
      result.setAttribute("baseProfile", "full");
      result.setAttribute("xmlns", svgNameSpace2);
      const renderer = new _SVGRenderer(result, viewport, sanitize);
      if (!visibleRect.eq(viewport.visibleRect)) {
        renderer.overrideVisibleRect(visibleRect);
      }
      return { element: result, renderer };
    }
  };

  // node_modules/js-draw/dist/mjs/tools/SelectionTool/SelectionHandle.mjs
  var HandleShape;
  (function(HandleShape2) {
    HandleShape2[HandleShape2["Circle"] = 0] = "Circle";
    HandleShape2[HandleShape2["Square"] = 1] = "Square";
  })(HandleShape || (HandleShape = {}));
  var HandleAction;
  (function(HandleAction2) {
    HandleAction2["ResizeXY"] = "resize-xy";
    HandleAction2["Rotate"] = "rotate";
    HandleAction2["ResizeX"] = "resize-x";
    HandleAction2["ResizeY"] = "resize-y";
  })(HandleAction || (HandleAction = {}));
  var handleSize = 30;
  var SelectionHandle = class {
    constructor(presentation, parent, viewport, onDragStart, onDragUpdate, onDragEnd) {
      this.presentation = presentation;
      this.parent = parent;
      this.viewport = viewport;
      this.onDragStart = onDragStart;
      this.onDragUpdate = onDragUpdate;
      this.onDragEnd = onDragEnd;
      this.dragLastPos = null;
      this.element = document.createElement("div");
      this.element.classList.add(`${cssPrefix}handle`, `${cssPrefix}${presentation.action}`);
      const visibleContent = document.createElement("div");
      visibleContent.classList.add(`${cssPrefix}content`);
      this.element.appendChild(visibleContent);
      this.parentSide = presentation.side;
      const icon2 = presentation.icon;
      if (icon2) {
        visibleContent.appendChild(icon2);
        icon2.classList.add("icon");
      }
      if (presentation.action === HandleAction.Rotate) {
        this.shape = HandleShape.Circle;
      } else {
        this.shape = HandleShape.Square;
      }
      switch (this.shape) {
        case HandleShape.Circle:
          this.element.classList.add(`${cssPrefix}circle`);
          break;
        case HandleShape.Square:
          this.element.classList.add(`${cssPrefix}square`);
          break;
        default:
          assertUnreachable(this.shape);
      }
      this.updatePosition();
    }
    /**
     * Adds this to `container`, where `conatiner` should be the background/selection
     * element visible on the screen.
     */
    addTo(container) {
      container.appendChild(this.element);
    }
    /**
     * Removes this element from its container. Should only be called
     * after {@link addTo}.
     */
    remove() {
      this.element.remove();
    }
    /**
     * Returns this handle's bounding box relative to the top left of the
     * selection box.
     */
    getBBoxParentCoords() {
      const parentRect = this.parent.getScreenRegion();
      const size = Vec2.of(handleSize, handleSize);
      const topLeft = parentRect.size.scale(this.parentSide).minus(size.times(1 / 2));
      return new Rect2(topLeft.x, topLeft.y, size.x, size.y);
    }
    /** @returns this handle's bounding box relative to the canvas. */
    getBBoxCanvasCoords() {
      const parentRect = this.parent.region;
      const size = Vec2.of(handleSize, handleSize).times(1 / this.viewport.getScaleFactor());
      const topLeftFromParent = parentRect.size.scale(this.parentSide).minus(size.times(0.5));
      return new Rect2(topLeftFromParent.x, topLeftFromParent.y, size.x, size.y).translatedBy(parentRect.topLeft);
    }
    /**
     * Moves the HTML representation of this to the location matching its internal representation.
     */
    updatePosition() {
      const bbox = this.getBBoxParentCoords();
      this.element.style.marginLeft = `${bbox.topLeft.x}px`;
      this.element.style.marginTop = `${bbox.topLeft.y}px`;
      this.element.style.width = `${bbox.w}px`;
      this.element.style.height = `${bbox.h}px`;
    }
    /** @returns true iff `point` (in editor **canvas** coordinates) is in this. */
    containsPoint(point) {
      const bbox = this.getBBoxCanvasCoords();
      const delta = point.minus(bbox.center);
      const radius = bbox.size.x / 2;
      let result;
      if (this.shape === HandleShape.Circle) {
        result = delta.magnitude() <= radius;
      } else {
        result = Math.abs(delta.x) <= radius && Math.abs(delta.y) <= radius;
      }
      return result;
    }
    handleDragStart(pointer) {
      this.onDragStart(pointer.canvasPos);
      this.dragLastPos = pointer.canvasPos;
      return true;
    }
    handleDragUpdate(pointer) {
      if (!this.dragLastPos) {
        return;
      }
      this.onDragUpdate(pointer.canvasPos);
    }
    handleDragEnd() {
      if (!this.dragLastPos) {
        return;
      }
      return this.onDragEnd();
    }
    setSnapToGrid(snap) {
      this.snapToGrid = snap;
    }
    isSnappingToGrid() {
      return this.snapToGrid;
    }
  };

  // node_modules/js-draw/dist/mjs/commands/Duplicate.mjs
  var Duplicate = class extends SerializableCommand_default {
    constructor(toDuplicate, idsForDuplicates) {
      super("duplicate");
      this.toDuplicate = toDuplicate;
      this.duplicates = toDuplicate.map((elem, idx) => {
        if (idsForDuplicates && idsForDuplicates[idx]) {
          return elem.cloneWithId(idsForDuplicates[idx]);
        } else {
          return elem.clone();
        }
      });
      this.reverse = new Erase_default(this.duplicates);
    }
    apply(editor) {
      this.reverse.unapply(editor);
    }
    unapply(editor) {
      this.reverse.apply(editor);
    }
    onDrop(editor) {
      this.reverse.onDrop(editor);
    }
    description(_editor, localizationTable) {
      if (this.duplicates.length === 0) {
        return localizationTable.duplicatedNoElements;
      }
      return localizationTable.duplicateAction(describeComponentList_default(localizationTable, this.duplicates) ?? localizationTable.elements, this.duplicates.length);
    }
    serializeToJSON() {
      return {
        originalIds: this.toDuplicate.map((elem) => elem.getId()),
        cloneIds: this.duplicates.map((elem) => elem.getId())
      };
    }
  };
  (() => {
    SerializableCommand_default.register("duplicate", (json, editor) => {
      let originalIds;
      let cloneIds;
      if (Array.isArray(json)) {
        originalIds = json;
        cloneIds = [];
      } else {
        originalIds = json.originalIds;
        cloneIds = json.cloneIds;
      }
      assertIsStringArray(originalIds);
      assertIsStringArray(cloneIds);
      const resolvedElements = [];
      const filteredCloneIds = [];
      for (let i = 0; i < originalIds.length; i++) {
        const originalId = originalIds[i];
        const foundElement = editor.image.lookupElement(originalId);
        if (!foundElement) {
          console.warn("Duplicate command: Could not find element with ID", originalId);
        } else {
          filteredCloneIds.push(cloneIds[i]);
          resolvedElements.push(foundElement);
        }
      }
      return new Duplicate(resolvedElements, filteredCloneIds);
    });
  })();
  var Duplicate_default = Duplicate;

  // node_modules/js-draw/dist/mjs/tools/SelectionTool/types.mjs
  var SelectionMode;
  (function(SelectionMode2) {
    SelectionMode2["Lasso"] = "lasso";
    SelectionMode2["Rectangle"] = "rect";
  })(SelectionMode || (SelectionMode = {}));
  var ResizeMode;
  (function(ResizeMode2) {
    ResizeMode2[ResizeMode2["Both"] = 0] = "Both";
    ResizeMode2[ResizeMode2["HorizontalOnly"] = 1] = "HorizontalOnly";
    ResizeMode2[ResizeMode2["VerticalOnly"] = 2] = "VerticalOnly";
  })(ResizeMode || (ResizeMode = {}));
  var TransformMode;
  (function(TransformMode2) {
    TransformMode2[TransformMode2["Snap"] = 0] = "Snap";
    TransformMode2[TransformMode2["NoSnap"] = 1] = "NoSnap";
  })(TransformMode || (TransformMode = {}));

  // node_modules/js-draw/dist/mjs/tools/SelectionTool/TransformMode.mjs
  var DragTransformer = class {
    constructor(editor, selection) {
      this.editor = editor;
      this.selection = selection;
    }
    onDragStart(startPoint) {
      this.selection.setTransform(Mat33.identity);
      this.dragStartPoint = startPoint;
    }
    onDragUpdate(canvasPos) {
      const delta = this.editor.viewport.roundPoint(canvasPos.minus(this.dragStartPoint));
      this.selection.setTransform(Mat33.translation(delta));
    }
    onDragEnd() {
      return this.selection.finalizeTransform();
    }
  };
  var ResizeTransformer = class {
    constructor(editor, selection) {
      this.editor = editor;
      this.selection = selection;
      this.mode = ResizeMode.Both;
    }
    onDragStart(startPoint, mode) {
      this.selection.setTransform(Mat33.identity);
      this.mode = mode;
      this.dragStartPoint = startPoint;
      this.computeOriginAndScaleRate();
    }
    computeOriginAndScaleRate() {
      const selectionRect = this.selection.preTransformRegion;
      const selectionBoxCorners = selectionRect.corners;
      let largestDistSquared = 0;
      for (let i = 0; i < selectionBoxCorners.length; i++) {
        const currentCorner = selectionBoxCorners[i];
        const distSquaredToCurrent = this.dragStartPoint.minus(currentCorner).magnitudeSquared();
        if (distSquaredToCurrent > largestDistSquared) {
          largestDistSquared = distSquaredToCurrent;
          this.transformOrigin = currentCorner;
        }
      }
      let widthScaleRate = 1;
      let heightScaleRate = 1;
      if (this.transformOrigin.x > selectionRect.center.x) {
        widthScaleRate = -1;
      }
      if (this.transformOrigin.y > selectionRect.center.y) {
        heightScaleRate = -1;
      }
      this.scaleRate = Vec2.of(widthScaleRate, heightScaleRate);
    }
    onDragUpdate(canvasPos) {
      const canvasDelta = canvasPos.minus(this.dragStartPoint);
      const origWidth = this.selection.preTransformRegion.width;
      const origHeight = this.selection.preTransformRegion.height;
      let scale = Vec2.of(1, 1);
      if (this.mode === ResizeMode.HorizontalOnly) {
        const newWidth = origWidth + canvasDelta.x * this.scaleRate.x;
        scale = Vec2.of(newWidth / origWidth, scale.y);
      }
      if (this.mode === ResizeMode.VerticalOnly) {
        const newHeight = origHeight + canvasDelta.y * this.scaleRate.y;
        scale = Vec2.of(scale.x, newHeight / origHeight);
      }
      if (this.mode === ResizeMode.Both) {
        const delta = Math.abs(canvasDelta.x) > Math.abs(canvasDelta.y) ? canvasDelta.x : canvasDelta.y;
        const newWidth = origWidth + delta;
        scale = Vec2.of(newWidth / origWidth, newWidth / origWidth);
      }
      scale = scale.map((component) => Viewport_default.roundScaleRatio(component, 2));
      if (scale.x !== 0 && scale.y !== 0) {
        const origin = this.editor.viewport.roundPoint(this.transformOrigin);
        this.selection.setTransform(Mat33.scaling2D(scale, origin));
      }
    }
    onDragEnd() {
      return this.selection.finalizeTransform();
    }
  };
  var RotateTransformer = class {
    constructor(editor, selection) {
      this.editor = editor;
      this.selection = selection;
      this.startAngle = 0;
      this.targetRotation = 0;
      this.maximumDistFromStart = 0;
    }
    getAngle(canvasPoint) {
      const selectionCenter = this.selection.preTransformRegion.center;
      const offset = canvasPoint.minus(selectionCenter);
      return offset.angle();
    }
    roundAngle(angle) {
      const roundingFactor = 16 / 2 / Math.PI;
      return Math.round(angle * roundingFactor) / roundingFactor;
    }
    onDragStart(startPoint) {
      this.startPoint = startPoint;
      this.selection.setTransform(Mat33.identity);
      this.startAngle = this.getAngle(startPoint);
      this.targetRotation = 0;
      this.maximumDistFromStart = 0;
      this.startTime = performance.now();
    }
    setRotationTo(angle) {
      const canvasSelCenter = this.editor.viewport.roundPoint(this.selection.preTransformRegion.center);
      const unrounded = Mat33.zRotation(angle);
      const roundedRotationTransform = unrounded.mapEntries((entry) => Viewport_default.roundScaleRatio(entry));
      const fullRoundedTransform = Mat33.translation(canvasSelCenter).rightMul(roundedRotationTransform).rightMul(Mat33.translation(canvasSelCenter.times(-1)));
      this.selection.setTransform(fullRoundedTransform);
    }
    onDragUpdate(canvasPos) {
      this.targetRotation = this.roundAngle(this.getAngle(canvasPos) - this.startAngle);
      this.setRotationTo(this.targetRotation);
      const distFromStart = canvasPos.minus(this.startPoint).magnitude();
      if (distFromStart > this.maximumDistFromStart) {
        this.maximumDistFromStart = distFromStart;
      }
    }
    onDragEnd() {
      const clickThresholdDist = 10;
      const clickThresholdTime = 0.4;
      const dragTimeSeconds = (performance.now() - this.startTime) / 1e3;
      if (dragTimeSeconds < clickThresholdTime && this.maximumDistFromStart < clickThresholdDist && this.targetRotation === 0) {
        this.setRotationTo(-Math.PI / 2);
      }
      return this.selection.finalizeTransform();
    }
  };

  // node_modules/js-draw/dist/mjs/util/dom/createElement.mjs
  var ElementNamespace;
  (function(ElementNamespace2) {
    ElementNamespace2["Html"] = "html";
    ElementNamespace2["Svg"] = "svg";
  })(ElementNamespace || (ElementNamespace = {}));
  var createElement = (tag, props, elementType = ElementNamespace.Html) => {
    let elem;
    if (elementType === ElementNamespace.Html) {
      elem = document.createElement(tag);
    } else if (elementType === ElementNamespace.Svg) {
      elem = document.createElementNS("http://www.w3.org/2000/svg", tag);
    } else {
      throw new Error(`Unknown element type ${elementType}`);
    }
    for (const [key, value] of Object.entries(props)) {
      if (key === "children")
        continue;
      if (typeof value !== "string" && typeof value !== "number") {
        throw new Error(`Unsupported value type ${typeof value}`);
      }
      elem.setAttribute(key, value.toString());
    }
    if (props.children) {
      for (const item of props.children) {
        elem.appendChild(item);
      }
    }
    return elem;
  };
  var createSvgElement = (tag, props) => {
    return createElement(tag, props, ElementNamespace.Svg);
  };
  var createSvgElements = (tag, elements) => {
    return elements.map((props) => createSvgElement(tag, props));
  };
  var createSvgPaths = (...paths) => {
    return createSvgElements("path", paths);
  };
  var createElement_default = createElement;

  // node_modules/js-draw/dist/mjs/util/dom/createButton.mjs
  var createButton = ({ onClick, text, classList = [] } = {}) => {
    const button = createElement_default("button", { type: "button" });
    if (onClick) {
      button.onclick = onClick;
    }
    if (text) {
      button.textContent = text;
    }
    for (const className of classList) {
      button.classList.add(className);
    }
    return button;
  };
  var createButton_default = createButton;

  // node_modules/js-draw/dist/mjs/tools/SelectionTool/SelectionMenuShortcut.mjs
  var verticalOffset = 40;
  var SelectionMenuShortcut = class {
    constructor(parent, viewport, icon2, showContextMenu, localization7) {
      this.parent = parent;
      this.viewport = viewport;
      this.icon = icon2;
      this.localization = localization7;
      this.lastDragPointer = null;
      this.element = document.createElement("div");
      this.element.classList.add(`${cssPrefix}handle`, `${cssPrefix}selection-menu`);
      this.element.style.setProperty("--vertical-offset", `${verticalOffset}px`);
      this.onClick = () => {
        this.button?.focus({ preventScroll: true });
        const anchor = this.getBBoxCanvasCoords().center;
        showContextMenu(anchor);
      };
      this.initUI();
      this.updatePosition();
    }
    initUI() {
      const button = createButton_default({
        classList: ["icon"]
      });
      button.replaceChildren(this.icon);
      button.ariaLabel = this.localization.selectionMenu__show;
      button.title = button.ariaLabel;
      this.button = button;
      button.onkeydown = (event) => {
        if (event.key === "Enter") {
          event.preventDefault();
          this.onClick();
        }
      };
      this.element.appendChild(button);
      requestAnimationFrame(() => {
        this.updatePosition();
      });
    }
    addTo(container) {
      container.appendChild(this.element);
    }
    remove() {
      this.element.remove();
    }
    getElementScreenSize() {
      return Vec2.of(this.element.clientWidth, this.element.clientHeight);
    }
    /** Gets this menu's bounding box relative to the top left of its parent. */
    getBBoxParentCoords() {
      const topLeft = Vec2.of(0, -verticalOffset);
      const screenSize = this.getElementScreenSize();
      return new Rect2(topLeft.x, topLeft.y, screenSize.x, screenSize.y);
    }
    getBBoxCanvasCoords() {
      const parentCanvasRect = this.parent.region;
      const toCanvasScale = this.viewport.getSizeOfPixelOnCanvas();
      const contentCanvasSize = this.getElementScreenSize().times(toCanvasScale);
      const handleSizeCanvas = verticalOffset / this.viewport.getScaleFactor();
      const topLeft = Vec2.of(parentCanvasRect.x, parentCanvasRect.y - handleSizeCanvas);
      const minSize = Vec2.of(48, 48).times(toCanvasScale);
      return new Rect2(topLeft.x, topLeft.y, contentCanvasSize.x, contentCanvasSize.y).grownToSize(minSize);
    }
    updatePosition() {
      const bbox = this.getBBoxParentCoords();
      this.element.style.marginLeft = `${bbox.topLeft.x}px`;
      this.element.style.marginTop = `${bbox.topLeft.y}px`;
    }
    containsPoint(canvasPoint) {
      return this.getBBoxCanvasCoords().containsPoint(canvasPoint);
    }
    handleDragStart(pointer) {
      this.lastDragPointer = pointer;
      return true;
    }
    handleDragUpdate(pointer) {
      this.lastDragPointer = pointer;
    }
    handleDragEnd() {
      if (this.lastDragPointer && this.containsPoint(this.lastDragPointer.canvasPos)) {
        this.onClick();
      }
      this.lastDragPointer = null;
    }
  };

  // node_modules/js-draw/dist/mjs/tools/SelectionTool/Selection.mjs
  var _a4;
  var updateChunkSize = 100;
  var maxPreviewElemCount = 500;
  var Selection = class {
    constructor(selectedElems, editor, showContextMenu) {
      this.editor = editor;
      this.selectionTightBoundingBox = null;
      this.transform = Mat33.identity;
      this.selectedElems = [];
      this.hasParent = true;
      this.removedFromImage = {};
      this.activeHandle = null;
      this.backgroundDragging = false;
      this.selectionDuplicatedAnimationTimeout = null;
      selectedElems = [...selectedElems];
      this.selectedElems = selectedElems;
      this.originalRegion = Rect2.empty;
      this.transformers = {
        drag: new DragTransformer(editor, this),
        resize: new ResizeTransformer(editor, this),
        rotate: new RotateTransformer(editor, this)
      };
      this.outerContainer = document.createElement("div");
      this.outerContainer.classList.add(`${cssPrefix}selection-outer-container`);
      this.innerContainer = document.createElement("div");
      this.innerContainer.classList.add(`${cssPrefix}selection-inner-container`);
      this.backgroundElem = document.createElement("div");
      this.backgroundElem.classList.add(`${cssPrefix}selection-background`);
      this.innerContainer.appendChild(this.backgroundElem);
      this.outerContainer.appendChild(this.innerContainer);
      const makeResizeHandle = (mode, side) => {
        const modeToAction = {
          [ResizeMode.Both]: HandleAction.ResizeXY,
          [ResizeMode.HorizontalOnly]: HandleAction.ResizeX,
          [ResizeMode.VerticalOnly]: HandleAction.ResizeY
        };
        return new SelectionHandle({
          action: modeToAction[mode],
          side
        }, this, this.editor.viewport, (startPoint) => this.transformers.resize.onDragStart(startPoint, mode), (currentPoint) => this.transformers.resize.onDragUpdate(currentPoint), () => this.transformers.resize.onDragEnd());
      };
      const resizeHorizontalHandles = [
        makeResizeHandle(ResizeMode.HorizontalOnly, Vec2.of(0, 0.5)),
        makeResizeHandle(ResizeMode.HorizontalOnly, Vec2.of(1, 0.5))
      ];
      const resizeVerticalHandle = makeResizeHandle(ResizeMode.VerticalOnly, Vec2.of(0.5, 1));
      const resizeBothHandle = makeResizeHandle(ResizeMode.Both, Vec2.of(1, 1));
      const rotationHandle = new SelectionHandle({
        action: HandleAction.Rotate,
        side: Vec2.of(0.5, 0),
        icon: this.editor.icons.makeRotateIcon()
      }, this, this.editor.viewport, (startPoint) => this.transformers.rotate.onDragStart(startPoint), (currentPoint) => this.transformers.rotate.onDragUpdate(currentPoint), () => this.transformers.rotate.onDragEnd());
      const menuToggleButton = new SelectionMenuShortcut(this, this.editor.viewport, this.editor.icons.makeOverflowIcon(), showContextMenu, this.editor.localization);
      this.childwidgets = [
        menuToggleButton,
        resizeBothHandle,
        ...resizeHorizontalHandles,
        resizeVerticalHandle,
        rotationHandle
      ];
      for (const widget of this.childwidgets) {
        widget.addTo(this.backgroundElem);
      }
      this.recomputeRegion();
      this.updateUI();
    }
    // @internal Intended for unit tests
    getBackgroundElem() {
      return this.backgroundElem;
    }
    getTransform() {
      return this.transform;
    }
    get preTransformRegion() {
      return this.originalRegion;
    }
    // The **canvas** region.
    get region() {
      const rotationMatrix = Mat33.zRotation(this.regionRotation, this.originalRegion.center);
      const scaleAndTranslateMat = this.transform.rightMul(rotationMatrix.inverse());
      return this.originalRegion.transformedBoundingBox(scaleAndTranslateMat);
    }
    /**
     * Computes and returns the bounding box of the selection without
     * any additional padding. Computes directly from the elements that are selected.
     * @internal
     */
    computeTightBoundingBox() {
      const bbox = this.selectedElems.reduce((accumulator, elem) => {
        return (accumulator ?? elem.getBBox()).union(elem.getBBox());
      }, null);
      return bbox ?? Rect2.empty;
    }
    get regionRotation() {
      return this.transform.transformVec3(Vec2.unitX).angle();
    }
    get preTransformedScreenRegion() {
      const toScreen = (vec) => this.editor.viewport.canvasToScreen(vec);
      return Rect2.fromCorners(toScreen(this.preTransformRegion.topLeft), toScreen(this.preTransformRegion.bottomRight));
    }
    get preTransformedScreenRegionRotation() {
      return this.editor.viewport.getRotationAngle();
    }
    getScreenRegion() {
      const toScreen = this.editor.viewport.canvasToScreenTransform;
      const scaleFactor = this.editor.viewport.getScaleFactor();
      const screenCenter = toScreen.transformVec2(this.region.center);
      return new Rect2(screenCenter.x, screenCenter.y, scaleFactor * this.region.width, scaleFactor * this.region.height).translatedBy(this.region.size.times(-scaleFactor / 2));
    }
    get screenRegionRotation() {
      return this.regionRotation + this.editor.viewport.getRotationAngle();
    }
    // Applies, previews, but doesn't finalize the given transformation.
    setTransform(transform, preview = true) {
      this.transform = transform;
      if (preview && this.hasParent) {
        this.previewTransformCmds();
      }
    }
    getDeltaZIndexToMoveSelectionToTop() {
      if (this.selectedElems.length === 0) {
        return 0;
      }
      const selectedBottommostZIndex = this.selectedElems[0].getZIndex();
      const visibleObjects = this.editor.image.getComponentsIntersecting(this.region);
      const topMostVisibleZIndex = visibleObjects[visibleObjects.length - 1]?.getZIndex() ?? selectedBottommostZIndex;
      const deltaZIndex = topMostVisibleZIndex + 1 - selectedBottommostZIndex;
      return deltaZIndex;
    }
    // Applies the current transformation to the selection
    finalizeTransform() {
      const fullTransform = this.transform;
      const selectedElems = this.selectedElems;
      this.originalRegion = this.originalRegion.transformedBoundingBox(this.transform);
      this.transform = Mat33.identity;
      this.scrollTo();
      let transformPromise = void 0;
      if (this.selectedElems.length > 0) {
        const deltaZIndex = this.getDeltaZIndexToMoveSelectionToTop();
        transformPromise = this.editor.dispatch(new _a4.ApplyTransformationCommand(this, selectedElems, this.originalRegion.center, fullTransform, deltaZIndex));
      }
      return transformPromise;
    }
    /** Sends all selected elements to the bottom of the visible image. */
    sendToBack() {
      const visibleObjects = this.editor.image.getComponentsIntersecting(this.editor.viewport.visibleRect);
      const lowestVisibleZIndex = visibleObjects[0]?.getZIndex() ?? 0;
      const highestSelectedZIndex = this.selectedElems[this.selectedElems.length - 1]?.getZIndex() ?? 0;
      const targetHighestZIndex = lowestVisibleZIndex - 1;
      const deltaZIndex = targetHighestZIndex - highestSelectedZIndex;
      if (deltaZIndex !== 0) {
        const commands = this.selectedElems.map((elem) => {
          return elem.setZIndex(elem.getZIndex() + deltaZIndex);
        });
        return uniteCommands_default(commands, updateChunkSize);
      }
      return null;
    }
    // Preview the effects of the current transformation on the selection
    previewTransformCmds() {
      if (this.selectedElems.length === 0) {
        return;
      }
      if (this.selectedElems.length > maxPreviewElemCount) {
        this.updateUI();
        return;
      }
      const wetInkRenderer = this.editor.display.getWetInkRenderer();
      wetInkRenderer.clear();
      wetInkRenderer.pushTransform(this.transform);
      const viewportVisibleRect = this.editor.viewport.visibleRect.union(this.region);
      const visibleRect = viewportVisibleRect.transformedBoundingBox(this.transform.inverse());
      for (const elem of this.selectedElems) {
        elem.render(wetInkRenderer, visibleRect);
      }
      wetInkRenderer.popTransform();
      this.updateUI();
    }
    // Recompute this' region from the selected elements.
    // Returns false if the selection is empty.
    recomputeRegion() {
      const newRegion = this.computeTightBoundingBox();
      this.selectionTightBoundingBox = newRegion;
      if (!newRegion) {
        this.cancelSelection();
        return false;
      }
      this.originalRegion = newRegion;
      this.padRegion();
      return true;
    }
    // Applies padding to the current region if it is too small.
    // @internal
    padRegion() {
      const sourceRegion = this.selectionTightBoundingBox ?? this.originalRegion;
      const minSize = this.getMinCanvasSize();
      if (sourceRegion.w < minSize || sourceRegion.h < minSize) {
        const padding = minSize / 2;
        this.originalRegion = Rect2.bboxOf(sourceRegion.corners, padding);
        this.updateUI();
      }
    }
    getMinCanvasSize() {
      const canvasHandleSize = handleSize / this.editor.viewport.getScaleFactor();
      return canvasHandleSize * 2;
    }
    getSelectedItemCount() {
      return this.selectedElems.length;
    }
    // @internal
    updateUI() {
      if (!this.hasParent) {
        return;
      }
      const screenRegion = this.getScreenRegion();
      this.backgroundElem.style.marginLeft = `${screenRegion.topLeft.x}px`;
      this.backgroundElem.style.marginTop = `${screenRegion.topLeft.y}px`;
      this.backgroundElem.style.width = `${screenRegion.width}px`;
      this.backgroundElem.style.height = `${screenRegion.height}px`;
      const rotationDeg = this.screenRegionRotation * 180 / Math.PI;
      this.backgroundElem.style.transform = `rotate(${rotationDeg}deg)`;
      this.backgroundElem.style.transformOrigin = "center";
      const perpendicularClassName = `${cssPrefix}rotated-near-perpendicular`;
      if (Math.abs(Math.sin(this.screenRegionRotation)) > 0.5) {
        this.innerContainer.classList.add(perpendicularClassName);
      } else {
        this.innerContainer.classList.remove(perpendicularClassName);
      }
      if (screenRegion.width === 0 && screenRegion.height === 0) {
        this.innerContainer.classList.add("-empty");
      } else {
        this.innerContainer.classList.remove("-empty");
      }
      for (const widget of this.childwidgets) {
        widget.updatePosition(this.getScreenRegion());
      }
    }
    // Add/remove the contents of this seleciton from the editor.
    // Used to prevent previewed content from looking like duplicate content
    // while dragging.
    //
    // Does nothing if a large number of elements are selected (and so modifying
    // the editor image is likely to be slow.)
    //
    // If removed from the image, selected elements are drawn as wet ink.
    //
    // [inImage] should be `true` if the selected elements should be added to the
    // main image, `false` if they should be removed.
    addRemoveSelectionFromImage(inImage) {
      if (!inImage && this.selectedElems.length > maxPreviewElemCount) {
        return;
      }
      for (const elem of this.selectedElems) {
        const parent = this.editor.image.findParent(elem);
        if (!inImage && parent) {
          this.removedFromImage[elem.getId()] = true;
          parent.remove();
        } else if (!parent && this.removedFromImage[elem.getId()]) {
          EditorImage_default.addComponent(elem).apply(this.editor);
          this.removedFromImage[elem.getId()] = false;
          delete this.removedFromImage[elem.getId()];
        }
      }
      this.editor.queueRerender().then(() => {
        if (!inImage) {
          this.previewTransformCmds();
        } else {
          const wetInkRenderer = this.editor.display.getWetInkRenderer();
          wetInkRenderer.clear();
        }
      });
    }
    removeDeletedElemsFromSelection() {
      this.selectedElems = this.selectedElems.filter((elem) => {
        const hasParent = !!this.editor.image.findParent(elem);
        const weRemoved = this.removedFromImage[elem.getId()];
        return hasParent || weRemoved;
      });
    }
    onDragStart(pointer) {
      if (this.selectedElems.length === 0) {
        return false;
      }
      document.getSelection()?.removeAllRanges();
      this.activeHandle = null;
      let result = false;
      this.backgroundDragging = false;
      if (this.region.containsPoint(pointer.canvasPos)) {
        this.backgroundDragging = true;
        result = true;
      }
      for (const widget of this.childwidgets) {
        if (widget.containsPoint(pointer.canvasPos)) {
          this.activeHandle = widget;
          this.backgroundDragging = false;
          result = true;
        }
      }
      if (result) {
        this.removeDeletedElemsFromSelection();
        this.addRemoveSelectionFromImage(false);
      }
      if (this.activeHandle) {
        this.activeHandle.handleDragStart(pointer);
      }
      if (this.backgroundDragging) {
        this.transformers.drag.onDragStart(pointer.canvasPos);
      }
      return result;
    }
    onDragUpdate(pointer) {
      if (this.backgroundDragging) {
        this.transformers.drag.onDragUpdate(pointer.canvasPos);
      }
      if (this.activeHandle) {
        this.activeHandle.handleDragUpdate(pointer);
      }
    }
    onDragEnd() {
      if (this.backgroundDragging) {
        this.transformers.drag.onDragEnd();
      } else if (this.activeHandle) {
        this.activeHandle.handleDragEnd();
      }
      this.addRemoveSelectionFromImage(true);
      this.backgroundDragging = false;
      this.activeHandle = null;
      this.updateUI();
    }
    onDragCancel() {
      this.backgroundDragging = false;
      this.activeHandle = null;
      this.setTransform(Mat33.identity);
      this.addRemoveSelectionFromImage(true);
      this.updateUI();
    }
    // Scroll the viewport to this. Does not zoom
    scrollTo() {
      if (this.selectedElems.length === 0) {
        return false;
      }
      const screenSize = this.editor.viewport.getScreenRectSize();
      const screenRect = new Rect2(0, 0, screenSize.x, screenSize.y);
      const selectionScreenRegion = this.getScreenRegion();
      if (!screenRect.containsPoint(selectionScreenRegion.center)) {
        const targetPointScreen = selectionScreenRegion.center;
        const closestPointScreen = screenRect.getClosestPointOnBoundaryTo(targetPointScreen);
        const closestPointCanvas = this.editor.viewport.screenToCanvas(closestPointScreen);
        const targetPointCanvas = this.region.center;
        const delta = closestPointCanvas.minus(targetPointCanvas);
        this.editor.dispatchNoAnnounce(Viewport_default.transformBy(Mat33.translation(delta.times(0.5))), false);
        this.editor.queueRerender().then(() => {
          this.previewTransformCmds();
        });
        return true;
      }
      return false;
    }
    deleteSelectedObjects() {
      if (this.backgroundDragging || this.activeHandle) {
        this.onDragEnd();
      }
      return new Erase_default(this.selectedElems);
    }
    runSelectionDuplicatedAnimation() {
      if (this.selectionDuplicatedAnimationTimeout) {
        clearTimeout(this.selectionDuplicatedAnimationTimeout);
      }
      const animationDuration = 400;
      this.backgroundElem.style.animation = `${animationDuration}ms ease selection-duplicated-animation`;
      this.selectionDuplicatedAnimationTimeout = setTimeout(() => {
        this.backgroundElem.style.animation = "";
        this.selectionDuplicatedAnimationTimeout = null;
      }, animationDuration);
    }
    async duplicateSelectedObjects() {
      const wasTransforming = this.backgroundDragging || this.activeHandle;
      let tmpApplyCommand = null;
      if (!wasTransforming) {
        this.runSelectionDuplicatedAnimation();
      }
      let command;
      if (wasTransforming) {
        const selectionToUpdate = null;
        const deltaZIndex = this.getDeltaZIndexToMoveSelectionToTop();
        tmpApplyCommand = new _a4.ApplyTransformationCommand(selectionToUpdate, this.selectedElems, this.region.center, this.transform, deltaZIndex);
        await tmpApplyCommand.apply(this.editor);
        this.addRemoveSelectionFromImage(true);
        command = uniteCommands_default(this.selectedElems.map((elem) => {
          return EditorImage_default.addComponent(elem.clone());
        }));
        await tmpApplyCommand?.unapply(this.editor);
        this.addRemoveSelectionFromImage(false);
        this.previewTransformCmds();
        this.updateUI();
      } else {
        command = new Duplicate_default(this.selectedElems);
      }
      return command;
    }
    snapSelectedObjectsToGrid() {
      const viewport = this.editor.viewport;
      const topLeftOfBBox = this.computeTightBoundingBox().topLeft;
      const snappedTopLeft = viewport.snapToGrid(topLeftOfBBox);
      const snapDelta = snappedTopLeft.minus(topLeftOfBBox);
      const oldTransform = this.getTransform();
      this.setTransform(oldTransform.rightMul(Mat33.translation(snapDelta)));
      this.finalizeTransform();
    }
    setHandlesVisible(showHandles) {
      if (!showHandles) {
        this.innerContainer.classList.add("-hide-handles");
      } else {
        this.innerContainer.classList.remove("-hide-handles");
      }
    }
    addTo(elem) {
      if (this.outerContainer.parentElement) {
        this.outerContainer.remove();
      }
      elem.appendChild(this.outerContainer);
      this.hasParent = true;
    }
    setToPoint(point) {
      this.originalRegion = this.originalRegion.grownToPoint(point);
      this.selectionTightBoundingBox = null;
      this.updateUI();
    }
    cancelSelection() {
      if (this.outerContainer.parentElement) {
        this.outerContainer.remove();
      }
      this.originalRegion = Rect2.empty;
      this.selectionTightBoundingBox = null;
      this.hasParent = false;
    }
    getSelectedObjects() {
      return [...this.selectedElems];
    }
  };
  _a4 = Selection;
  (() => {
    SerializableCommand_default.register("selection-tool-transform", (json, _editor) => {
      const rawTransformArray = json.transform;
      const rawCenterArray = json.selectionCenter ?? [0, 0];
      const rawElementIds = json.elems ?? [];
      assertIsNumberArray(rawTransformArray);
      assertIsNumberArray(rawCenterArray);
      assertIsStringArray(rawElementIds);
      const fullTransform = new Mat33(...rawTransformArray);
      const elemIds = rawElementIds;
      const deltaZIndex = parseInt(json.deltaZIndex ?? 0);
      const center = Vec2.of(rawCenterArray[0] ?? 0, rawCenterArray[1] ?? 0);
      return new _a4.ApplyTransformationCommand(null, elemIds, center, fullTransform, deltaZIndex);
    });
  })();
  Selection.ApplyTransformationCommand = class extends SerializableCommand_default {
    constructor(selection, selectedElems, selectionCenter, fullTransform, deltaZIndex) {
      super("selection-tool-transform");
      this.selection = selection;
      this.selectionCenter = selectionCenter;
      this.fullTransform = fullTransform;
      this.deltaZIndex = deltaZIndex;
      const isIDList = (arr) => {
        return typeof arr[0] === "string";
      };
      if (isIDList(selectedElems)) {
        this.selectedElemIds = selectedElems;
      } else {
        this.selectedElemIds = selectedElems.map((elem) => elem.getId());
        this.transformCommands = selectedElems.map((elem) => {
          return elem.setZIndexAndTransformBy(this.fullTransform, elem.getZIndex() + deltaZIndex);
        });
      }
    }
    resolveToElems(editor, isUndoing) {
      if (this.transformCommands) {
        return;
      }
      this.transformCommands = this.selectedElemIds.map((id) => {
        const elem = editor.image.lookupElement(id);
        if (!elem) {
          console.warn(`Unable to find element with ID, ${id}.`);
          return null;
        }
        let originalZIndex = elem.getZIndex();
        let targetZIndex = elem.getZIndex() + this.deltaZIndex;
        if (isUndoing) {
          targetZIndex = elem.getZIndex();
          originalZIndex = elem.getZIndex() - this.deltaZIndex;
        }
        return elem.setZIndexAndTransformBy(this.fullTransform, targetZIndex, originalZIndex);
      }).filter(
        // Remove all null commands
        (command) => command !== null
      );
    }
    async apply(editor) {
      this.resolveToElems(editor, false);
      this.selection?.setTransform(this.fullTransform, false);
      this.selection?.updateUI();
      await editor.asyncApplyCommands(this.transformCommands, updateChunkSize);
      this.selection?.setTransform(Mat33.identity, false);
      this.selection?.recomputeRegion();
      this.selection?.updateUI();
    }
    async unapply(editor) {
      this.resolveToElems(editor, true);
      this.selection?.setTransform(this.fullTransform.inverse(), false);
      this.selection?.updateUI();
      await editor.asyncUnapplyCommands(this.transformCommands, updateChunkSize, true);
      this.selection?.setTransform(Mat33.identity, false);
      this.selection?.recomputeRegion();
      this.selection?.updateUI();
    }
    serializeToJSON() {
      return {
        elems: this.selectedElemIds,
        transform: this.fullTransform.toArray(),
        deltaZIndex: this.deltaZIndex,
        selectionCenter: this.selectionCenter.asArray()
      };
    }
    description(_editor, localizationTable) {
      return localizationTable.transformedElements(this.selectedElemIds.length, describeTransformation_default(this.selectionCenter, this.fullTransform, false, localizationTable));
    }
  };
  var Selection_default = Selection;

  // node_modules/js-draw/dist/mjs/tools/SelectionTool/ToPointerAutoscroller.mjs
  var ToPointerAutoscroller = class {
    constructor(viewport, scrollByCanvasDelta) {
      this.viewport = viewport;
      this.scrollByCanvasDelta = scrollByCanvasDelta;
      this.started = false;
      this.updateLoopId = 0;
      this.updateLoopRunning = false;
      this.targetPoint = null;
      this.scrollRate = 1e3;
    }
    getScrollForPoint(screenPoint) {
      const screenSize = this.viewport.getScreenRectSize();
      const screenRect = new Rect2(0, 0, screenSize.x, screenSize.y);
      const marginSize = 44;
      const autoscrollBoundary = screenRect.grownBy(-marginSize);
      if (autoscrollBoundary.containsPoint(screenPoint)) {
        return Vec2.zero;
      }
      const closestEdgePoint = autoscrollBoundary.getClosestPointOnBoundaryTo(screenPoint);
      const distToEdge = closestEdgePoint.distanceTo(screenPoint);
      const toEdge = closestEdgePoint.minus(screenPoint);
      const maximumScaleFactor = 1.25;
      const scaleFactor = Math.min(distToEdge / marginSize, maximumScaleFactor);
      return toEdge.normalizedOrZero().times(scaleFactor);
    }
    start() {
      this.started = true;
    }
    onPointerMove(pointerScreenPosition) {
      if (!this.started) {
        return;
      }
      if (this.getScrollForPoint(pointerScreenPosition) === Vec2.zero) {
        this.stopUpdateLoop();
      } else {
        this.targetPoint = pointerScreenPosition;
        this.startUpdateLoop();
      }
    }
    stop() {
      this.targetPoint = null;
      this.started = false;
      this.stopUpdateLoop();
    }
    startUpdateLoop() {
      if (this.updateLoopRunning) {
        return;
      }
      (async () => {
        this.updateLoopId++;
        const currentUpdateLoopId = this.updateLoopId;
        let lastUpdateTime = performance.now();
        while (this.updateLoopId === currentUpdateLoopId && this.targetPoint) {
          this.updateLoopRunning = true;
          const currentTime = performance.now();
          const deltaTimeMs = currentTime - lastUpdateTime;
          const scrollDirection = this.getScrollForPoint(this.targetPoint);
          const screenScrollAmount = scrollDirection.times(this.scrollRate * deltaTimeMs / 1e3);
          this.scrollByCanvasDelta(this.viewport.screenToCanvasTransform.transformVec3(screenScrollAmount));
          lastUpdateTime = currentTime;
          await untilNextAnimationFrame_default();
        }
        this.updateLoopRunning = false;
      })();
    }
    stopUpdateLoop() {
      this.updateLoopId++;
    }
  };

  // node_modules/js-draw/dist/mjs/util/waitForTimeout.mjs
  var waitForTimeout = (timeout) => {
    return new Promise((resolve) => {
      setTimeout(() => resolve(), timeout);
    });
  };
  var waitForTimeout_default = waitForTimeout;

  // node_modules/js-draw/dist/mjs/tools/util/createMenuOverlay.mjs
  var idCounter = 0;
  var createMenuOverlay = async (editor, canvasAnchor, options) => {
    const overlay = document.createElement("div");
    const { remove: removeOverlay } = editor.createHTMLOverlay(overlay);
    const menuModal = document.createElement("dialog");
    menuModal.classList.add("editor-popup-menu");
    const hideMenuTimeout = 240;
    menuModal.style.setProperty("--hide-menu-animation-timeout", `${hideMenuTimeout}ms`);
    const updateMenuLocation = () => {
      const overlayRect = editor.getOutputBBoxInDOM();
      const anchor = editor.viewport.canvasToScreen(canvasAnchor).plus(overlayRect.topLeft);
      menuModal.style.setProperty("--anchor-x", `${anchor.x}px`);
      menuModal.style.setProperty("--anchor-y", `${anchor.y}px`);
    };
    updateMenuLocation();
    const viewportChangeListener = editor.notifier.on(EditorEventType.ViewportChanged, updateMenuLocation);
    overlay.appendChild(menuModal);
    let dismissing = false;
    const dismissMenu = async () => {
      if (dismissing)
        return;
      dismissing = true;
      viewportChangeListener.remove();
      menuModal.classList.add("-hide");
      await waitForTimeout_default(hideMenuTimeout);
      menuModal.close();
    };
    return new Promise((resolve) => {
      let resolved = false;
      let result = null;
      const resolveWithSelectedResult = () => {
        if (!resolved) {
          resolve(result);
          resolved = true;
        }
      };
      menuModal.onclose = () => {
        removeOverlay();
        resolveWithSelectedResult();
      };
      const onOptionSelected = (key) => {
        result = key;
        void dismissMenu();
        resolveWithSelectedResult();
      };
      editor.handlePointerEventsExceptClicksFrom(menuModal, (eventName, event) => {
        if (event.target === menuModal && eventName === "pointerdown") {
          void dismissMenu();
          return true;
        } else if (dismissing) {
          return true;
        }
        return false;
      }, (_eventName, event) => {
        return event.target === menuModal;
      });
      const contentElement = document.createElement("div");
      contentElement.classList.add("content");
      contentElement.role = "menu";
      const optionElements = [];
      contentElement.addEventListener("keydown", (event) => {
        const focusedIndex = optionElements.findIndex((item) => item === document.activeElement);
        if (focusedIndex === -1)
          return;
        let newFocusedIndex = focusedIndex;
        if (event.key === "ArrowDown") {
          newFocusedIndex++;
        } else if (event.key === "ArrowUp") {
          newFocusedIndex--;
        } else if (event.key === "End") {
          newFocusedIndex = optionElements.length - 1;
        } else if (event.key === "Home") {
          newFocusedIndex = 0;
        }
        if (newFocusedIndex < 0) {
          newFocusedIndex += optionElements.length;
        }
        newFocusedIndex %= optionElements.length;
        if (newFocusedIndex !== focusedIndex) {
          event.preventDefault();
          optionElements[newFocusedIndex].focus();
        }
      });
      for (const option of options) {
        const optionElement = createButton_default({
          classList: ["option", "editor-popup-menu-option"],
          onClick: (event) => {
            if (event.defaultPrevented)
              return;
            onOptionSelected(option.key);
          }
        });
        optionElement.id = `menu-overlay-option-${idCounter++}`;
        optionElement.role = "menuitem";
        optionElement.replaceChildren(option.icon(), document.createTextNode(option.text));
        contentElement.appendChild(optionElement);
        if (optionElements.length === 0) {
          optionElement.autofocus = true;
        }
        optionElements.push(optionElement);
      }
      menuModal.appendChild(contentElement);
      menuModal.showModal();
      contentElement.scrollIntoView({ block: "nearest" });
    });
  };
  var createMenuOverlay_default = createMenuOverlay;

  // node_modules/js-draw/dist/mjs/util/fileToBase64Url.mjs
  var fileToBase64Url = async (file, options = {}) => {
    try {
      const reader = new FileReader();
      return await new Promise((resolve, reject) => {
        reader.onload = () => resolve(reader.result);
        reader.onerror = reject;
        reader.onabort = reject;
        reader.onprogress = (evt) => {
          options.onprogress?.(evt);
        };
        reader.readAsDataURL(file);
      });
    } catch (error) {
      (options.onWarning ?? console.warn)("Unable to convert file to base64 with a FileReader: ", error);
      const arrayBuffer = await file.arrayBuffer();
      const array = new Uint8Array(arrayBuffer);
      const step = 30;
      const result = [];
      for (let i = 0; i < array.length; i += step) {
        const stringByteArray = String.fromCharCode(...array.slice(i, i + step));
        result.push(btoa(stringByteArray));
      }
      return `data:${file.type ?? "image/*"};base64,${result.join("")}`;
    }
  };
  var fileToBase64Url_default = fileToBase64Url;

  // node_modules/js-draw/dist/mjs/util/ClipboardHandler.mjs
  var __classPrivateFieldGet7 = function(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var __classPrivateFieldSet7 = function(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var _ClipboardHandler_preferClipboardEvents;
  var isTextMimeType = (mime) => (
    // +xml: Handles image/svg+xml
    mime.endsWith("+xml") || mime.startsWith("text/")
  );
  var ClipboardHandler = class {
    constructor(editor, callbacks) {
      this.editor = editor;
      this.callbacks = callbacks;
      _ClipboardHandler_preferClipboardEvents.set(this, false);
    }
    /**
     * Pastes data from the clipboard into the editor associated with
     * this handler.
     *
     * @param event Optional -- a clipboard/drag event. If not provided,
     * 				`navigator.clipboard` will be used instead.
     * @returns true if the paste event was handled by the editor.
     */
    paste(event) {
      const onError = (error) => {
        if (this.callbacks?.onPasteError) {
          this.callbacks.onPasteError(error);
          return Promise.resolve(false);
        } else {
          throw error;
        }
      };
      try {
        return this.pasteInternal(event).catch(onError);
      } catch (error) {
        return onError(error);
      }
    }
    async pasteInternal(event) {
      const editor = this.editor;
      const clipboardData = event?.dataTransfer ?? event?.clipboardData ?? null;
      const hasEvent = !!clipboardData;
      const sendPasteEvent = (mime, data) => {
        return data && editor.toolController.dispatchInputEvent({
          kind: InputEvtType.PasteEvent,
          mime,
          data
        });
      };
      const supportedMIMEs = ["image/svg+xml", "text/html", "image/png", "image/jpeg", "text/plain"];
      let files = [];
      const textData = /* @__PURE__ */ new Map();
      const editorSettings = editor.getCurrentSettings();
      if (hasEvent) {
        files = [...clipboardData.files];
        for (const mime of supportedMIMEs) {
          const data = clipboardData.getData(mime);
          if (data) {
            textData.set(mime, data);
          }
        }
      } else if (editorSettings.clipboardApi) {
        const clipboardData2 = await editorSettings.clipboardApi.read();
        for (const [type, data] of clipboardData2.entries()) {
          if (typeof data === "string") {
            textData.set(type, data);
          } else {
            let blob = data;
            if (blob.type !== type) {
              blob = new Blob([blob], { type });
            }
            files.push(blob);
          }
        }
      } else {
        const clipboardData2 = await navigator.clipboard.read();
        for (const item of clipboardData2) {
          for (const mime of item.types) {
            if (supportedMIMEs.includes(mime)) {
              files.push(await item.getType(mime));
            }
          }
        }
      }
      const handleMIME = async (mime) => {
        const isTextFormat = isTextMimeType(mime);
        if (isTextFormat) {
          const data = textData.get(mime);
          if (sendPasteEvent(mime, data)) {
            event?.preventDefault();
            return true;
          }
        }
        for (const file of files) {
          const fileType = file?.type?.toLowerCase();
          if (fileType !== mime) {
            continue;
          }
          if (isTextFormat) {
            const text = await file.text();
            if (sendPasteEvent(mime, text)) {
              event?.preventDefault();
              return true;
            }
          } else {
            editor.showLoadingWarning(0);
            const onprogress = (evt) => {
              editor.showLoadingWarning(evt.loaded / evt.total);
            };
            try {
              const data = await fileToBase64Url_default(file, { onprogress });
              if (sendPasteEvent(mime, data)) {
                event?.preventDefault();
                editor.hideLoadingWarning();
                return true;
              }
            } catch (e) {
              console.error("Error reading image:", e);
            }
            editor.hideLoadingWarning();
          }
        }
        return false;
      };
      for (const mime of supportedMIMEs) {
        if (await handleMIME(mime)) {
          return true;
        }
      }
      return false;
    }
    /**
     * Copies text from the editor associated with this.
     *
     * Even if `event` is provided, the `navigator.clipboard` API may be used if image data
     * is to be copied. This is done because `ClipboardEvent`s seem to not support attaching
     * images.
     */
    copy(event) {
      const onError = (error) => {
        if (this.callbacks?.onCopyError) {
          this.callbacks.onCopyError(error);
          return Promise.resolve();
        } else {
          throw error;
        }
      };
      try {
        return this.copyInternal(event).catch(onError);
      } catch (error) {
        return onError(error);
      }
    }
    copyInternal(event) {
      const mimeToData = /* @__PURE__ */ new Map();
      if (this.editor.toolController.dispatchInputEvent({
        kind: InputEvtType.CopyEvent,
        setData: (mime, data) => {
          mimeToData.set(mime, data);
        }
      })) {
        event?.preventDefault();
      }
      const mimeTypes = [...mimeToData.keys()];
      const hasNonTextMimeTypes = mimeTypes.some((mime) => !isTextMimeType(mime));
      const copyToEvent = (reason) => {
        if (!event) {
          throw new Error(`Unable to copy -- no event provided${reason ? `. Original error: ${reason}` : ""}`);
        }
        for (const [key, value] of mimeToData.entries()) {
          if (typeof value === "string") {
            if ("clipboardData" in event) {
              event.clipboardData?.setData(key, value);
            } else {
              event.dataTransfer?.setData(key, value);
            }
          }
        }
      };
      const copyToClipboardApi = () => {
        const mapInternalDataToBrowserData = (originalMimeToData) => {
          const mappedMimeToData = /* @__PURE__ */ Object.create(null);
          for (const [key, data] of originalMimeToData.entries()) {
            if (typeof data === "string") {
              const loadedData = new Blob([new TextEncoder().encode(data)], { type: key });
              mappedMimeToData[key] = loadedData;
            } else {
              mappedMimeToData[key] = data;
            }
            if (key === "image/svg+xml") {
              mappedMimeToData["text/html"] ??= mappedMimeToData[key];
            }
          }
          return mappedMimeToData;
        };
        const removeUnsupportedMime = (originalMimeToData) => {
          const filteredMimeToData = /* @__PURE__ */ Object.create(null);
          for (const [key, data] of Object.entries(originalMimeToData)) {
            const unsupported = "supports" in ClipboardItem && typeof ClipboardItem.supports === "function" && !ClipboardItem.supports(key);
            if (!unsupported) {
              filteredMimeToData[key] = data;
            }
          }
          return filteredMimeToData;
        };
        const browserMimeToData = removeUnsupportedMime(mapInternalDataToBrowserData(mimeToData));
        return navigator.clipboard.write([new ClipboardItem(browserMimeToData)]);
      };
      const supportsClipboardApi = typeof ClipboardItem !== "undefined" && typeof navigator?.clipboard?.write !== "undefined";
      const prefersClipboardApi = !__classPrivateFieldGet7(this, _ClipboardHandler_preferClipboardEvents, "f") && supportsClipboardApi && (hasNonTextMimeTypes || !event);
      const editorSettings = this.editor.getCurrentSettings();
      if (prefersClipboardApi && editorSettings.clipboardApi) {
        const writeResult = editorSettings.clipboardApi.write(mimeToData);
        return writeResult ?? Promise.resolve();
      } else if (prefersClipboardApi) {
        let clipboardApiPromise = null;
        const fallBackToCopyEvent = (reason) => {
          console.warn("Unable to copy to the clipboard API. Future calls to .copy will use ClipboardEvents if possible.", reason);
          __classPrivateFieldSet7(this, _ClipboardHandler_preferClipboardEvents, true, "f");
          copyToEvent(reason);
        };
        try {
          clipboardApiPromise = copyToClipboardApi();
        } catch (error) {
          fallBackToCopyEvent(error);
        }
        if (clipboardApiPromise) {
          return clipboardApiPromise.catch(fallBackToCopyEvent);
        }
      } else {
        copyToEvent();
      }
      return Promise.resolve();
    }
  };
  _ClipboardHandler_preferClipboardEvents = /* @__PURE__ */ new WeakMap();
  var ClipboardHandler_default = ClipboardHandler;

  // node_modules/js-draw/dist/mjs/dialogs/makeMessageDialog.mjs
  var makeAboutDialog = (editor, options) => {
    const overlay = document.createElement("div");
    const { remove: removeOverlay } = editor.createHTMLOverlay(overlay);
    overlay.classList.add("dialog-container", "message-dialog-container", ...options.classNames ?? []);
    const dialog = document.createElement("dialog");
    const contentWrapper = document.createElement("div");
    contentWrapper.classList.add("message-dialog-content", ...options.contentClassNames ?? []);
    const heading = document.createElement("h1");
    heading.textContent = options.title;
    heading.setAttribute("autofocus", "true");
    const closeButton = createButton_default({
      text: editor.localization.closeDialog,
      classList: ["close"]
    });
    const scrollRegion = document.createElement("div");
    scrollRegion.classList.add("scroll");
    scrollRegion.onwheel = (evt) => evt.stopPropagation();
    contentWrapper.replaceChildren(heading, scrollRegion, closeButton);
    dialog.replaceChildren(contentWrapper);
    overlay.replaceChildren(dialog);
    const closeTimeout = 300;
    dialog.style.setProperty("--close-delay", `${closeTimeout}ms`);
    const closeDialog = async () => {
      dialog.classList.add("-closing");
      await waitForTimeout_default(closeTimeout);
      dialog.close();
    };
    const addCloseListeners = () => {
      dialog.addEventListener("pointerdown", (event) => {
        if (event.target === dialog) {
          void closeDialog();
        }
      });
      dialog.onclose = () => {
        removeOverlay();
      };
      closeButton.onclick = () => closeDialog();
    };
    addCloseListeners();
    dialog.showModal();
    return {
      close: () => {
        return closeDialog();
      },
      appendChild: (child) => {
        scrollRegion.appendChild(child);
      }
    };
  };
  var makeMessageDialog_default = makeAboutDialog;

  // node_modules/js-draw/dist/mjs/tools/SelectionTool/util/makeClipboardErrorHandlers.mjs
  var makeClipboardErrorHandlers = (editor) => {
    const makeErrorDialog = (error) => {
      const dialog = makeMessageDialog_default(editor, {
        title: editor.localization.copyPasteError__heading,
        classNames: ["clipboard-error-dialog"]
      });
      dialog.appendChild(document.createTextNode(editor.localization.copyPasteError__description));
      const errorDetailsElement = document.createElement("details");
      const errorDetailsSummary = document.createElement("summary");
      errorDetailsSummary.textContent = editor.localization.copyPasteError__errorDetails;
      errorDetailsElement.appendChild(errorDetailsSummary);
      errorDetailsElement.appendChild(document.createTextNode(`Error: ${error}`));
      dialog.appendChild(errorDetailsElement);
      return dialog;
    };
    return {
      onCopyError(error) {
        const dialog = makeErrorDialog(error);
        const textboxLabel = document.createElement("label");
        textboxLabel.textContent = editor.localization.copyPasteError__copyRetry;
        const copyTextbox = document.createElement("textarea");
        textboxLabel.appendChild(copyTextbox);
        const retryHandler = new ClipboardHandler_default(editor);
        const handleCopy = (event) => {
          event.preventDefault();
          return retryHandler.copy(event).then(() => {
            dialog.close();
          });
        };
        copyTextbox.oncopy = handleCopy;
        copyTextbox.ondragstart = handleCopy;
        copyTextbox.value = editor.localization.copyPasteError__copyMe;
        dialog.appendChild(textboxLabel);
        copyTextbox.select();
        document.execCommand("copy");
      },
      onPasteError(error) {
        const dialog = makeErrorDialog(error);
        const textboxLabel = document.createElement("label");
        textboxLabel.textContent = editor.localization.copyPasteError__pasteRetry;
        const pasteTextbox = document.createElement("textarea");
        textboxLabel.appendChild(pasteTextbox);
        const retryHandler = new ClipboardHandler_default(editor);
        const handlePaste = (event) => {
          event.preventDefault();
          return retryHandler.paste(event).then((pasted) => {
            if (pasted) {
              dialog.close();
            }
          });
        };
        pasteTextbox.onpaste = handlePaste;
        pasteTextbox.ondrop = handlePaste;
        dialog.appendChild(textboxLabel);
        pasteTextbox.focus();
        document.execCommand("paste");
      }
    };
  };
  var makeClipboardErrorHandlers_default = makeClipboardErrorHandlers;

  // node_modules/js-draw/dist/mjs/tools/SelectionTool/util/showSelectionContextMenu.mjs
  var showSelectionContextMenu = async (selectionBox, editor, canvasAnchor, preferSelectionMenu, clearSelection) => {
    const localization7 = editor.localization;
    const showSelectionMenu = selectionBox?.getSelectedItemCount() && preferSelectionMenu;
    const noSelectionMenu = [
      {
        text: localization7.selectionMenu__paste,
        icon: () => editor.icons.makePasteIcon(),
        key: () => {
          const clipboardHandler = new ClipboardHandler_default(editor, makeClipboardErrorHandlers_default(editor));
          void clipboardHandler.paste();
        }
      }
    ];
    const onActivated = await createMenuOverlay_default(editor, canvasAnchor, showSelectionMenu ? [
      {
        text: localization7.selectionMenu__duplicate,
        icon: () => editor.icons.makeDuplicateSelectionIcon(),
        key: async () => {
          await editor.dispatch(await selectionBox.duplicateSelectedObjects());
        }
      },
      {
        text: localization7.selectionMenu__delete,
        icon: () => editor.icons.makeDeleteSelectionIcon(),
        key: async () => {
          await editor.dispatch(selectionBox.deleteSelectedObjects());
          clearSelection();
        }
      },
      {
        text: localization7.selectionMenu__copyToClipboard,
        icon: () => editor.icons.makeCopyIcon(),
        key: () => {
          const clipboardHandler = new ClipboardHandler_default(editor, makeClipboardErrorHandlers_default(editor));
          void clipboardHandler.copy();
        }
      },
      ...noSelectionMenu
    ] : noSelectionMenu);
    onActivated?.();
  };
  var showSelectionContextMenu_default = showSelectionContextMenu;

  // node_modules/js-draw/dist/mjs/tools/SelectionTool/SelectionBuilders/SelectionBuilder.mjs
  var SelectionBuilder = class {
    /** Renders a preview of the selection bounds */
    render(renderer, color) {
      renderer.drawPath(pathToRenderable(this.previewPath(), { fill: color }));
    }
    /** Converts the selection preview into a set of selected elements */
    resolve(image, viewport) {
      const path = this.previewPath();
      const filterComponents = (components2) => {
        return components2.filter((component) => {
          return component.isSelectable();
        });
      };
      let components;
      const clickSize = viewport.getSizeOfPixelOnCanvas() * 3;
      const isClick = path.bbox.maxDimension <= clickSize;
      if (isClick) {
        const searchRegionSize = viewport.visibleRect.maxDimension / 200;
        const minSizeBox = path.bbox.grownBy(searchRegionSize);
        components = image.getComponentsIntersecting(minSizeBox).filter((component) => {
          return minSizeBox.containsRect(component.getBBox()) || component.intersectsRect(minSizeBox);
        });
        components = filterComponents(components);
        if (components.length > 1) {
          components = [components[0]];
        }
      } else {
        components = filterComponents(this.resolveInternal(image));
      }
      return components;
    }
  };

  // node_modules/js-draw/dist/mjs/tools/SelectionTool/SelectionBuilders/LassoSelectionBuilder.mjs
  var LassoSelectionBuilder = class extends SelectionBuilder {
    constructor(startPoint, viewport) {
      super();
      this.viewport = viewport;
      this.boundaryPoints = [];
      this.boundaryPoints.push(startPoint);
      this.lastPoint = startPoint;
    }
    onPointerMove(canvasPoint) {
      const lastBoundaryPoint = this.boundaryPoints[this.boundaryPoints.length - 1];
      const minBoundaryDist = this.viewport.getSizeOfPixelOnCanvas() * 8;
      if (lastBoundaryPoint.distanceTo(canvasPoint) >= minBoundaryDist) {
        this.boundaryPoints.push(canvasPoint);
      }
      this.lastPoint = canvasPoint;
    }
    previewPath() {
      const pathCommands = this.boundaryPoints.map((point) => {
        return { kind: PathCommandType.LineTo, point };
      });
      pathCommands.push({
        kind: PathCommandType.LineTo,
        point: this.lastPoint
      });
      return new Path(this.boundaryPoints[0], pathCommands).asClosed();
    }
    resolveInternal(image) {
      const path = this.previewPath();
      const lines = path.polylineApproximation();
      const candidates = image.getComponentsIntersecting(path.bbox);
      const componentIsInSelection = (component) => {
        if (path.closedContainsRect(component.getExactBBox())) {
          return true;
        }
        let hasKeyPoint = false;
        for (const point of component.keyPoints()) {
          if (path.closedContainsPoint(point)) {
            hasKeyPoint = true;
            break;
          }
        }
        if (!hasKeyPoint) {
          return false;
        }
        for (const line of lines) {
          if (component.intersects(line)) {
            return false;
          }
        }
        return true;
      };
      return candidates.filter(componentIsInSelection);
    }
  };

  // node_modules/js-draw/dist/mjs/tools/SelectionTool/SelectionBuilders/RectSelectionBuilder.mjs
  var RectSelectionBuilder = class extends SelectionBuilder {
    constructor(startPoint) {
      super();
      this.rect = Rect2.fromCorners(startPoint, startPoint);
    }
    onPointerMove(canvasPoint) {
      this.rect = this.rect.grownToPoint(canvasPoint);
    }
    previewPath() {
      return Path.fromRect(this.rect);
    }
    resolveInternal(image) {
      return image.getComponentsIntersecting(this.rect).filter((element) => {
        return element.intersectsRect(this.rect);
      });
    }
  };

  // node_modules/js-draw/dist/mjs/tools/SelectionTool/SelectionTool.mjs
  var cssPrefix = "selection-tool-";
  var SelectionTool = class extends BaseTool_default {
    constructor(editor, description) {
      super(editor.notifier, description);
      this.editor = editor;
      this.removeSelectionScheduled = false;
      this.startPoint = null;
      this.expandingSelectionBox = false;
      this.shiftKeyPressed = false;
      this.snapToGrid = false;
      this.lastPointer = null;
      this.showContextMenu = async (canvasAnchor, preferSelectionMenu = true) => {
        await showSelectionContextMenu_default(this.selectionBox, this.editor, canvasAnchor, preferSelectionMenu, () => this.clearSelection());
      };
      this.selectionBoxHandlingEvt = false;
      this.lastSelectedObjects = [];
      this.hasUnfinalizedTransformFromKeyPress = false;
      this.modeValue = MutableReactiveValue.fromInitialValue(SelectionMode.Rectangle);
      this.modeValue.onUpdate(() => {
        this.editor.notifier.dispatch(EditorEventType.ToolUpdated, {
          kind: EditorEventType.ToolUpdated,
          tool: this
        });
      });
      this.autoscroller = new ToPointerAutoscroller(editor.viewport, (scrollBy) => {
        editor.dispatch(Viewport_default.transformBy(Mat33.translation(scrollBy)), false);
        if (this.lastPointer) {
          const updatedPointer = this.lastPointer.withScreenPosition(this.lastPointer.screenPos, editor.viewport);
          this.onMainPointerUpdated(updatedPointer);
        }
      });
      this.handleOverlay = document.createElement("div");
      editor.createHTMLOverlay(this.handleOverlay);
      this.handleOverlay.style.display = "none";
      this.handleOverlay.classList.add("handleOverlay");
      editor.notifier.on(EditorEventType.ViewportChanged, (_data) => {
        this.editor.clearWetInk();
        if (!this.expandingSelectionBox) {
          this.selectionBox?.padRegion();
        }
        this.selectionBox?.updateUI();
      });
      this.editor.handleKeyEventsFrom(this.handleOverlay);
      this.editor.handlePointerEventsFrom(this.handleOverlay);
    }
    getSelectionColor() {
      const colorString = getComputedStyle(this.handleOverlay).getPropertyValue("--selection-background-color");
      return Color4.fromString(colorString).withAlpha(0.5);
    }
    makeSelectionBox(selectedObjects) {
      this.prevSelectionBox = this.selectionBox;
      this.selectionBox = new Selection_default(selectedObjects, this.editor, this.showContextMenu);
      if (!this.expandingSelectionBox) {
        this.prevSelectionBox?.cancelSelection();
      }
      this.selectionBox.addTo(this.handleOverlay);
    }
    onContextMenu(event) {
      const canShowSelectionMenu = this.selectionBox?.getScreenRegion()?.containsPoint(event.screenPos);
      void this.showContextMenu(event.canvasPos, canShowSelectionMenu);
      return true;
    }
    onPointerDown({ allPointers, current }) {
      const snapToGrid = this.snapToGrid;
      if (snapToGrid) {
        current = current.snappedToGrid(this.editor.viewport);
      }
      if (allPointers.length === 1) {
        this.startPoint = current.canvasPos;
        let transforming = false;
        if (this.selectionBox) {
          if (snapToGrid) {
            this.selectionBox.snapSelectedObjectsToGrid();
          }
          const dragStartResult = this.selectionBox.onDragStart(current);
          if (dragStartResult) {
            transforming = true;
            this.selectionBoxHandlingEvt = true;
            this.expandingSelectionBox = false;
          }
        }
        if (!transforming) {
          this.expandingSelectionBox = this.shiftKeyPressed;
          this.removeSelectionScheduled = !this.expandingSelectionBox;
          if (this.modeValue.get() === SelectionMode.Lasso) {
            this.selectionBuilder = new LassoSelectionBuilder(current.canvasPos, this.editor.viewport);
          } else {
            this.selectionBuilder = new RectSelectionBuilder(current.canvasPos);
          }
        } else {
          this.autoscroller.start();
        }
        return true;
      }
      return false;
    }
    onPointerMove(event) {
      this.onMainPointerUpdated(event.current);
    }
    onMainPointerUpdated(currentPointer) {
      this.lastPointer = currentPointer;
      if (this.removeSelectionScheduled) {
        this.removeSelectionScheduled = false;
        this.handleOverlay.replaceChildren();
        this.prevSelectionBox = this.selectionBox;
        this.selectionBox = null;
      }
      this.autoscroller.onPointerMove(currentPointer.screenPos);
      if (!this.expandingSelectionBox && this.shiftKeyPressed && this.startPoint) {
        const screenPos = this.editor.viewport.canvasToScreen(this.startPoint);
        currentPointer = currentPointer.lockedToXYAxesScreen(screenPos, this.editor.viewport);
      }
      if (this.snapToGrid) {
        currentPointer = currentPointer.snappedToGrid(this.editor.viewport);
      }
      if (this.selectionBoxHandlingEvt) {
        this.selectionBox?.onDragUpdate(currentPointer);
      } else {
        this.selectionBuilder?.onPointerMove(currentPointer.canvasPos);
        this.editor.clearWetInk();
        this.selectionBuilder?.render(this.editor.display.getWetInkRenderer(), this.getSelectionColor());
      }
    }
    onPointerUp(event) {
      this.onMainPointerUpdated(event.current);
      this.autoscroller.stop();
      if (this.selectionBoxHandlingEvt) {
        this.selectionBox?.onDragEnd();
      } else if (this.selectionBuilder) {
        const newSelection = this.selectionBuilder.resolve(this.editor.image, this.editor.viewport);
        this.selectionBuilder = null;
        this.editor.clearWetInk();
        if (this.expandingSelectionBox && this.selectionBox) {
          this.setSelection([...this.selectionBox.getSelectedObjects(), ...newSelection]);
        } else {
          this.setSelection(newSelection);
        }
      }
      this.expandingSelectionBox = false;
      this.removeSelectionScheduled = false;
      this.selectionBoxHandlingEvt = false;
      this.lastPointer = null;
    }
    onGestureCancel() {
      if (this.selectionBuilder) {
        this.selectionBuilder = null;
        this.editor.clearWetInk();
      }
      this.autoscroller.stop();
      if (this.selectionBoxHandlingEvt) {
        this.selectionBox?.onDragCancel();
      } else if (!this.removeSelectionScheduled) {
        this.selectionBox?.cancelSelection();
        this.selectionBox = this.prevSelectionBox;
        this.selectionBox?.addTo(this.handleOverlay);
        this.selectionBox?.recomputeRegion();
        this.prevSelectionBox = null;
      }
      this.removeSelectionScheduled = false;
      this.expandingSelectionBox = false;
      this.lastPointer = null;
      this.selectionBoxHandlingEvt = false;
    }
    onSelectionUpdated() {
      const selectedItemCount = this.selectionBox?.getSelectedItemCount() ?? 0;
      const selectedObjects = this.selectionBox?.getSelectedObjects() ?? [];
      const hasDifferentSelection = this.lastSelectedObjects.length !== selectedItemCount || selectedObjects.some((obj, i) => this.lastSelectedObjects[i] !== obj);
      if (hasDifferentSelection) {
        this.lastSelectedObjects = selectedObjects;
        this.editor.notifier.dispatch(EditorEventType.ToolUpdated, {
          kind: EditorEventType.ToolUpdated,
          tool: this
        });
        this.editor.notifier.dispatch(EditorEventType.SelectionUpdated, {
          kind: EditorEventType.SelectionUpdated,
          selectedComponents: selectedObjects,
          tool: this
        });
        if (selectedItemCount > 0) {
          this.editor.announceForAccessibility(this.editor.localization.selectedElements(selectedItemCount));
          this.zoomToSelection();
        }
      }
      if (selectedItemCount === 0 && this.selectionBox) {
        this.selectionBox.cancelSelection();
        this.prevSelectionBox = this.selectionBox;
        this.selectionBox = null;
      }
    }
    zoomToSelection() {
      if (this.selectionBox) {
        const selectionRect = this.selectionBox.region;
        this.editor.dispatchNoAnnounce(this.editor.viewport.zoomTo(selectionRect, false), false);
      }
    }
    onKeyPress(event) {
      const shortcucts = this.editor.shortcuts;
      if (shortcucts.matchesShortcut(snapToGridKeyboardShortcutId, event)) {
        this.snapToGrid = true;
        return true;
      }
      if (this.selectionBox && (shortcucts.matchesShortcut(duplicateSelectionShortcut, event) || shortcucts.matchesShortcut(sendToBackSelectionShortcut, event))) {
        return true;
      } else if (shortcucts.matchesShortcut(selectAllKeyboardShortcut, event)) {
        this.setSelection(this.editor.image.getAllComponents());
        return true;
      } else if (event.ctrlKey) {
        return false;
      } else if (event.shiftKey || event.key === "Shift") {
        this.shiftKeyPressed = true;
        if (event.key === "Shift") {
          return true;
        }
      }
      let rotationSteps = 0;
      let xTranslateSteps = 0;
      let yTranslateSteps = 0;
      let xScaleSteps = 0;
      let yScaleSteps = 0;
      if (shortcucts.matchesShortcut(translateLeftSelectionShortcutId, event)) {
        xTranslateSteps -= 1;
      } else if (shortcucts.matchesShortcut(translateRightSelectionShortcutId, event)) {
        xTranslateSteps += 1;
      } else if (shortcucts.matchesShortcut(translateUpSelectionShortcutId, event)) {
        yTranslateSteps -= 1;
      } else if (shortcucts.matchesShortcut(translateDownSelectionShortcutId, event)) {
        yTranslateSteps += 1;
      } else if (shortcucts.matchesShortcut(rotateClockwiseSelectionShortcutId, event)) {
        rotationSteps += 1;
      } else if (shortcucts.matchesShortcut(rotateCounterClockwiseSelectionShortcutId, event)) {
        rotationSteps -= 1;
      } else if (shortcucts.matchesShortcut(shrinkXSelectionShortcutId, event)) {
        xScaleSteps -= 1;
      } else if (shortcucts.matchesShortcut(stretchXSelectionShortcutId, event)) {
        xScaleSteps += 1;
      } else if (shortcucts.matchesShortcut(shrinkYSelectionShortcutId, event)) {
        yScaleSteps -= 1;
      } else if (shortcucts.matchesShortcut(stretchYSelectionShortcutId, event)) {
        yScaleSteps += 1;
      } else if (shortcucts.matchesShortcut(shrinkXYSelectionShortcutId, event)) {
        xScaleSteps -= 1;
        yScaleSteps -= 1;
      } else if (shortcucts.matchesShortcut(stretchXYSelectionShortcutId, event)) {
        xScaleSteps += 1;
        yScaleSteps += 1;
      }
      let handled = xTranslateSteps !== 0 || yTranslateSteps !== 0 || rotationSteps !== 0 || xScaleSteps !== 0 || yScaleSteps !== 0;
      if (!this.selectionBox) {
        handled = false;
      } else if (handled) {
        const translateStepSize = 10 * this.editor.viewport.getSizeOfPixelOnCanvas();
        const rotateStepSize = Math.PI / 8;
        const scaleStepSize = 5 / 4;
        const region = this.selectionBox.region;
        const scaleFactor = Vec2.of(scaleStepSize ** xScaleSteps, scaleStepSize ** yScaleSteps);
        const rotationMat = Mat33.zRotation(rotationSteps * rotateStepSize);
        const roundedRotationMatrix = rotationMat.mapEntries((component) => Viewport_default.roundScaleRatio(component));
        const regionCenter = this.editor.viewport.roundPoint(region.center);
        const transform = Mat33.scaling2D(scaleFactor, this.editor.viewport.roundPoint(region.topLeft)).rightMul(Mat33.translation(regionCenter).rightMul(roundedRotationMatrix).rightMul(Mat33.translation(regionCenter.times(-1)))).rightMul(Mat33.translation(this.editor.viewport.roundPoint(Vec2.of(xTranslateSteps, yTranslateSteps).times(translateStepSize))));
        const oldTransform = this.selectionBox.getTransform();
        this.selectionBox.setTransform(oldTransform.rightMul(transform));
        this.selectionBox.scrollTo();
        this.hasUnfinalizedTransformFromKeyPress = true;
      }
      if (this.selectionBox && !handled && (event.key === "Delete" || event.key === "Backspace")) {
        this.editor.dispatch(this.selectionBox.deleteSelectedObjects());
        this.clearSelection();
        handled = true;
      }
      return handled;
    }
    onKeyUp(evt) {
      const shortcucts = this.editor.shortcuts;
      if (shortcucts.matchesShortcut(snapToGridKeyboardShortcutId, evt)) {
        this.snapToGrid = false;
        return true;
      }
      if (shortcucts.matchesShortcut(selectAllKeyboardShortcut, evt)) {
        return true;
      }
      if (this.selectionBox && shortcucts.matchesShortcut(duplicateSelectionShortcut, evt)) {
        this.selectionBox.duplicateSelectedObjects().then((command) => {
          this.editor.dispatch(command);
        });
        return true;
      }
      if (this.selectionBox && shortcucts.matchesShortcut(sendToBackSelectionShortcut, evt)) {
        const sendToBackCommand = this.selectionBox.sendToBack();
        if (sendToBackCommand) {
          this.editor.dispatch(sendToBackCommand);
        }
        return true;
      }
      if (evt.shiftKey === false) {
        this.shiftKeyPressed = false;
      }
      if (evt.key === "Shift") {
        this.shiftKeyPressed = false;
        return true;
      }
      if (!this.hasUnfinalizedTransformFromKeyPress) {
        return true;
      }
      if (this.selectionBox) {
        this.selectionBox.finalizeTransform();
        this.hasUnfinalizedTransformFromKeyPress = false;
        return true;
      }
      return false;
    }
    onCopy(event) {
      if (!this.selectionBox) {
        return false;
      }
      const selectedElems = this.selectionBox.getSelectedObjects();
      const bbox = this.selectionBox.region;
      if (selectedElems.length === 0) {
        return false;
      }
      const exportViewport = new Viewport_default(() => {
      });
      const selectionScreenSize = this.selectionBox.getScreenRegion().size.times(this.editor.display.getDevicePixelRatio());
      let scaleFactor = selectionScreenSize.maximumEntryMagnitude() / (bbox.size.maximumEntryMagnitude() || 1);
      scaleFactor = Math.pow(2, Math.ceil(Math.log2(scaleFactor)));
      exportViewport.updateScreenSize(bbox.size.times(scaleFactor));
      exportViewport.resetTransform(Mat33.scaling2D(scaleFactor).rightMul(Mat33.translation(bbox.topLeft.times(-1))));
      const { element: svgExportElem, renderer: svgRenderer } = SVGRenderer.fromViewport(exportViewport, { sanitize: true, useViewBoxForPositioning: true });
      const { element: canvas, renderer: canvasRenderer } = CanvasRenderer.fromViewport(exportViewport, { maxCanvasDimen: 4096 });
      const text = [];
      for (const elem of selectedElems) {
        elem.render(svgRenderer);
        elem.render(canvasRenderer);
        if (elem instanceof TextComponent_default) {
          text.push(elem.getText());
        }
      }
      event.setData("image/svg+xml", svgExportElem.outerHTML);
      event.setData("text/html", svgExportElem.outerHTML);
      event.setData("image/png", new Promise((resolve, reject) => {
        canvas.toBlob((blob) => {
          if (blob) {
            resolve(blob);
          } else {
            reject(new Error("Failed to convert canvas to blob."));
          }
        }, "image/png");
      }));
      if (text.length > 0) {
        event.setData("text/plain", text.join("\n"));
      }
      return true;
    }
    setEnabled(enabled) {
      const wasEnabled = this.isEnabled();
      super.setEnabled(enabled);
      if (wasEnabled === enabled) {
        return;
      }
      this.selectionBox?.cancelSelection();
      this.onSelectionUpdated();
      this.handleOverlay.replaceChildren();
      this.selectionBox = null;
      this.shiftKeyPressed = false;
      this.snapToGrid = false;
      this.handleOverlay.style.display = enabled ? "block" : "none";
      if (enabled) {
        this.handleOverlay.tabIndex = 0;
        this.handleOverlay.role = "group";
        this.handleOverlay.ariaLabel = this.editor.localization.selectionToolKeyboardShortcuts;
      } else {
        this.handleOverlay.tabIndex = -1;
      }
    }
    // Get the object responsible for displaying this' selection.
    // @internal
    getSelection() {
      return this.selectionBox;
    }
    /** @returns true if the selection is currently being created by the user. */
    isSelecting() {
      return !!this.selectionBuilder;
    }
    getSelectedObjects() {
      return this.selectionBox?.getSelectedObjects() ?? [];
    }
    // Select the given `objects`. Any non-selectable objects in `objects` are ignored.
    setSelection(objects) {
      objects = objects.filter((obj) => obj.isSelectable());
      objects.sort((a, b) => a.getZIndex() - b.getZIndex());
      objects = objects.filter((current, idx) => {
        if (idx > 0) {
          return current !== objects[idx - 1];
        }
        return true;
      });
      let bbox = null;
      for (const object of objects) {
        if (bbox) {
          bbox = bbox.union(object.getBBox());
        } else {
          bbox = object.getBBox();
        }
      }
      this.clearSelectionNoUpdateEvent();
      if (bbox) {
        this.makeSelectionBox(objects);
      }
      this.onSelectionUpdated();
    }
    // Equivalent to .clearSelection, but does not dispatch an update event
    clearSelectionNoUpdateEvent() {
      this.handleOverlay.replaceChildren();
      this.prevSelectionBox = this.selectionBox;
      this.selectionBox = null;
    }
    clearSelection() {
      this.clearSelectionNoUpdateEvent();
      this.onSelectionUpdated();
    }
  };

  // node_modules/js-draw/dist/mjs/tools/UndoRedoShortcut.mjs
  var UndoRedoShortcut = class extends BaseTool_default {
    constructor(editor) {
      super(editor.notifier, editor.localization.undoRedoTool);
      this.editor = editor;
    }
    // @internal
    onKeyPress(event) {
      if (this.editor.shortcuts.matchesShortcut(undoKeyboardShortcutId, event)) {
        void this.editor.history.undo();
        return true;
      } else if (this.editor.shortcuts.matchesShortcut(redoKeyboardShortcutId, event)) {
        void this.editor.history.redo();
        return true;
      }
      return false;
    }
  };

  // node_modules/js-draw/dist/mjs/tools/TextTool.mjs
  var overlayCSSClass = "textEditorOverlay";
  var TextTool = class extends BaseTool_default {
    constructor(editor, description, localizationTable) {
      super(editor.notifier, description);
      this.editor = editor;
      this.localizationTable = localizationTable;
      this.textInputElem = null;
      this.textMeasuringCtx = null;
      this.removeExistingCommand = null;
      const editorFonts = editor.getCurrentSettings().text?.fonts ?? [];
      this.textStyleValue = ReactiveValue.fromInitialValue({
        size: 32,
        fontFamily: editorFonts.length > 0 ? editorFonts[0] : "sans-serif",
        renderingStyle: {
          fill: Color4.purple
        }
      });
      this.textStyleValue.onUpdateAndNow(() => {
        this.textStyle = this.textStyleValue.get();
        this.updateTextInput();
        this.editor.notifier.dispatch(EditorEventType.ToolUpdated, {
          kind: EditorEventType.ToolUpdated,
          tool: this
        });
      });
      this.contentTransform = ReactiveValue.fromInitialValue(Mat33.identity);
      this.textEditOverlay = document.createElement("div");
      this.textEditOverlay.classList.add(overlayCSSClass);
      this.editor.addStyleSheet(`
			.${overlayCSSClass} textarea {
				background-color: rgba(0, 0, 0, 0);

				white-space: pre;
				overflow: hidden;

				padding: 0;
				margin: 0;
				border: none;
				padding: 0;

				min-width: 100px;
				min-height: 1.1em;
			}
		`);
      this.anchorControl = this.editor.anchorElementToCanvas(this.textEditOverlay, this.contentTransform);
    }
    initTextMeasuringCanvas() {
      this.textMeasuringCtx ??= document.createElement("canvas").getContext("2d");
    }
    getTextAscent(text, style) {
      this.initTextMeasuringCanvas();
      if (this.textMeasuringCtx) {
        this.textMeasuringCtx.textBaseline = "alphabetic";
        TextComponent_default.applyTextStyles(this.textMeasuringCtx, style);
        const measurement = this.textMeasuringCtx.measureText(text);
        return measurement.fontBoundingBoxAscent ?? measurement.actualBoundingBoxAscent;
      }
      return style.size * 2 / 3;
    }
    // Take input from this' textInputElem and add it to the EditorImage.
    // If [removeInput], the HTML input element is removed. Otherwise, its value
    // is cleared.
    flushInput(removeInput = true) {
      if (!this.textInputElem)
        return;
      const scrollingRegion = this.textEditOverlay.parentElement;
      const containerScroll = Vec2.of(scrollingRegion?.scrollLeft ?? 0, scrollingRegion?.scrollTop ?? 0);
      const content = this.textInputElem.value.trimEnd();
      this.textInputElem.value = "";
      if (removeInput) {
        const input = this.textInputElem;
        this.textInputElem = null;
        input.remove();
      }
      if (content !== "") {
        const scrollCorrectionScreen = containerScroll.times(-1);
        const scrollCorrectionCanvas = this.editor.viewport.screenToCanvasTransform.transformVec3(scrollCorrectionScreen);
        const scrollTransform = Mat33.translation(scrollCorrectionCanvas);
        const textComponent = TextComponent_default.fromLines(content.split("\n"), scrollTransform.rightMul(this.contentTransform.get()), this.textStyle);
        const action = EditorImage_default.addComponent(textComponent);
        if (this.removeExistingCommand) {
          this.removeExistingCommand.unapply(this.editor);
          this.editor.dispatch(uniteCommands_default([this.removeExistingCommand, action]));
          this.removeExistingCommand = null;
        } else {
          this.editor.dispatch(action);
        }
      }
    }
    updateTextInput() {
      if (!this.textInputElem) {
        return;
      }
      this.textInputElem.placeholder = this.localizationTable.enterTextToInsert;
      this.textInputElem.style.fontFamily = this.textStyle.fontFamily;
      this.textInputElem.style.fontStyle = this.textStyle.fontStyle ?? "";
      this.textInputElem.style.fontVariant = this.textStyle.fontVariant ?? "";
      this.textInputElem.style.fontWeight = this.textStyle.fontWeight ?? "";
      this.textInputElem.style.fontSize = `${this.textStyle.size}px`;
      this.textInputElem.style.color = this.textStyle.renderingStyle.fill.toHexString();
      this.textInputElem.style.margin = "0";
      this.textInputElem.style.width = `${this.textInputElem.scrollWidth}px`;
      this.textInputElem.style.height = `${this.textInputElem.scrollHeight}px`;
      const tallText = "Testing!";
      const ascent = this.getTextAscent(tallText, this.textStyle);
      const vertAdjust = ascent;
      this.textInputElem.style.transform = `translate(0, ${-vertAdjust}px)`;
      this.textInputElem.style.transformOrigin = "top left";
      const lineHeight = Math.floor(this.textStyle.size);
      this.textInputElem.style.lineHeight = `${lineHeight}px`;
    }
    startTextInput(textCanvasPos, initialText) {
      this.flushInput();
      this.textInputElem = document.createElement("textarea");
      this.textInputElem.value = initialText;
      this.textInputElem.style.display = "inline-block";
      const textTargetPosition = this.editor.viewport.roundPoint(textCanvasPos);
      const textRotation = -this.editor.viewport.getRotationAngle();
      const textScale = Vec2.of(1, 1).times(this.editor.viewport.getSizeOfPixelOnCanvas());
      this.contentTransform.set(
        // Scale, then rotate, then translate:
        Mat33.translation(textTargetPosition).rightMul(Mat33.zRotation(textRotation)).rightMul(Mat33.scaling2D(textScale))
      );
      this.updateTextInput();
      setTimeout(() => this.updateTextInput(), 0);
      this.textInputElem.oninput = () => {
        if (this.textInputElem) {
          this.textInputElem.style.width = `${this.textInputElem.scrollWidth}px`;
          this.textInputElem.style.height = `${this.textInputElem.scrollHeight}px`;
        }
      };
      this.textInputElem.onblur = () => {
        const input = this.textInputElem;
        const removeInput = false;
        this.flushInput(removeInput);
        this.textInputElem = null;
        if (input) {
          input.classList.add("-hiding");
        }
        setTimeout(() => {
          input?.remove();
        }, 0);
      };
      this.textInputElem.onkeyup = (evt) => {
        if (evt.isComposing)
          return;
        if (evt.key === "Enter" && !evt.shiftKey) {
          this.flushInput();
          this.editor.focus();
        } else if (evt.key === "Escape") {
          this.textInputElem?.remove();
          this.textInputElem = null;
          this.editor.focus();
          this.removeExistingCommand?.unapply(this.editor);
          this.removeExistingCommand = null;
        }
      };
      this.textEditOverlay.replaceChildren(this.textInputElem);
      setTimeout(() => this.textInputElem?.focus(), 0);
    }
    setEnabled(enabled) {
      super.setEnabled(enabled);
      if (!this.isEnabled()) {
        this.flushInput();
      }
      this.textEditOverlay.style.display = enabled ? "block" : "none";
    }
    onPointerDown({ current, allPointers }) {
      if (current.device === PointerDevice.Eraser) {
        return false;
      }
      if (allPointers.length === 1) {
        const canvasPos = current.canvasPos;
        const halfTestRegionSize = Vec2.of(4, 4).times(this.editor.viewport.getSizeOfPixelOnCanvas());
        const testRegion = Rect2.fromCorners(canvasPos.minus(halfTestRegionSize), canvasPos.plus(halfTestRegionSize));
        const targetNodes = this.editor.image.getComponentsIntersecting(testRegion);
        let targetTextNodes = targetNodes.filter((node) => node instanceof TextComponent_default);
        const visibleRect = this.editor.viewport.visibleRect;
        targetTextNodes = targetTextNodes.filter((node) => !node.getBBox().containsRect(visibleRect));
        this.flushInput();
        if (targetTextNodes.length > 0) {
          const targetNode = targetTextNodes[targetTextNodes.length - 1];
          this.setTextStyle(targetNode.getTextStyle());
          this.removeExistingCommand = new Erase_default([targetNode]);
          this.removeExistingCommand.apply(this.editor);
          this.startTextInput(targetNode.getBaselinePos(), targetNode.getText());
          this.contentTransform.set(targetNode.getTransform());
          this.updateTextInput();
        } else {
          this.removeExistingCommand = null;
          this.startTextInput(current.canvasPos, "");
        }
        return true;
      }
      return false;
    }
    onGestureCancel() {
      this.flushInput();
      this.editor.focus();
    }
    setFontFamily(fontFamily) {
      if (fontFamily !== this.textStyle.fontFamily) {
        this.textStyleValue.set({
          ...this.textStyle,
          fontFamily
        });
      }
    }
    setColor(color) {
      if (!color.eq(this.textStyle.renderingStyle.fill)) {
        this.textStyleValue.set({
          ...this.textStyle,
          renderingStyle: {
            ...this.textStyle.renderingStyle,
            fill: color
          }
        });
      }
    }
    setFontSize(size) {
      if (size !== this.textStyle.size) {
        this.textStyleValue.set({
          ...this.textStyle,
          size
        });
      }
    }
    getTextStyle() {
      return this.textStyle;
    }
    getStyleValue() {
      return this.textStyleValue;
    }
    setTextStyle(style) {
      this.textStyleValue.set(style);
    }
    // @internal
    onDestroy() {
      super.onDestroy();
      this.anchorControl.remove();
    }
  };

  // node_modules/js-draw/dist/mjs/tools/PipetteTool.mjs
  var PipetteTool = class extends BaseTool_default {
    constructor(editor, description) {
      super(editor.notifier, description);
      this.editor = editor;
      this.colorPreviewListener = null;
      this.colorSelectListener = null;
      this.enabledValue().onUpdateAndNow(() => {
        this.updateSelectingStatus();
      });
    }
    canReceiveInputInReadOnlyEditor() {
      return true;
    }
    // Ensures that the root editor element correctly reflects whether color selection
    // is in progress.
    updateSelectingStatus() {
      const className = "pipette--color-selection-in-progress";
      if (this.isEnabled() && this.colorSelectListener && this.colorPreviewListener) {
        this.editor.getRootElement().classList.add(className);
      } else {
        this.editor.getRootElement().classList.remove(className);
      }
    }
    setColorListener(colorPreviewListener, colorSelectListener) {
      this.colorPreviewListener = colorPreviewListener;
      this.colorSelectListener = colorSelectListener;
      this.updateSelectingStatus();
    }
    clearColorListener() {
      this.colorPreviewListener = null;
      this.colorSelectListener = null;
      this.updateSelectingStatus();
    }
    onPointerDown({ current, allPointers }) {
      if (this.colorPreviewListener && allPointers.length === 1) {
        this.colorPreviewListener(this.editor.display.getColorAt(current.screenPos));
        return true;
      }
      return false;
    }
    onPointerMove({ current }) {
      this.colorPreviewListener?.(this.editor.display.getColorAt(current.screenPos));
    }
    onPointerUp({ current }) {
      this.colorSelectListener?.(this.editor.display.getColorAt(current.screenPos));
    }
    onGestureCancel() {
      this.colorSelectListener?.(null);
    }
  };

  // node_modules/js-draw/dist/mjs/tools/ToolSwitcherShortcut.mjs
  var ToolSwitcherShortcut = class extends BaseTool_default {
    constructor(editor) {
      super(editor.notifier, editor.localization.changeTool);
      this.editor = editor;
    }
    canReceiveInputInReadOnlyEditor() {
      return true;
    }
    // @internal
    onKeyPress({ key }) {
      const toolController = this.editor.toolController;
      const primaryTools = toolController.getPrimaryTools();
      const keyMatch = /^[0-9]$/.exec(key);
      let targetTool;
      if (keyMatch) {
        const targetIdx = parseInt(keyMatch[0], 10) - 1;
        targetTool = primaryTools[targetIdx];
      }
      if (targetTool) {
        targetTool.setEnabled(true);
        return true;
      }
      return false;
    }
  };

  // node_modules/js-draw/dist/mjs/tools/PasteHandler.mjs
  var PasteHandler = class extends BaseTool_default {
    constructor(editor) {
      super(editor.notifier, editor.localization.pasteHandler);
      this.editor = editor;
    }
    // @internal
    onPaste(event, onComplete) {
      const mime = event.mime.toLowerCase();
      const svgData = (() => {
        if (mime === "image/svg+xml") {
          return event.data;
        }
        if (mime === "text/plain") {
          const trimmedData = event.data.trim();
          if (trimmedData.startsWith("<svg") && trimmedData.endsWith("</svg>")) {
            return trimmedData;
          }
        }
        if (mime !== "text/html") {
          return false;
        }
        const match = event.data.match(/^[^]{0,200}<svg.*/i);
        if (!match) {
          return false;
        }
        let svgEnd = event.data.toLowerCase().lastIndexOf("</svg>");
        if (svgEnd === -1)
          svgEnd = event.data.length;
        return event.data.substring(event.data.search(/<svg/i), svgEnd);
      })();
      if (svgData) {
        void this.doSVGPaste(svgData).then(onComplete);
        return true;
      } else if (mime === "text/plain") {
        void this.doTextPaste(event.data).then(onComplete);
        return true;
      } else if (mime === "image/png" || mime === "image/jpeg") {
        void this.doImagePaste(event.data).then(onComplete);
        return true;
      }
      return false;
    }
    async addComponentsFromPaste(components) {
      await this.editor.addAndCenterComponents(components, true, this.editor.localization.pasted(components.length));
    }
    async doSVGPaste(data) {
      this.editor.showLoadingWarning(0);
      try {
        const loader = SVGLoader.fromString(data, {
          sanitize: true,
          plugins: this.editor.getCurrentSettings().svg?.loaderPlugins ?? []
        });
        const components = [];
        await loader.start((component) => {
          components.push(component);
        }, (_countProcessed, _totalToProcess) => null);
        await this.addComponentsFromPaste(components);
      } finally {
        this.editor.hideLoadingWarning();
      }
    }
    async doTextPaste(text) {
      const textTools = this.editor.toolController.getMatchingTools(TextTool);
      textTools.sort((a, b) => {
        if (!a.isEnabled() && b.isEnabled()) {
          return -1;
        }
        if (!b.isEnabled() && a.isEnabled()) {
          return 1;
        }
        return 0;
      });
      const defaultTextStyle3 = {
        size: 12,
        fontFamily: "sans",
        renderingStyle: { fill: Color4.red }
      };
      const pastedTextStyle = textTools[0]?.getTextStyle() ?? defaultTextStyle3;
      if (text.trim() === "") {
        return;
      }
      const lines = text.split("\n");
      await this.addComponentsFromPaste([
        TextComponent_default.fromLines(lines, Mat33.identity, pastedTextStyle)
      ]);
    }
    async doImagePaste(dataURL) {
      const image = new Image();
      image.src = dataURL;
      const component = await ImageComponent.fromImage(image, Mat33.identity);
      await this.addComponentsFromPaste([component]);
    }
  };

  // node_modules/js-draw/dist/mjs/tools/ToolbarShortcutHandler.mjs
  var ToolbarShortcutHandler = class extends BaseTool_default {
    constructor(editor) {
      super(editor.notifier, editor.localization.changeTool);
      this.listeners = /* @__PURE__ */ new Set([]);
    }
    registerListener(listener) {
      this.listeners.add(listener);
    }
    removeListener(listener) {
      this.listeners.delete(listener);
    }
    onKeyPress(event) {
      const listeners = Array.from(this.listeners.values());
      for (const listener of listeners) {
        if (listener(event)) {
          return true;
        }
      }
      return false;
    }
  };

  // node_modules/js-draw/dist/mjs/components/builders/PressureSensitiveFreehandLineBuilder.mjs
  var makePressureSensitiveFreehandLineBuilder = makeShapeFitAutocorrect_default((initialPoint, viewport) => {
    const maxSmoothingDist = viewport.getSizeOfPixelOnCanvas() * 3;
    const minSmoothingDist = viewport.getSizeOfPixelOnCanvas();
    return new PressureSensitiveFreehandLineBuilder(initialPoint, minSmoothingDist, maxSmoothingDist, viewport);
  });
  var PressureSensitiveFreehandLineBuilder = class {
    constructor(startPoint, minFitAllowed, maxFitAllowed, viewport) {
      this.startPoint = startPoint;
      this.minFitAllowed = minFitAllowed;
      this.viewport = viewport;
      this.isFirstSegment = true;
      this.pathStartConnector = null;
      this.mostRecentConnector = null;
      this.nextCurveStartConnector = null;
      this.lastUpperBezier = null;
      this.lastLowerBezier = null;
      this.parts = [];
      this.upperSegments = [];
      this.lowerSegments = [];
      this.curveFitter = new StrokeSmoother(startPoint, minFitAllowed, maxFitAllowed, (curve) => this.addCurve(curve));
      this.curveStartWidth = startPoint.width;
      this.bbox = new Rect2(this.startPoint.pos.x, this.startPoint.pos.y, 0, 0);
    }
    getBBox() {
      return this.bbox;
    }
    getRenderingStyle() {
      return {
        fill: this.startPoint.color ?? null
      };
    }
    previewCurrentPath(extendWithLatest = true) {
      const upperPath = this.upperSegments.slice();
      const lowerPath = this.lowerSegments.slice();
      let lowerToUpperCap;
      let pathStartConnector;
      const currentCurve = this.curveFitter.preview();
      if (currentCurve && extendWithLatest) {
        const { upperCurveCommand, lowerToUpperConnector, upperToLowerConnector, lowerCurveCommand } = this.segmentToPath(currentCurve);
        upperPath.push(upperCurveCommand);
        lowerPath.push(lowerCurveCommand);
        lowerToUpperCap = lowerToUpperConnector;
        pathStartConnector = this.pathStartConnector ?? [upperToLowerConnector];
      } else {
        if (this.mostRecentConnector === null || this.pathStartConnector === null) {
          return null;
        }
        lowerToUpperCap = this.mostRecentConnector;
        pathStartConnector = this.pathStartConnector;
      }
      let startPoint;
      const lastLowerSegment = lowerPath[lowerPath.length - 1];
      if (lastLowerSegment.kind === PathCommandType.LineTo || lastLowerSegment.kind === PathCommandType.MoveTo) {
        startPoint = lastLowerSegment.point;
      } else {
        startPoint = lastLowerSegment.endPoint;
      }
      return {
        // Start at the end of the lower curve:
        //    Start point
        //     
        //  __/  __/  Most recent points on this end
        // /___ /
        //  
        //  Oldest points
        startPoint,
        commands: [
          // Move to the most recent point on the upperPath:
          //     ----
          //  __/  __/
          // /___ /
          lowerToUpperCap,
          // Move to the beginning of the upperPath:
          //  __/  __/
          // /___ /
          //      -
          ...upperPath.reverse(),
          // Move to the beginning of the lowerPath:
          //  __/  __/
          // /___ /
          // 
          ...pathStartConnector,
          // Move back to the start point:
          //     
          //  __/  __/
          // /___ /
          ...lowerPath
        ],
        style: this.getRenderingStyle()
      };
    }
    previewFullPath() {
      const preview = this.previewCurrentPath();
      if (preview) {
        return [...this.parts, preview];
      }
      return null;
    }
    preview(renderer) {
      const paths = this.previewFullPath();
      if (paths) {
        const approxBBox = this.viewport.visibleRect;
        renderer.startObject(approxBBox);
        for (const path of paths) {
          renderer.drawPath(path);
        }
        renderer.endObject();
      }
    }
    build() {
      this.curveFitter.finalizeCurrentCurve();
      if (this.isFirstSegment) {
        this.addCurve(null);
      }
      return new Stroke(this.previewFullPath());
    }
    roundPoint(point) {
      let minFit = Math.min(this.minFitAllowed, this.curveStartWidth / 3);
      if (minFit < 1e-10) {
        minFit = this.minFitAllowed;
      }
      return Viewport_default.roundPoint(point, minFit);
    }
    // Returns true if, due to overlap with previous segments, a new RenderablePathSpec should be created.
    shouldStartNewSegment(lowerCurve, upperCurve) {
      if (!this.lastLowerBezier || !this.lastUpperBezier) {
        return false;
      }
      const getIntersection = (curve1, curve2) => {
        const intersections = curve1.intersectsBezier(curve2);
        if (!intersections.length)
          return null;
        return intersections[0].point;
      };
      const getExitDirection = (curve) => {
        return curve.p2.minus(curve.p1).normalized();
      };
      const getEnterDirection = (curve) => {
        return curve.p1.minus(curve.p0).normalized();
      };
      if (getEnterDirection(upperCurve).dot(getExitDirection(this.lastUpperBezier)) < 0.35 || getEnterDirection(lowerCurve).dot(getExitDirection(this.lastLowerBezier)) < 0.35 || // Also handle if the curves exit/enter directions differ
      getEnterDirection(upperCurve).dot(getExitDirection(upperCurve)) < 0 || getEnterDirection(lowerCurve).dot(getExitDirection(lowerCurve)) < 0) {
        return true;
      }
      const lowerIntersection = getIntersection(lowerCurve, this.lastUpperBezier);
      const upperIntersection = getIntersection(upperCurve, this.lastLowerBezier);
      if (lowerIntersection || upperIntersection) {
        return true;
      }
      return false;
    }
    getCurrentRadius() {
      return Viewport_default.roundPoint(this.startPoint.width / 2.2, Math.min(this.minFitAllowed, this.startPoint.width / 4));
    }
    addCurve(curve) {
      if (!curve) {
        if (!this.isFirstSegment) {
          return;
        }
        const radius = this.getCurrentRadius();
        const center = this.roundPoint(this.startPoint.pos);
        const startPoint = this.startPoint.pos.plus(Vec2.of(radius, 0));
        this.lowerSegments.push({
          kind: PathCommandType.QuadraticBezierTo,
          controlPoint: center.plus(Vec2.of(radius, radius)),
          // Bottom of the circle
          //    |
          //  -----
          //    |
          //    
          endPoint: center.plus(Vec2.of(0, radius))
        }, {
          kind: PathCommandType.QuadraticBezierTo,
          controlPoint: center.plus(Vec2.of(-radius, radius)),
          endPoint: center.plus(Vec2.of(-radius, 0))
        }, {
          kind: PathCommandType.QuadraticBezierTo,
          controlPoint: center.plus(Vec2.of(-radius, -radius)),
          endPoint: center.plus(Vec2.of(0, -radius))
        }, {
          kind: PathCommandType.QuadraticBezierTo,
          controlPoint: center.plus(Vec2.of(radius, -radius)),
          endPoint: center.plus(Vec2.of(radius, 0))
        });
        const connector = {
          kind: PathCommandType.LineTo,
          point: startPoint
        };
        this.pathStartConnector = [connector];
        this.mostRecentConnector = connector;
        return;
      }
      const { upperCurveCommand, lowerToUpperConnector, upperToLowerConnector, lowerCurveCommand, lowerCurve, upperCurve, nextCurveStartConnector } = this.segmentToPath(curve);
      let shouldStartNew = this.shouldStartNewSegment(lowerCurve, upperCurve);
      if (shouldStartNew) {
        const part = this.previewCurrentPath(false);
        if (part) {
          this.parts.push(part);
          this.upperSegments = [];
          this.lowerSegments = [];
        } else {
          shouldStartNew = false;
        }
      }
      if (this.isFirstSegment || shouldStartNew) {
        this.pathStartConnector = this.nextCurveStartConnector ?? [upperToLowerConnector];
        this.isFirstSegment = false;
      }
      this.mostRecentConnector = lowerToUpperConnector;
      this.nextCurveStartConnector = nextCurveStartConnector;
      this.lowerSegments.push(lowerCurveCommand);
      this.upperSegments.push(upperCurveCommand);
      this.lastLowerBezier = lowerCurve;
      this.lastUpperBezier = upperCurve;
      this.curveStartWidth = curve.startWidth;
    }
    // Returns [upper curve, connector, lower curve]
    segmentToPath(curve) {
      const bezier = new QuadraticBezier(curve.startPoint, curve.controlPoint, curve.endPoint);
      let startVec = bezier.normal(0);
      let endVec = bezier.normal(1);
      startVec = startVec.times(curve.startWidth / 2);
      endVec = endVec.times(curve.endWidth / 2);
      if (!isFinite(startVec.magnitude())) {
        console.error("Warning: startVec is NaN or \u221E", startVec, endVec, curve);
        startVec = endVec;
      }
      const startPt = curve.startPoint;
      const endPt = curve.endPoint;
      const controlPoint = curve.controlPoint;
      const projectionT = bezier.nearestPointTo(controlPoint).parameterValue;
      const halfVecT = projectionT;
      const halfVec = bezier.normal(halfVecT).times(curve.startWidth / 2 * halfVecT + curve.endWidth / 2 * (1 - halfVecT));
      const lowerCurveStartPoint = this.roundPoint(startPt.plus(startVec));
      const lowerCurveControlPoint = this.roundPoint(controlPoint.plus(halfVec));
      const lowerCurveEndPoint = this.roundPoint(endPt.plus(endVec));
      const upperCurveControlPoint = this.roundPoint(controlPoint.minus(halfVec));
      const upperCurveStartPoint = this.roundPoint(endPt.minus(endVec));
      const upperCurveEndPoint = this.roundPoint(startPt.minus(startVec));
      const lowerCurveCommand = {
        kind: PathCommandType.QuadraticBezierTo,
        controlPoint: lowerCurveControlPoint,
        endPoint: lowerCurveEndPoint
      };
      const upperToLowerConnector = {
        kind: PathCommandType.LineTo,
        point: lowerCurveStartPoint
      };
      const lowerToUpperConnector = {
        kind: PathCommandType.LineTo,
        point: upperCurveStartPoint
      };
      const nextCurveStartConnector = [
        {
          kind: PathCommandType.LineTo,
          point: upperCurveStartPoint
        },
        {
          kind: PathCommandType.LineTo,
          point: lowerCurveEndPoint
        }
      ];
      const upperCurveCommand = {
        kind: PathCommandType.QuadraticBezierTo,
        controlPoint: upperCurveControlPoint,
        endPoint: upperCurveEndPoint
      };
      const upperCurve = new QuadraticBezier(upperCurveStartPoint, upperCurveControlPoint, upperCurveEndPoint);
      const lowerCurve = new QuadraticBezier(lowerCurveStartPoint, lowerCurveControlPoint, lowerCurveEndPoint);
      return {
        upperCurveCommand,
        upperToLowerConnector,
        lowerToUpperConnector,
        lowerCurveCommand,
        upperCurve,
        lowerCurve,
        nextCurveStartConnector
      };
    }
    addPoint(newPoint) {
      this.curveFitter.addPoint(newPoint);
    }
  };

  // node_modules/js-draw/dist/mjs/tools/FindTool.mjs
  var cssPrefix2 = "find-tool";
  var FindTool = class extends BaseTool_default {
    constructor(editor) {
      super(editor.notifier, editor.localization.findLabel);
      this.editor = editor;
      this.currentMatchIdx = 0;
      this.overlay = document.createElement("div");
      this.fillOverlay();
      editor.createHTMLOverlay(this.overlay);
      this.overlay.style.display = "none";
      this.overlay.classList.add(`${cssPrefix2}-overlay`);
    }
    canReceiveInputInReadOnlyEditor() {
      return true;
    }
    getMatches(searchFor) {
      const lowerSearchFor = searchFor.toLocaleLowerCase();
      const matchingComponents = this.editor.image.getAllComponents().filter((component) => {
        let text = "";
        if (component instanceof TextComponent_default) {
          text = component.getText();
        } else if (component instanceof ImageComponent) {
          text = component.getAltText() ?? "";
        } else {
          return false;
        }
        const hasLowercaseMatch = text.toLocaleLowerCase().indexOf(lowerSearchFor) !== -1;
        const hasSameCaseMatch = text.indexOf(searchFor) !== -1;
        return hasLowercaseMatch || hasSameCaseMatch;
      });
      return matchingComponents.map((match) => match.getBBox());
    }
    focusCurrentMatch() {
      const matches = this.getMatches(this.searchInput.value);
      let matchIdx = this.currentMatchIdx % matches.length;
      if (matchIdx < 0) {
        matchIdx = matches.length + matchIdx;
      }
      if (matchIdx < matches.length) {
        const undoable = false;
        void this.editor.dispatch(this.editor.viewport.zoomTo(matches[matchIdx], true, true), undoable);
        this.editor.announceForAccessibility(this.editor.localization.focusedFoundText(matchIdx + 1, matches.length));
      }
    }
    toNextMatch() {
      this.currentMatchIdx++;
      this.focusCurrentMatch();
    }
    toPrevMatch() {
      this.currentMatchIdx--;
      this.focusCurrentMatch();
    }
    fillOverlay() {
      const label = document.createElement("label");
      this.searchInput = document.createElement("input");
      const nextBtn = createButton_default();
      const closeBtn = createButton_default();
      this.searchInput.setAttribute("id", `${cssPrefix2}-searchInput-${Math.random()}`);
      label.htmlFor = this.searchInput.getAttribute("id");
      label.innerText = this.editor.localization.findLabel;
      nextBtn.innerText = this.editor.localization.toNextMatch;
      closeBtn.innerText = this.editor.localization.closeDialog;
      this.searchInput.onkeydown = (ev) => {
        if (ev.key === "Enter") {
          if (ev.shiftKey) {
            this.toPrevMatch();
          } else {
            this.toNextMatch();
          }
        } else if (ev.key === "Escape") {
          this.setVisible(false);
        } else if (this.editor.shortcuts.matchesShortcut(toggleFindVisibleShortcutId, ev)) {
          ev.preventDefault();
          this.toggleVisible();
        }
      };
      nextBtn.onclick = () => {
        this.toNextMatch();
      };
      closeBtn.onclick = () => {
        this.setVisible(false);
      };
      this.overlay.replaceChildren(label, this.searchInput, nextBtn, closeBtn);
    }
    isVisible() {
      return this.overlay.style.display !== "none";
    }
    setVisible(visible) {
      if (visible !== this.isVisible()) {
        this.overlay.style.display = visible ? "block" : "none";
        if (visible) {
          this.searchInput.focus();
          this.editor.announceForAccessibility(this.editor.localization.findDialogShown);
        } else {
          this.editor.focus();
          this.editor.announceForAccessibility(this.editor.localization.findDialogHidden);
        }
      }
    }
    toggleVisible() {
      this.setVisible(!this.isVisible());
    }
    onKeyPress(event) {
      if (this.editor.shortcuts.matchesShortcut(toggleFindVisibleShortcutId, event)) {
        this.toggleVisible();
        return true;
      }
      return false;
    }
    setEnabled(enabled) {
      super.setEnabled(enabled);
      if (this.isEnabled()) {
        this.setVisible(false);
      }
    }
  };

  // node_modules/js-draw/dist/mjs/tools/SelectionTool/SelectAllShortcutHandler.mjs
  var SelectAllShortcutHandler = class extends BaseTool_default {
    constructor(editor) {
      super(editor.notifier, editor.localization.selectAllTool);
      this.editor = editor;
    }
    canReceiveInputInReadOnlyEditor() {
      return true;
    }
    // @internal
    onKeyPress(event) {
      if (this.editor.shortcuts.matchesShortcut(selectAllKeyboardShortcut, event)) {
        const selectionTools = this.editor.toolController.getMatchingTools(SelectionTool);
        if (selectionTools.length > 0) {
          const selectionTool = selectionTools[0];
          selectionTool.setEnabled(true);
          selectionTool.setSelection(this.editor.image.getAllComponents());
          return true;
        }
      }
      return false;
    }
  };

  // node_modules/js-draw/dist/mjs/tools/SoundUITool.mjs
  var SoundFeedback = class {
    constructor() {
      this.closed = false;
      if (!window.AudioContext) {
        console.warn("Accessibility sound UI: Unable to open AudioContext.");
        this.closed = true;
        return;
      }
      this.ctx = new AudioContext();
      this.colorOscHue = this.ctx.createOscillator();
      this.colorOscValue = this.ctx.createOscillator();
      this.colorOscSaturation = this.ctx.createOscillator();
      this.colorOscHue.type = "triangle";
      this.colorOscSaturation.type = "sine";
      this.colorOscValue.type = "sawtooth";
      this.valueGain = this.ctx.createGain();
      this.colorOscValue.connect(this.valueGain);
      this.valueGain.gain.setValueAtTime(0.18, this.ctx.currentTime);
      this.colorGain = this.ctx.createGain();
      this.colorOscHue.connect(this.colorGain);
      this.valueGain.connect(this.colorGain);
      this.colorOscSaturation.connect(this.colorGain);
      this.colorGain.connect(this.ctx.destination);
      this.boundaryGain = this.ctx.createGain();
      this.boundaryOsc = this.ctx.createOscillator();
      this.boundaryOsc.type = "sawtooth";
      this.boundaryGain.gain.setValueAtTime(0, this.ctx.currentTime);
      this.boundaryOsc.connect(this.boundaryGain);
      this.boundaryGain.connect(this.ctx.destination);
      this.colorOscHue.start();
      this.colorOscSaturation.start();
      this.colorOscValue.start();
      this.boundaryOsc.start();
      this.pause();
    }
    pause() {
      if (this.closed)
        return;
      this.colorGain.gain.setValueAtTime(0, this.ctx.currentTime);
      void this.ctx.suspend();
    }
    play() {
      if (this.closed)
        return;
      void this.ctx.resume();
    }
    setColor(color) {
      const hsv = color.asHSV();
      const hueFrequency = -Math.cos(hsv.x / 2) * 220 + 440;
      const saturationFrequency = hsv.y * 440 + 220;
      const valueFrequency = (hsv.z + 0.1) * 440;
      const gain = 0.25 * Math.min(1, color.a) / (1 + Math.exp(-(hsv.z - 0.5) * 3));
      this.colorOscHue.frequency.setValueAtTime(hueFrequency, this.ctx.currentTime);
      this.colorOscSaturation.frequency.setValueAtTime(saturationFrequency, this.ctx.currentTime);
      this.colorOscValue.frequency.setValueAtTime(valueFrequency, this.ctx.currentTime);
      this.valueGain.gain.setValueAtTime((1 - hsv.z) * 0.4, this.ctx.currentTime);
      this.colorGain.gain.setValueAtTime(gain, this.ctx.currentTime);
    }
    announceBoundaryCross(boundaryCrossCount) {
      this.boundaryGain.gain.cancelScheduledValues(this.ctx.currentTime);
      this.boundaryGain.gain.setValueAtTime(0, this.ctx.currentTime);
      this.boundaryGain.gain.linearRampToValueAtTime(0.018, this.ctx.currentTime + 0.1);
      this.boundaryOsc.frequency.setValueAtTime(440 + Math.atan(boundaryCrossCount / 2) * 100, this.ctx.currentTime);
      this.boundaryGain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.25);
    }
    close() {
      void this.ctx.close();
      this.closed = true;
    }
  };
  var SoundUITool = class extends BaseTool_default {
    constructor(editor, description) {
      super(editor.notifier, description);
      this.editor = editor;
      this.soundFeedback = null;
      this.toggleButtonContainer = document.createElement("div");
      this.toggleButtonContainer.classList.add("js-draw-sound-ui-toggle");
      this.toggleButton = createButton_default({
        onClick: () => {
          this.setEnabled(!this.isEnabled());
        }
      });
      this.toggleButtonContainer.appendChild(this.toggleButton);
      this.updateToggleButtonText();
      editor.createHTMLOverlay(this.toggleButtonContainer);
    }
    canReceiveInputInReadOnlyEditor() {
      return true;
    }
    updateToggleButtonText() {
      const containerEnabledClass = "sound-ui-tool-enabled";
      if (this.isEnabled()) {
        this.toggleButton.innerText = this.editor.localization.disableAccessibilityExploreTool;
        this.toggleButtonContainer.classList.add(containerEnabledClass);
      } else {
        this.toggleButton.innerText = this.editor.localization.enableAccessibilityExploreTool;
        this.toggleButtonContainer.classList.remove(containerEnabledClass);
      }
    }
    setEnabled(enabled) {
      super.setEnabled(enabled);
      if (!this.isEnabled()) {
        this.soundFeedback?.close();
        this.soundFeedback = null;
      } else {
        this.editor.announceForAccessibility(this.editor.localization.soundExplorerUsageAnnouncement);
      }
      this.updateToggleButtonText();
    }
    onKeyPress(event) {
      if (event.code === "Escape") {
        this.setEnabled(false);
        return true;
      }
      return false;
    }
    onPointerDown({ current, allPointers }) {
      if (!this.soundFeedback) {
        this.soundFeedback = new SoundFeedback();
      }
      if (allPointers.length >= 2) {
        return false;
      }
      this.soundFeedback?.play();
      this.soundFeedback?.setColor(this.editor.display.getColorAt(current.screenPos) ?? Color4.black);
      this.lastPointerPos = current.canvasPos;
      return true;
    }
    onPointerMove({ current }) {
      this.soundFeedback?.setColor(this.editor.display.getColorAt(current.screenPos) ?? Color4.black);
      const pointerMotionLine = new LineSegment2(this.lastPointerPos, current.canvasPos);
      const collisions = this.editor.image.getComponentsIntersecting(pointerMotionLine.bbox).filter((component) => component.intersects(pointerMotionLine));
      this.lastPointerPos = current.canvasPos;
      if (collisions.length > 0) {
        this.soundFeedback?.announceBoundaryCross(collisions.length);
      }
    }
    onPointerUp(_event) {
      this.soundFeedback?.pause();
    }
    onGestureCancel() {
      this.soundFeedback?.pause();
    }
  };

  // node_modules/js-draw/dist/mjs/tools/InputFilter/InputPipeline.mjs
  var __classPrivateFieldGet8 = function(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var __classPrivateFieldSet8 = function(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var _InputPipeline_head;
  var _InputPipeline_tail;
  var InputPipeline = class extends InputMapper_default {
    constructor() {
      super(...arguments);
      _InputPipeline_head.set(this, null);
      _InputPipeline_tail.set(this, null);
    }
    onEvent(event) {
      if (__classPrivateFieldGet8(this, _InputPipeline_head, "f") === null) {
        return this.emit(event);
      } else {
        return __classPrivateFieldGet8(this, _InputPipeline_head, "f").onEvent(event);
      }
    }
    /**
     * Adds a new `InputMapper` to the *tail* of this pipeline.
     * Note that an instance of an `InputMapper` can only be used in a single
     * pipeline.
     */
    addToTail(mapper) {
      if (!__classPrivateFieldGet8(this, _InputPipeline_tail, "f")) {
        __classPrivateFieldSet8(this, _InputPipeline_head, mapper, "f");
        __classPrivateFieldSet8(this, _InputPipeline_tail, __classPrivateFieldGet8(this, _InputPipeline_head, "f"), "f");
      } else {
        __classPrivateFieldGet8(this, _InputPipeline_tail, "f").setEmitListener(mapper);
        __classPrivateFieldSet8(this, _InputPipeline_tail, mapper, "f");
      }
      __classPrivateFieldGet8(this, _InputPipeline_tail, "f").setEmitListener((event) => this.emit(event));
    }
  };
  _InputPipeline_head = /* @__PURE__ */ new WeakMap(), _InputPipeline_tail = /* @__PURE__ */ new WeakMap();
  var InputPipeline_default = InputPipeline;

  // node_modules/js-draw/dist/mjs/tools/ScrollbarTool.mjs
  var ScrollbarTool = class extends BaseTool_default {
    constructor(editor) {
      super(editor.notifier, "scrollbar");
      this.editor = editor;
      this.fadeOutTimeout = null;
      this.scrollbarOverlay = document.createElement("div");
      this.scrollbarOverlay.classList.add("ScrollbarTool-overlay");
      this.verticalScrollbar = document.createElement("div");
      this.verticalScrollbar.classList.add("vertical-scrollbar");
      this.horizontalScrollbar = document.createElement("div");
      this.horizontalScrollbar.classList.add("horizontal-scrollbar");
      this.scrollbarOverlay.replaceChildren(this.verticalScrollbar, this.horizontalScrollbar);
      let overlay = null;
      let viewportListener = null;
      this.enabledValue().onUpdateAndNow((enabled) => {
        overlay?.remove();
        viewportListener?.remove();
        viewportListener = null;
        overlay = null;
        if (enabled) {
          viewportListener = editor.notifier.on(EditorEventType.ViewportChanged, (_event) => {
            this.updateScrollbars();
          });
          this.updateScrollbars();
          overlay = editor.createHTMLOverlay(this.scrollbarOverlay);
        }
      });
    }
    updateScrollbars() {
      const viewport = this.editor.viewport;
      const screenSize = viewport.getScreenRectSize();
      const screenRect = new Rect2(0, 0, screenSize.x, screenSize.y);
      const imageRect = this.editor.getImportExportRect().transformedBoundingBox(viewport.canvasToScreenTransform).union(screenRect);
      const scrollbarWidth = screenRect.width / imageRect.width * screenSize.x;
      const scrollbarHeight = screenRect.height / imageRect.height * screenSize.y;
      const scrollbarX = (screenRect.x - imageRect.x) / imageRect.width * screenSize.x;
      const scrollbarY = (screenRect.y - imageRect.y) / imageRect.height * screenSize.y;
      this.horizontalScrollbar.style.width = `${scrollbarWidth}px`;
      this.verticalScrollbar.style.height = `${scrollbarHeight}px`;
      this.horizontalScrollbar.style.marginLeft = `${scrollbarX}px`;
      this.verticalScrollbar.style.marginTop = `${scrollbarY}px`;
      const handleNoScrollStyling = (scrollbar, size, fillSize) => {
        const fillsWindowClass = "represents-no-scroll";
        if (Math.abs(size - fillSize) < 1e-8) {
          scrollbar.classList.add(fillsWindowClass);
        } else {
          scrollbar.classList.remove(fillsWindowClass);
        }
      };
      handleNoScrollStyling(this.horizontalScrollbar, scrollbarWidth, screenSize.x);
      handleNoScrollStyling(this.verticalScrollbar, scrollbarHeight, screenSize.y);
      if (this.fadeOutTimeout !== null) {
        clearTimeout(this.fadeOutTimeout);
      }
      const fadeOutDelay = 3e3;
      this.fadeOutTimeout = setTimeout(() => {
        this.scrollbarOverlay.classList.remove("just-updated");
      }, fadeOutDelay);
      this.scrollbarOverlay.classList.add("just-updated");
    }
  };

  // node_modules/js-draw/dist/mjs/tools/ToolController.mjs
  var ToolController = class {
    /** @internal */
    constructor(editor, localization7) {
      this.activeTool = null;
      this.isEditorReadOnly = editor.isReadOnlyReactiveValue();
      this.inputPipeline = new InputPipeline_default();
      this.inputPipeline.setEmitListener((event) => this.onEventInternal(event));
      const primaryToolGroup = new ToolEnabledGroup();
      this.primaryToolGroup = primaryToolGroup;
      const panZoomTool = new PanZoom(editor, PanZoomMode.TwoFingerTouchGestures | PanZoomMode.RightClickDrags, localization7.touchPanTool);
      const keyboardPanZoomTool = new PanZoom(editor, PanZoomMode.Keyboard, localization7.keyboardPanZoom);
      const primaryPenTool = new Pen(editor, localization7.penTool(1), {
        color: Color4.purple,
        thickness: 8
      });
      const secondaryPenTool = new Pen(editor, localization7.penTool(2), {
        color: Color4.clay,
        thickness: 4
      });
      secondaryPenTool.setInputMapper(new InputStabilizer(editor.viewport));
      const eraser = new Eraser(editor, localization7.eraserTool);
      const primaryTools = [
        // Three pens
        primaryPenTool,
        secondaryPenTool,
        // Highlighter-like pen with width=40
        new Pen(editor, localization7.penTool(3), {
          color: Color4.ofRGBA(1, 1, 0, 0.5),
          thickness: 40,
          factory: makePressureSensitiveFreehandLineBuilder
        }),
        eraser,
        new SelectionTool(editor, localization7.selectionTool),
        new TextTool(editor, localization7.textTool, localization7),
        new PanZoom(editor, PanZoomMode.SinglePointerGestures, localization7.anyDevicePanning)
      ];
      const soundExplorer = new SoundUITool(editor, localization7.soundExplorer);
      soundExplorer.setEnabled(false);
      this.tools = [
        new ScrollbarTool(editor),
        new PipetteTool(editor, localization7.pipetteTool),
        soundExplorer,
        panZoomTool,
        ...primaryTools,
        keyboardPanZoomTool,
        new UndoRedoShortcut(editor),
        new ToolbarShortcutHandler(editor),
        new ToolSwitcherShortcut(editor),
        eraser.makeEraserSwitcherTool(),
        new FindTool(editor),
        new PasteHandler(editor),
        new SelectAllShortcutHandler(editor)
      ];
      primaryTools.forEach((tool) => tool.setToolGroup(primaryToolGroup));
      panZoomTool.setEnabled(true);
      primaryPenTool.setEnabled(true);
      editor.notifier.on(EditorEventType.ToolEnabled, (event) => {
        if (event.kind === EditorEventType.ToolEnabled) {
          editor.announceForAccessibility(localization7.toolEnabledAnnouncement(event.tool.description));
        }
      });
      editor.notifier.on(EditorEventType.ToolDisabled, (event) => {
        if (event.kind === EditorEventType.ToolDisabled) {
          editor.announceForAccessibility(localization7.toolDisabledAnnouncement(event.tool.description));
        }
      });
      this.activeTool = null;
    }
    /**
     * Replaces the current set of tools with `tools`. This should only be done before
     * the creation of the app's toolbar (if using `AbstractToolbar`).
     *
     * If no `primaryToolGroup` is given, an empty one will be created.
     */
    setTools(tools, primaryToolGroup) {
      this.tools = tools;
      this.primaryToolGroup = primaryToolGroup ?? new ToolEnabledGroup();
    }
    /**
     * Add a tool that acts like one of the primary tools (only one primary tool can be enabled at a time).
     *
     * If the tool is already added to this, the tool is converted to a primary tool.
     *
     * This should be called before creating the app's toolbar.
     */
    addPrimaryTool(tool) {
      tool.setToolGroup(this.primaryToolGroup);
      if (tool.isEnabled()) {
        this.primaryToolGroup.notifyEnabled(tool);
      }
      if (!this.tools.includes(tool)) {
        this.addTool(tool);
      }
    }
    getPrimaryTools() {
      return this.tools.filter((tool) => {
        return tool.getToolGroup() === this.primaryToolGroup;
      });
    }
    /**
     * Add a tool to the end of this' tool list (the added tool receives events after tools already added to this).
     * This should be called before creating the app's toolbar.
     *
     * If `options.addToFront`, the tool is added to the beginning of this' tool list.
     *
     * Does nothing if the tool is already present.
     */
    addTool(tool, options) {
      if (!this.tools.includes(tool)) {
        if (options?.addToFront) {
          this.tools.splice(0, 0, tool);
        } else {
          this.tools.push(tool);
        }
      }
    }
    /**
     * Removes **and destroys** all tools in `tools` from this.
     */
    removeAndDestroyTools(tools) {
      const newTools = [];
      for (const tool of this.tools) {
        if (tools.includes(tool)) {
          if (this.activeTool === tool) {
            this.activeTool = null;
          }
          tool.onDestroy();
        } else {
          newTools.push(tool);
        }
      }
      this.tools = newTools;
    }
    insertTools(insertNear, toolsToInsert, mode) {
      this.tools = this.tools.filter((tool) => !toolsToInsert.includes(tool));
      const newTools = [];
      for (const tool of this.tools) {
        if (mode === "after") {
          newTools.push(tool);
        }
        if (tool === insertNear) {
          newTools.push(...toolsToInsert);
        }
        if (mode === "before") {
          newTools.push(tool);
        }
      }
      this.tools = newTools;
    }
    /**
     * Removes a tool from this' tool list and replaces it with `replaceWith`.
     *
     * If any of `toolsToInsert` have already been added to this, the tools are
     * moved.
     *
     * This should be called before creating the editor's toolbar.
     */
    insertToolsAfter(insertAfter, toolsToInsert) {
      this.insertTools(insertAfter, toolsToInsert, "after");
    }
    /** @see {@link insertToolsAfter} */
    insertToolsBefore(insertBefore, toolsToInsert) {
      this.insertTools(insertBefore, toolsToInsert, "before");
    }
    // @internal use `dispatchEvent` rather than calling `onEvent` directly.
    onEventInternal(event) {
      const isEditorReadOnly = this.isEditorReadOnly.get();
      const canToolReceiveInput = (tool) => {
        return tool.isEnabled() && (!isEditorReadOnly || tool.canReceiveInputInReadOnlyEditor());
      };
      let handled = false;
      if (event.kind === InputEvtType.PointerDownEvt) {
        let canOnlySendToActiveTool = false;
        if (this.activeTool && !this.activeTool.eventCanBeDeliveredToNonActiveTool(event)) {
          canOnlySendToActiveTool = true;
        }
        for (const tool of this.tools) {
          if (canOnlySendToActiveTool && tool !== this.activeTool) {
            continue;
          }
          if (canToolReceiveInput(tool) && tool.onEvent(event)) {
            if (this.activeTool !== tool) {
              this.activeTool?.onEvent({ kind: InputEvtType.GestureCancelEvt });
            }
            this.activeTool = tool;
            handled = true;
            break;
          }
        }
      } else if (event.kind === InputEvtType.PointerUpEvt) {
        const upResult = this.activeTool?.onEvent(event);
        const continueHandlingEvents = upResult && event.allPointers.length > 1;
        if (!continueHandlingEvents) {
          this.activeTool = null;
        }
        handled = true;
      } else if (event.kind === InputEvtType.PointerMoveEvt) {
        if (this.activeTool !== null) {
          this.activeTool.onEvent(event);
          handled = true;
        }
      } else if (event.kind === InputEvtType.GestureCancelEvt) {
        if (this.activeTool !== null) {
          this.activeTool.onEvent(event);
          this.activeTool = null;
        }
      } else {
        for (const tool of this.tools) {
          if (!canToolReceiveInput(tool)) {
            continue;
          }
          handled = tool.onEvent(event);
          if (handled) {
            break;
          }
        }
      }
      return handled;
    }
    /** Alias for {@link dispatchInputEvent}. */
    onEvent(event) {
      return this.dispatchInputEvent(event);
    }
    // Returns true if the event was handled.
    dispatchInputEvent(event) {
      return this.inputPipeline.onEvent(event);
    }
    /**
     * Adds a new `InputMapper` to this' input pipeline.
     *
     * A `mapper` is really a relation that maps each event to no, one,
     * or many other events.
     *
     * @see {@link InputMapper}.
     */
    addInputMapper(mapper) {
      this.inputPipeline.addToTail(mapper);
    }
    getMatchingTools(type) {
      return this.tools.filter((tool) => tool instanceof type);
    }
    // @internal
    onEditorDestroyed() {
      for (const tool of this.tools) {
        tool.onDestroy();
      }
    }
  };

  // node_modules/js-draw/dist/mjs/UndoRedoHistory.mjs
  var __classPrivateFieldSet9 = function(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var __classPrivateFieldGet9 = function(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var _UndoRedoHistory_undoStack;
  var _UndoRedoHistory_redoStack;
  var UndoRedoHistory = class {
    // @internal
    constructor(editor, announceRedoCallback, announceUndoCallback) {
      this.editor = editor;
      this.announceRedoCallback = announceRedoCallback;
      this.announceUndoCallback = announceUndoCallback;
      _UndoRedoHistory_undoStack.set(this, void 0);
      _UndoRedoHistory_redoStack.set(this, void 0);
      this.maxUndoRedoStackSize = 700;
      __classPrivateFieldSet9(this, _UndoRedoHistory_undoStack, [], "f");
      __classPrivateFieldSet9(this, _UndoRedoHistory_redoStack, [], "f");
    }
    fireUpdateEvent(stackUpdateType, triggeringCommand) {
      this.editor.notifier.dispatch(EditorEventType.UndoRedoStackUpdated, {
        kind: EditorEventType.UndoRedoStackUpdated,
        undoStackSize: __classPrivateFieldGet9(this, _UndoRedoHistory_undoStack, "f").length,
        redoStackSize: __classPrivateFieldGet9(this, _UndoRedoHistory_redoStack, "f").length,
        command: triggeringCommand,
        stackUpdateType
      });
    }
    // Adds the given command to this and applies it to the editor.
    push(command, apply = true) {
      if (apply) {
        command.apply(this.editor);
      }
      __classPrivateFieldGet9(this, _UndoRedoHistory_undoStack, "f").push(command);
      for (const elem of __classPrivateFieldGet9(this, _UndoRedoHistory_redoStack, "f")) {
        elem.onDrop(this.editor);
      }
      __classPrivateFieldSet9(this, _UndoRedoHistory_redoStack, [], "f");
      if (__classPrivateFieldGet9(this, _UndoRedoHistory_undoStack, "f").length > this.maxUndoRedoStackSize) {
        const removeAtOnceCount = Math.ceil(this.maxUndoRedoStackSize / 100);
        const removedElements = __classPrivateFieldGet9(this, _UndoRedoHistory_undoStack, "f").splice(0, removeAtOnceCount);
        removedElements.forEach((elem) => elem.onDrop(this.editor));
      }
      this.fireUpdateEvent(UndoEventType.CommandDone, command);
      this.editor.notifier.dispatch(EditorEventType.CommandDone, {
        kind: EditorEventType.CommandDone,
        command
      });
    }
    // Remove the last command from this' undo stack and apply it.
    undo() {
      const command = __classPrivateFieldGet9(this, _UndoRedoHistory_undoStack, "f").pop();
      if (command) {
        __classPrivateFieldGet9(this, _UndoRedoHistory_redoStack, "f").push(command);
        const result = command.unapply(this.editor);
        this.announceUndoCallback(command);
        this.fireUpdateEvent(UndoEventType.CommandUndone, command);
        this.editor.notifier.dispatch(EditorEventType.CommandUndone, {
          kind: EditorEventType.CommandUndone,
          command
        });
        return result;
      }
    }
    redo() {
      const command = __classPrivateFieldGet9(this, _UndoRedoHistory_redoStack, "f").pop();
      if (command) {
        __classPrivateFieldGet9(this, _UndoRedoHistory_undoStack, "f").push(command);
        const result = command.apply(this.editor);
        this.announceRedoCallback(command);
        this.fireUpdateEvent(UndoEventType.CommandRedone, command);
        this.editor.notifier.dispatch(EditorEventType.CommandDone, {
          kind: EditorEventType.CommandDone,
          command
        });
        return result;
      }
    }
    get undoStackSize() {
      return __classPrivateFieldGet9(this, _UndoRedoHistory_undoStack, "f").length;
    }
    get redoStackSize() {
      return __classPrivateFieldGet9(this, _UndoRedoHistory_redoStack, "f").length;
    }
  };
  _UndoRedoHistory_undoStack = /* @__PURE__ */ new WeakMap(), _UndoRedoHistory_redoStack = /* @__PURE__ */ new WeakMap();
  var UndoRedoHistory_default = UndoRedoHistory;

  // node_modules/js-draw/dist/mjs/rendering/renderers/DummyRenderer.mjs
  var DummyRenderer = class _DummyRenderer extends AbstractRenderer {
    constructor(viewport) {
      super(viewport);
      this.clearedCount = 0;
      this.renderedPathCount = 0;
      this.lastFillStyle = null;
      this.lastPoint = null;
      this.objectNestingLevel = 0;
      this.lastText = null;
      this.lastImage = null;
      this.pointBuffer = [];
    }
    displaySize() {
      const viewportSize = this.getViewport().getScreenRectSize();
      if (viewportSize.x === 0 || viewportSize.y === 0) {
        return Vec2.of(640, 480);
      }
      return viewportSize;
    }
    clear() {
      this.clearedCount++;
      this.renderedPathCount = 0;
      this.pointBuffer = [];
      this.lastText = null;
      this.lastImage = null;
      if (this.objectNestingLevel > 0) {
        throw new Error(`Within an object while clearing! Nesting level: ${this.objectNestingLevel}`);
      }
    }
    beginPath(startPoint) {
      this.lastPoint = startPoint;
      this.pointBuffer.push(startPoint);
    }
    endPath(style) {
      this.renderedPathCount++;
      this.lastFillStyle = style;
    }
    lineTo(point) {
      point = this.canvasToScreen(point);
      this.lastPoint = point;
      this.pointBuffer.push(point);
    }
    moveTo(point) {
      point = this.canvasToScreen(point);
      this.lastPoint = point;
      this.pointBuffer.push(point);
    }
    traceCubicBezierCurve(p1, p2, p3) {
      p1 = this.canvasToScreen(p1);
      p2 = this.canvasToScreen(p2);
      p3 = this.canvasToScreen(p3);
      this.lastPoint = p3;
      this.pointBuffer.push(p1, p2, p3);
    }
    traceQuadraticBezierCurve(controlPoint, endPoint) {
      controlPoint = this.canvasToScreen(controlPoint);
      endPoint = this.canvasToScreen(endPoint);
      this.lastPoint = endPoint;
      this.pointBuffer.push(controlPoint, endPoint);
    }
    drawPoints(..._points) {
    }
    drawText(text, _transform, _style) {
      this.lastText = text;
    }
    drawImage(image) {
      this.lastImage = image;
    }
    startObject(boundingBox, _clip) {
      super.startObject(boundingBox);
      this.objectNestingLevel += 1;
    }
    endObject() {
      super.endObject();
      this.objectNestingLevel -= 1;
    }
    isTooSmallToRender(_rect) {
      return false;
    }
    canRenderFromWithoutDataLoss(other) {
      return other instanceof _DummyRenderer;
    }
    renderFromOtherOfSameType(transform, other) {
      if (!(other instanceof _DummyRenderer)) {
        throw new Error(`${other} cannot be rendered onto ${this}`);
      }
      this.renderedPathCount += other.renderedPathCount;
      this.lastFillStyle = other.lastFillStyle;
      this.lastPoint = other.lastPoint;
      this.pointBuffer.push(...other.pointBuffer.map((point) => {
        return transform.transformVec2(point);
      }));
    }
    toString() {
      return "[DummyRenderer]";
    }
  };

  // node_modules/js-draw/dist/mjs/rendering/caching/RenderingCacheNode.mjs
  var cacheDivisionSize = 3;
  var RenderingCacheNode = class _RenderingCacheNode {
    constructor(region, cacheState) {
      this.region = region;
      this.cacheState = cacheState;
      this.instantiatedChildren = [];
      this.parent = null;
      this.cachedRenderer = null;
      this.renderedIds = [];
      this.renderedMaxZIndex = null;
    }
    // Creates a previous layer of the cache tree and adds this as a child near the
    // center of the previous layer's children.
    // Returns this' parent if it already exists.
    generateParent() {
      if (this.parent) {
        return this.parent;
      }
      const parentRegion = Rect2.fromCorners(this.region.topLeft.minus(this.region.size), this.region.bottomRight.plus(this.region.size));
      const parent = new _RenderingCacheNode(parentRegion, this.cacheState);
      parent.generateChildren();
      const checkTolerance = this.region.maxDimension / 100;
      const middleChildIdx = (parent.instantiatedChildren.length - 1) / 2;
      if (!parent.instantiatedChildren[middleChildIdx].region.eq(this.region, checkTolerance)) {
        console.error(parent.instantiatedChildren[middleChildIdx].region, "\u2260", this.region);
        throw new Error("Logic error: [this] is not contained within its parent's center child");
      }
      parent.instantiatedChildren[middleChildIdx] = this;
      this.parent = parent;
      return parent;
    }
    // Generates children, if missing.
    generateChildren() {
      if (this.instantiatedChildren.length === 0) {
        if (this.region.size.x / cacheDivisionSize === 0 || this.region.size.y / cacheDivisionSize === 0) {
          console.warn("Cache element has zero size! Not generating children.");
          return;
        }
        const childRects = this.region.divideIntoGrid(cacheDivisionSize, cacheDivisionSize);
        console.assert(childRects.length === cacheDivisionSize * cacheDivisionSize, "Warning: divideIntoGrid created the wrong number of subrectangles!");
        for (const rect of childRects) {
          const child = new _RenderingCacheNode(rect, this.cacheState);
          child.parent = this;
          this.instantiatedChildren.push(child);
        }
      }
      this.checkRep();
    }
    // Returns CacheNodes directly contained within this.
    getChildren() {
      this.checkRep();
      this.generateChildren();
      return this.instantiatedChildren;
    }
    smallestChildContaining(rect) {
      const largerThanChildren = rect.maxDimension > this.region.maxDimension / cacheDivisionSize;
      if (!this.region.containsRect(rect) || largerThanChildren) {
        return null;
      }
      for (const child of this.getChildren()) {
        if (child.region.containsRect(rect)) {
          return child.smallestChildContaining(rect) ?? child;
        }
      }
      return null;
    }
    // => [true] iff [this] can be rendered without too much scaling
    renderingWouldBeHighEnoughResolution(viewport) {
      const sizeOfThisPixelOnCanvas = this.region.w / this.cacheState.props.blockResolution.x;
      const sizeOfThisPixelOnScreen = viewport.getScaleFactor() * sizeOfThisPixelOnCanvas;
      if (sizeOfThisPixelOnScreen > this.cacheState.props.maxScale) {
        return false;
      }
      return true;
    }
    // => [true] if all children of this can be rendered from their caches.
    allChildrenCanRender(viewport, leavesSortedById) {
      if (this.instantiatedChildren.length === 0) {
        return false;
      }
      for (const child of this.instantiatedChildren) {
        if (!child.region.intersects(viewport.visibleRect)) {
          continue;
        }
        if (!child.renderingIsUpToDate(this.idsOfIntersecting(leavesSortedById))) {
          return false;
        }
      }
      return true;
    }
    computeSortedByLeafIds(leaves) {
      const ids = leaves.slice();
      ids.sort((a, b) => a.getId() - b.getId());
      return ids;
    }
    // Returns a list of the ids of the nodes intersecting this
    idsOfIntersecting(nodes) {
      const result = [];
      for (const node of nodes) {
        if (node.getBBox().intersects(this.region)) {
          result.push(node.getId());
        }
      }
      return result;
    }
    // Returns true iff all elems of this.renderedIds are in sortedIds.
    // sortedIds should be sorted by z-index (or some other order, so long as they are
    // sorted by the same thing as this.renderedIds.)
    allRenderedIdsIn(sortedIds) {
      if (this.renderedIds.length > sortedIds.length) {
        return false;
      }
      for (let i = 0; i < this.renderedIds.length; i++) {
        if (sortedIds[i] !== this.renderedIds[i]) {
          return false;
        }
      }
      return true;
    }
    renderingIsUpToDate(sortedIds) {
      if (this.cachedRenderer === null || sortedIds.length !== this.renderedIds.length) {
        return false;
      }
      return this.allRenderedIdsIn(sortedIds);
    }
    // Render all [items] within [viewport]
    renderItems(screenRenderer, items, viewport) {
      if (!viewport.visibleRect.intersects(this.region) || items.length === 0) {
        return;
      }
      const divideUntilSmallerThanThis = (itemsToDivide) => {
        const newItems = [];
        for (const item of itemsToDivide) {
          const bbox = item.getBBox();
          if (!bbox.intersects(this.region)) {
            continue;
          }
          if (bbox.maxDimension >= this.region.maxDimension) {
            newItems.push(...item.getChildrenOrSelfIntersectingRegion(this.region));
          } else {
            newItems.push(item);
          }
        }
        return newItems;
      };
      items = divideUntilSmallerThanThis(items);
      if (!this.cacheState.props.isOfCorrectType(screenRenderer)) {
        for (const item of items) {
          item.render(screenRenderer, viewport.visibleRect);
        }
        return;
      }
      if (this.cacheState.debugMode) {
        screenRenderer.drawRect(this.region, viewport.getSizeOfPixelOnCanvas(), {
          fill: Color4.yellow
        });
      }
      const couldRender = this.renderingWouldBeHighEnoughResolution(viewport);
      if (!couldRender) {
        for (const child of this.getChildren()) {
          child.renderItems(screenRenderer, items.filter((item) => {
            return item.getBBox().intersects(child.region);
          }), viewport);
        }
      } else {
        const tooSmallToRender = (rect) => rect.w / this.region.w < 1 / this.cacheState.props.blockResolution.x;
        const leaves = [];
        for (const item of items) {
          leaves.push(...item.getLeavesIntersectingRegion(this.region, tooSmallToRender));
        }
        sortLeavesByZIndex(leaves);
        const leavesByIds = this.computeSortedByLeafIds(leaves);
        if (leavesByIds.length === 0) {
          return;
        }
        const leafIds = leavesByIds.map((leaf) => leaf.getId());
        let thisRenderer;
        if (!this.renderingIsUpToDate(leafIds)) {
          if (this.allChildrenCanRender(viewport, leavesByIds)) {
            for (const child of this.getChildren()) {
              child.renderItems(screenRenderer, items, viewport);
            }
            return;
          }
          let leafApproxRenderTime = 0;
          for (const leaf of leavesByIds) {
            if (!tooSmallToRender(leaf.getBBox())) {
              leafApproxRenderTime += leaf.getContent().getProportionalRenderingTime();
            }
          }
          if (leafApproxRenderTime > this.cacheState.props.minProportionalRenderTimePerCache) {
            let fullRerenderNeeded = true;
            if (!this.cachedRenderer) {
              this.cachedRenderer = this.cacheState.recordManager.allocCanvas(this.region, () => this.onRegionDealloc());
            } else if (leavesByIds.length > this.renderedIds.length && this.allRenderedIdsIn(leafIds) && this.renderedMaxZIndex !== null) {
              const newLeaves = [];
              let minNewZIndex = null;
              for (let i = 0; i < leavesByIds.length; i++) {
                const leaf = leavesByIds[i];
                const content = leaf.getContent();
                const zIndex = content.getZIndex();
                if (i >= this.renderedIds.length || leaf.getId() !== this.renderedIds[i]) {
                  newLeaves.push(leaf);
                  if (minNewZIndex === null || zIndex < minNewZIndex) {
                    minNewZIndex = zIndex;
                  }
                }
              }
              if (minNewZIndex !== null && minNewZIndex > this.renderedMaxZIndex) {
                fullRerenderNeeded = false;
                thisRenderer = this.cachedRenderer.startRender();
                for (let i = 0; i < leaves.length; i++) {
                  const leaf = leaves[i];
                  const zIndex = leaf.getContent().getZIndex();
                  if (zIndex > this.renderedMaxZIndex) {
                    leaf.render(thisRenderer, this.region);
                    this.renderedMaxZIndex = zIndex;
                  }
                }
                if (this.cacheState.debugMode) {
                  screenRenderer.drawRect(this.region, 2 * viewport.getSizeOfPixelOnCanvas(), {
                    fill: Color4.clay
                  });
                }
              }
            } else if (this.cacheState.debugMode) {
              console.log("Decided on a full re-render. Reason: At least one of the following is false:", "\n leafIds.length > this.renderedIds.length: ", leafIds.length > this.renderedIds.length, "\n this.allRenderedIdsIn(leafIds): ", this.allRenderedIdsIn(leafIds), "\n this.renderedMaxZIndex !== null: ", this.renderedMaxZIndex !== null, "\n\nthis.rerenderedIds: ", this.renderedIds, ", leafIds: ", leafIds);
            }
            if (fullRerenderNeeded) {
              thisRenderer = this.cachedRenderer.startRender();
              thisRenderer.clear();
              this.renderedMaxZIndex = null;
              const startIndex = computeFirstIndexToRender(leaves, this.region);
              for (let i = startIndex; i < leaves.length; i++) {
                const leaf = leaves[i];
                const content = leaf.getContent();
                this.renderedMaxZIndex ??= content.getZIndex();
                this.renderedMaxZIndex = Math.max(this.renderedMaxZIndex, content.getZIndex());
                leaf.render(thisRenderer, this.region);
              }
              if (this.cacheState.debugMode) {
                screenRenderer.drawRect(this.region, 3 * viewport.getSizeOfPixelOnCanvas(), {
                  fill: Color4.red
                });
              }
            }
            this.renderedIds = leafIds;
          } else {
            this.cachedRenderer?.dealloc();
            const pixelSize = viewport.getSizeOfPixelOnCanvas();
            const expandedRegion = new Rect2(this.region.x, this.region.y, this.region.w + pixelSize, this.region.h + pixelSize);
            const clip = true;
            screenRenderer.startObject(expandedRegion, clip);
            for (const leaf of leaves) {
              leaf.render(screenRenderer, this.region.intersection(viewport.visibleRect));
            }
            screenRenderer.endObject();
            if (this.cacheState.debugMode) {
              screenRenderer.drawRect(this.region, 2 * viewport.getSizeOfPixelOnCanvas(), {
                fill: Color4.green
              });
            }
          }
        } else {
          thisRenderer = this.cachedRenderer.startRender();
        }
        if (thisRenderer) {
          const transformMat = this.cachedRenderer.getTransform(this.region).inverse();
          screenRenderer.renderFromOtherOfSameType(transformMat, thisRenderer);
        }
        if (this.instantiatedChildren.every((child) => child.isEmpty())) {
          this.instantiatedChildren = [];
        }
      }
      this.checkRep();
    }
    // Returns true iff this/its children have no cached state.
    isEmpty() {
      if (this.cachedRenderer !== null) {
        return false;
      }
      return this.instantiatedChildren.every((child) => child.isEmpty());
    }
    onRegionDealloc() {
      this.cachedRenderer = null;
      if (this.isEmpty()) {
        this.instantiatedChildren = [];
      }
    }
    checkRep() {
      if (this.instantiatedChildren.length !== cacheDivisionSize * cacheDivisionSize && this.instantiatedChildren.length !== 0) {
        throw new Error(`Repcheck: Wrong number of children. Got ${this.instantiatedChildren.length}`);
      }
      if (this.renderedIds[1] !== void 0 && this.renderedIds[0] >= this.renderedIds[1]) {
        console.error(this.renderedIds);
        throw new Error("Repcheck: First two ids are not in ascending order!");
      }
      for (const child of this.instantiatedChildren) {
        if (child.parent !== this) {
          throw new Error("Children should be linked to their parents!");
        }
      }
      if (this.cachedRenderer && !this.cachedRenderer.isAllocd()) {
        throw new Error("this' cachedRenderer != null, but is dealloc'd");
      }
    }
  };

  // node_modules/js-draw/dist/mjs/rendering/caching/CacheRecord.mjs
  var CacheRecord = class {
    constructor(onBeforeDeallocCallback, cacheState) {
      this.onBeforeDeallocCallback = onBeforeDeallocCallback;
      this.cacheState = cacheState;
      this.allocd = false;
      this.allocCount = 0;
      this.renderer = cacheState.props.createRenderer();
      this.lastUsedCycle = -1;
      this.allocd = true;
    }
    startRender() {
      this.lastUsedCycle = this.cacheState.currentRenderingCycle;
      if (!this.allocd) {
        throw new Error("Only alloc'd canvases can be rendered to");
      }
      return this.renderer;
    }
    dealloc() {
      this.onBeforeDeallocCallback?.();
      this.allocd = false;
      this.onBeforeDeallocCallback = null;
      this.lastUsedCycle = 0;
    }
    isAllocd() {
      return this.allocd;
    }
    realloc(newDeallocCallback) {
      if (this.allocd) {
        this.dealloc();
      }
      this.allocd = true;
      this.onBeforeDeallocCallback = newDeallocCallback;
      this.lastUsedCycle = this.cacheState.currentRenderingCycle;
      this.allocCount++;
    }
    getLastUsedCycle() {
      return this.lastUsedCycle;
    }
    // Returns the transformation that maps [drawTo] to this' renderable region
    // (i.e. a [cacheProps.blockResolution]-sized rectangle with top left at (0, 0))
    getTransform(drawTo) {
      const transform = Mat33.scaling2D(this.cacheState.props.blockResolution.x / drawTo.size.x).rightMul(Mat33.translation(drawTo.topLeft.times(-1)));
      return transform;
    }
    setRenderingRegion(drawTo) {
      const transform = this.getTransform(drawTo);
      this.renderer.setTransform(transform);
      this.renderer.overrideVisibleRect(drawTo.grownBy(1 / transform.getScaleFactor()));
    }
  };

  // node_modules/js-draw/dist/mjs/rendering/caching/CacheRecordManager.mjs
  var CacheRecordManager = class {
    constructor(cacheProps) {
      this.cacheRecords = [];
      this.maxCanvases = Math.ceil(
        // Assuming four components per pixel:
        cacheProps.cacheSize / 4 / cacheProps.blockResolution.x / cacheProps.blockResolution.y
      );
    }
    setSharedState(state) {
      this.cacheState = state;
    }
    allocCanvas(drawTo, onDealloc) {
      if (this.cacheRecords.length < this.maxCanvases) {
        const record = new CacheRecord(onDealloc, this.cacheState);
        record.setRenderingRegion(drawTo);
        this.cacheRecords.push(record);
        if (this.cacheState.debugMode) {
          console.log("[Cache] Cache spaces used: ", this.cacheRecords.length, " of ", this.maxCanvases);
        }
        return record;
      } else {
        const lru = this.getLeastRecentlyUsedRecord();
        if (this.cacheState.debugMode) {
          console.log("[Cache] Re-alloc. Times allocated: ", lru.allocCount, "\nLast used cycle: ", lru.getLastUsedCycle(), "\nCurrent cycle: ", this.cacheState.currentRenderingCycle);
        }
        lru.realloc(onDealloc);
        lru.setRenderingRegion(drawTo);
        if (this.cacheState.debugMode) {
          console.log("[Cache] Now re-alloc'd. Last used cycle: ", lru.getLastUsedCycle());
          console.assert(lru["cacheState"] === this.cacheState, "[Cache] Unequal cache states! cacheState should be a shared object!");
        }
        return lru;
      }
    }
    // Returns null if there are no cache records. Returns an unalloc'd record if one exists.
    getLeastRecentlyUsedRecord() {
      this.cacheRecords.sort((a, b) => a.getLastUsedCycle() - b.getLastUsedCycle());
      return this.cacheRecords[0];
    }
    // Returns information to (hopefully) help debug performance issues
    getDebugInfo() {
      let numberAllocd = 0;
      let averageReassignedCount = 0;
      for (const cacheRecord of this.cacheRecords) {
        averageReassignedCount += cacheRecord.allocCount;
        if (cacheRecord.isAllocd()) {
          numberAllocd++;
        }
      }
      averageReassignedCount /= Math.max(this.cacheRecords.length, 1);
      const debugInfo = [
        `${this.cacheRecords.length} cache records (max ${this.maxCanvases})`,
        `${numberAllocd} assigned to screen regions`,
        `Average number of times reassigned: ${Math.round(averageReassignedCount * 100) / 100}`
      ];
      return debugInfo.join("\n");
    }
  };

  // node_modules/js-draw/dist/mjs/rendering/caching/RenderingCache.mjs
  var RenderingCache = class {
    constructor(cacheProps) {
      this.recordManager = new CacheRecordManager(cacheProps);
      this.sharedState = {
        props: cacheProps,
        currentRenderingCycle: 0,
        recordManager: this.recordManager,
        debugMode: false
      };
      this.recordManager.setSharedState(this.sharedState);
    }
    render(screenRenderer, image, viewport) {
      const visibleRect = viewport.visibleRect;
      this.sharedState.currentRenderingCycle++;
      if (!this.sharedState.props.isOfCorrectType(screenRenderer)) {
        image.render(screenRenderer, visibleRect);
        return;
      }
      if (!this.rootNode) {
        const res = this.sharedState.props.blockResolution;
        const topLeft = visibleRect.topLeft;
        this.rootNode = new RenderingCacheNode(new Rect2(topLeft.x, topLeft.y, res.x, res.y), this.sharedState);
      }
      while (!this.rootNode.region.containsRect(visibleRect)) {
        this.rootNode = this.rootNode.generateParent();
      }
      this.rootNode = this.rootNode.smallestChildContaining(visibleRect) ?? this.rootNode;
      const visibleLeaves = image.getLeavesIntersectingRegion(viewport.visibleRect, (rect) => screenRenderer.isTooSmallToRender(rect));
      let approxVisibleRenderTime = 0;
      for (const leaf of visibleLeaves) {
        approxVisibleRenderTime += leaf.getContent().getProportionalRenderingTime();
      }
      if (approxVisibleRenderTime > this.sharedState.props.minProportionalRenderTimeToUseCache) {
        this.rootNode.renderItems(screenRenderer, [image], viewport);
      } else {
        image.render(screenRenderer, visibleRect);
      }
    }
    getDebugInfo() {
      return this.recordManager.getDebugInfo();
    }
    setIsDebugMode(debugMode2) {
      this.sharedState.debugMode = debugMode2;
    }
  };

  // node_modules/js-draw/dist/mjs/rendering/renderers/TextOnlyRenderer.mjs
  var TextOnlyRenderer = class extends AbstractRenderer {
    constructor(viewport, localizationTable) {
      super(viewport);
      this.localizationTable = localizationTable;
      this.descriptionBuilder = [];
      this.pathCount = 0;
      this.textNodeCount = 0;
      this.imageNodeCount = 0;
    }
    displaySize() {
      return Vec2.of(500, 500);
    }
    clear() {
      this.descriptionBuilder = [];
      this.pathCount = 0;
      this.textNodeCount = 0;
      this.imageNodeCount = 0;
    }
    getDescription() {
      return [
        this.localizationTable.pathNodeCount(this.pathCount),
        ...this.textNodeCount > 0 ? [this.localizationTable.textNodeCount(this.textNodeCount)] : [],
        ...this.imageNodeCount > 0 ? [this.localizationTable.imageNodeCount(this.imageNodeCount)] : [],
        ...this.descriptionBuilder
      ].join("\n");
    }
    beginPath(_startPoint) {
    }
    endPath(_style) {
      this.pathCount++;
    }
    lineTo(_point) {
    }
    moveTo(_point) {
    }
    traceCubicBezierCurve(_p1, _p2, _p3) {
    }
    traceQuadraticBezierCurve(_controlPoint, _endPoint) {
    }
    drawText(text, _transform, _style) {
      this.descriptionBuilder.push(this.localizationTable.textNode(text));
      this.textNodeCount++;
    }
    drawImage(image) {
      const label = image.label ? this.localizationTable.imageNode(image.label) : this.localizationTable.unlabeledImageNode;
      this.descriptionBuilder.push(label);
      this.imageNodeCount++;
    }
    isTooSmallToRender(rect) {
      return rect.maxDimension < 15 / this.getSizeOfCanvasPixelOnScreen();
    }
    drawPoints(..._points) {
    }
  };

  // node_modules/js-draw/dist/mjs/rendering/renderers/AcceleratedInkingCanvasRenderer.mjs
  var CanvasInkPresenter = class {
    constructor(canvas, viewport) {
      this.viewport = viewport;
      this.enabled = /* @__PURE__ */ new Map();
      this.presenter = null;
      this.style = { color: "black", diameter: 2 };
      if ("ink" in navigator && navigator.ink) {
        const ink = navigator.ink;
        ink.requestPresenter({ presentationArea: canvas }).then((presenter) => {
          this.presenter = presenter;
        });
      }
    }
    setEnabled(pointerId, enabled) {
      this.enabled.set(pointerId, enabled);
    }
    updateStyle(style) {
      const colorString = style.color.toString();
      this.style = {
        color: colorString,
        diameter: Math.ceil(style.width / this.viewport.getSizeOfPixelOnCanvas())
      };
    }
    onEvent(event) {
      if (this.presenter && this.enabled.get(event.pointerId) && event.isTrusted) {
        this.presenter.updateInkTrailStartPoint(event, this.style);
      }
    }
  };
  var AcceleratedInkingCanvasRenderer = class extends CanvasRenderer {
    constructor(ctx, viewport) {
      super(ctx, viewport);
      this.inkPresenter = new CanvasInkPresenter(ctx.canvas, viewport);
    }
    getDraftInkPresenter() {
      return this.inkPresenter;
    }
    onEvent(event) {
      this.inkPresenter.onEvent(event);
    }
  };

  // node_modules/js-draw/dist/mjs/rendering/Display.mjs
  var RenderingMode;
  (function(RenderingMode2) {
    RenderingMode2[RenderingMode2["DummyRenderer"] = 0] = "DummyRenderer";
    RenderingMode2[RenderingMode2["CanvasRenderer"] = 1] = "CanvasRenderer";
  })(RenderingMode || (RenderingMode = {}));
  var Display = class {
    /** @internal */
    constructor(editor, mode, parent) {
      this.editor = editor;
      this.parent = parent;
      this.textRerenderOutput = null;
      this.devicePixelRatio = window.devicePixelRatio ?? 1;
      this.getColorAt = (_screenPos) => {
        return null;
      };
      if (mode === RenderingMode.CanvasRenderer) {
        this.initializeCanvasRendering();
      } else if (mode === RenderingMode.DummyRenderer) {
        this.dryInkRenderer = new DummyRenderer(editor.viewport);
        this.wetInkRenderer = new DummyRenderer(editor.viewport);
      } else {
        throw new Error(`Unknown rendering mode, ${mode}!`);
      }
      this.textRenderer = new TextOnlyRenderer(editor.viewport, editor.localization);
      this.initializeTextRendering();
      const cacheBlockResolution = Vec2.of(600, 600);
      this.cache = new RenderingCache({
        createRenderer: () => {
          if (mode === RenderingMode.DummyRenderer) {
            return new DummyRenderer(editor.viewport);
          } else if (mode !== RenderingMode.CanvasRenderer) {
            throw new Error("Unspported rendering mode");
          }
          const canvas = document.createElement("canvas");
          canvas.width = cacheBlockResolution.x + 1;
          canvas.height = cacheBlockResolution.y + 1;
          const ctx = canvas.getContext("2d");
          return new CanvasRenderer(ctx, editor.viewport);
        },
        isOfCorrectType: (renderer) => {
          return this.dryInkRenderer.canRenderFromWithoutDataLoss(renderer);
        },
        blockResolution: cacheBlockResolution,
        cacheSize: 600 * 600 * 4 * 90,
        // On higher resolution displays, don't scale cache blocks as much to decrease blurriness.
        // TODO: Decrease the minimum cache scale as well.
        maxScale: Math.max(1, 1.3 / window.devicePixelRatio),
        // Require about 20 strokes with 4 parts each to cache an image in one of the
        // parts of the cache grid.
        minProportionalRenderTimePerCache: 20 * 4,
        // Require about 105 strokes with 4 parts each to use the cache at all.
        minProportionalRenderTimeToUseCache: 105 * 4
      });
      this.editor.notifier.on(EditorEventType.DisplayResized, (event) => {
        if (event.kind !== EditorEventType.DisplayResized) {
          throw new Error("Mismatched event.kinds!");
        }
        this.resizeSurfacesCallback?.();
      });
    }
    /**
     * @returns the visible width of the display (e.g. how much
     * space the display's element takes up in the x direction
     * in the DOM).
     */
    get width() {
      return this.dryInkRenderer.displaySize().x;
    }
    /** @returns the visible height of the display. See {@link width}. */
    get height() {
      return this.dryInkRenderer.displaySize().y;
    }
    /** @internal */
    getCache() {
      return this.cache;
    }
    initializeCanvasRendering() {
      const dryInkCanvas = document.createElement("canvas");
      const wetInkCanvas = document.createElement("canvas");
      const dryInkCtx = dryInkCanvas.getContext("2d");
      const wetInkCtx = wetInkCanvas.getContext("2d");
      this.dryInkRenderer = new CanvasRenderer(dryInkCtx, this.editor.viewport);
      this.wetInkRenderer = new AcceleratedInkingCanvasRenderer(wetInkCtx, this.editor.viewport);
      dryInkCanvas.className = "dryInkCanvas";
      wetInkCanvas.className = "wetInkCanvas";
      if (this.parent) {
        this.parent.appendChild(dryInkCanvas);
        this.parent.appendChild(wetInkCanvas);
      }
      this.resizeSurfacesCallback = () => {
        const expectedWidth = (canvas) => {
          const widthInPixels = Math.ceil(canvas.clientWidth * this.devicePixelRatio);
          return widthInPixels || canvas.width;
        };
        const expectedHeight = (canvas) => {
          const heightInPixels = Math.ceil(canvas.clientHeight * this.devicePixelRatio);
          return heightInPixels || canvas.height;
        };
        const hasSizeMismatch = (canvas) => {
          return expectedHeight(canvas) !== canvas.height || expectedWidth(canvas) !== canvas.width;
        };
        if (hasSizeMismatch(dryInkCanvas) || hasSizeMismatch(wetInkCanvas)) {
          dryInkCanvas.width = expectedWidth(dryInkCanvas);
          dryInkCanvas.height = expectedHeight(dryInkCanvas);
          wetInkCanvas.width = expectedWidth(wetInkCanvas);
          wetInkCanvas.height = expectedHeight(wetInkCanvas);
          wetInkCtx.resetTransform();
          dryInkCtx.resetTransform();
          dryInkCtx.scale(this.devicePixelRatio, this.devicePixelRatio);
          wetInkCtx.scale(this.devicePixelRatio, this.devicePixelRatio);
          this.editor.notifier.dispatch(EditorEventType.DisplayResized, {
            kind: EditorEventType.DisplayResized,
            newSize: Vec2.of(this.width, this.height)
          });
        }
      };
      this.resizeSurfacesCallback();
      this.flattenCallback = () => {
        dryInkCtx.save();
        dryInkCtx.resetTransform();
        dryInkCtx.drawImage(wetInkCanvas, 0, 0);
        dryInkCtx.restore();
      };
      this.getColorAt = (screenPos) => {
        const adjustedScreenPos = screenPos.times(this.devicePixelRatio);
        const pixel = dryInkCtx.getImageData(adjustedScreenPos.x, adjustedScreenPos.y, 1, 1);
        const data = pixel?.data;
        if (data) {
          const color = Color4.ofRGBA(data[0] / 255, data[1] / 255, data[2] / 255, data[3] / 255);
          return color;
        }
        return null;
      };
    }
    initializeTextRendering() {
      const textRendererOutputContainer = document.createElement("div");
      textRendererOutputContainer.classList.add("textRendererOutputContainer");
      const rerenderButton = createButton_default({
        classList: ["rerenderButton"],
        text: this.editor.localization.rerenderAsText
      });
      this.textRerenderOutput = document.createElement("div");
      this.textRerenderOutput.setAttribute("aria-live", "polite");
      rerenderButton.onclick = () => {
        this.rerenderAsText();
      };
      textRendererOutputContainer.replaceChildren(rerenderButton, this.textRerenderOutput);
      this.editor.createHTMLOverlay(textRendererOutputContainer);
    }
    /**
     * Sets the device-pixel-ratio.
     *
     * Intended for debugging. Users do not need to call this manually.
     *
     * @internal
     */
    setDevicePixelRatio(dpr) {
      const minDpr = 1e-3;
      const maxDpr = 10;
      if (isFinite(dpr) && dpr >= minDpr && dpr <= maxDpr && dpr !== this.devicePixelRatio) {
        this.devicePixelRatio = dpr;
        this.resizeSurfacesCallback?.();
        return this.editor.queueRerender();
      }
      return void 0;
    }
    /** @internal */
    getDevicePixelRatio() {
      return this.devicePixelRatio;
    }
    /** @internal -- used for internal performance improvements. */
    onPointerEvent(event) {
      if (this.wetInkRenderer instanceof AcceleratedInkingCanvasRenderer) {
        this.wetInkRenderer.onEvent(event);
      }
    }
    /**
     * Rerenders the text-based display.
     * The text-based display is intended for screen readers and can be navigated to by pressing `tab`.
     */
    rerenderAsText() {
      this.textRenderer.clear();
      this.editor.image.render(this.textRenderer, this.editor.viewport);
      if (this.textRerenderOutput) {
        this.textRerenderOutput.innerText = this.textRenderer.getDescription();
      }
    }
    /**
     * Clears the main drawing surface and otherwise prepares for a rerender.
     *
     * @returns the dry ink renderer.
     */
    startRerender() {
      this.resizeSurfacesCallback?.();
      this.dryInkRenderer.clear();
      return this.dryInkRenderer;
    }
    /**
     * If `draftMode`, the dry ink renderer is configured to render
     * low-quality output.
     */
    setDraftMode(draftMode) {
      this.dryInkRenderer.setDraftMode(draftMode);
    }
    /** @internal */
    getDryInkRenderer() {
      return this.dryInkRenderer;
    }
    /**
     * @returns The renderer used for showing action previews (e.g. an unfinished stroke).
     * The `wetInkRenderer`'s surface is stacked above the `dryInkRenderer`'s.
     */
    getWetInkRenderer() {
      return this.wetInkRenderer;
    }
    /** Re-renders the contents of the wetInkRenderer onto the dryInkRenderer. */
    flatten() {
      this.flattenCallback?.();
    }
  };

  // node_modules/js-draw/dist/mjs/components/builders/PolylineBuilder.mjs
  var makePolylineBuilder = makeShapeFitAutocorrect_default((initialPoint, viewport) => {
    const minFit = viewport.getSizeOfPixelOnCanvas() * 0.65;
    return new PolylineBuilder(initialPoint, minFit, viewport);
  });
  var PolylineBuilder = class {
    constructor(startPoint, minFitAllowed, viewport) {
      this.minFitAllowed = minFitAllowed;
      this.viewport = viewport;
      this.parts = [];
      this.widthAverageNumSamples = 1;
      this.lastLineSegment = null;
      this.averageWidth = startPoint.width;
      this.startPoint = {
        ...startPoint,
        pos: this.roundPoint(startPoint.pos)
      };
      this.lastPoint = this.startPoint.pos;
      this.bbox = new Rect2(this.startPoint.pos.x, this.startPoint.pos.y, 0, 0);
      this.parts = [
        {
          kind: PathCommandType.MoveTo,
          point: this.startPoint.pos
        }
      ];
    }
    getBBox() {
      return this.bbox.grownBy(this.averageWidth);
    }
    getRenderingStyle() {
      return {
        fill: Color4.transparent,
        stroke: this.inkTrailStyle()
      };
    }
    inkTrailStyle() {
      return {
        color: this.startPoint.color,
        width: this.roundDistance(this.averageWidth)
      };
    }
    previewCurrentPath() {
      const startPoint = this.startPoint.pos;
      const commands = [...this.parts];
      if (commands.length <= 1) {
        commands.push({
          kind: PathCommandType.LineTo,
          point: startPoint.plus(Vec2.of(this.averageWidth / 4, 0))
        });
      }
      return {
        startPoint,
        commands,
        style: this.getRenderingStyle()
      };
    }
    previewFullPath() {
      return [this.previewCurrentPath()];
    }
    preview(renderer) {
      const paths = this.previewFullPath();
      if (paths) {
        const approxBBox = this.viewport.visibleRect;
        renderer.startObject(approxBBox);
        for (const path of paths) {
          renderer.drawPath(path);
        }
        renderer.endObject();
      }
    }
    build() {
      return new Stroke(this.previewFullPath());
    }
    getMinFit() {
      let minFit = Math.min(this.minFitAllowed, this.averageWidth / 4);
      if (minFit < 1e-10) {
        minFit = this.minFitAllowed;
      }
      return minFit;
    }
    roundPoint(point) {
      const minFit = this.getMinFit();
      return Viewport_default.roundPoint(point, minFit);
    }
    roundDistance(dist) {
      const minFit = this.getMinFit();
      return Viewport_default.roundPoint(dist, minFit);
    }
    addPoint(newPoint) {
      this.widthAverageNumSamples++;
      this.averageWidth = this.averageWidth * (this.widthAverageNumSamples - 1) / this.widthAverageNumSamples + newPoint.width / this.widthAverageNumSamples;
      const roundedPoint = this.roundPoint(newPoint.pos);
      if (!roundedPoint.eq(this.lastPoint)) {
        if (this.lastLineSegment && this.lastLineSegment.direction.dot(roundedPoint.minus(this.lastPoint).normalized()) > 0.997) {
          this.parts.pop();
          this.lastPoint = this.lastLineSegment.p1;
        }
        this.parts.push({
          kind: PathCommandType.LineTo,
          point: this.roundPoint(newPoint.pos)
        });
        this.bbox = this.bbox.grownToPoint(roundedPoint);
        this.lastLineSegment = new LineSegment2(this.lastPoint, roundedPoint);
        this.lastPoint = roundedPoint;
      }
    }
  };

  // node_modules/js-draw/dist/mjs/toolbar/IconProvider.mjs
  var __classPrivateFieldGet10 = function(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var _IconProvider_instances;
  var _IconProvider_makeXIcon;
  var svgNamespace = "http://www.w3.org/2000/svg";
  var checkerboardIdCounter = 0;
  var makeCheckerboardPattern = () => {
    const id = `checkerboard-${checkerboardIdCounter++}`;
    const patternElement = createSvgElement("pattern", {
      id,
      viewBox: "0,0,10,10",
      width: "20%",
      height: "20%",
      patternUnits: "userSpaceOnUse",
      children: createSvgElements("rect", [
        { x: 0, y: 0, width: 10, height: 10, fill: "white" },
        { x: 0, y: 0, width: 5, height: 5, fill: "gray" },
        { x: 5, y: 5, width: 5, height: 5, fill: "gray" }
      ])
    });
    const patternRef = `url(#${id})`;
    return {
      patternDefElement: patternElement,
      // @deprecated use patternDefElement
      get patternDef() {
        return patternElement.innerHTML;
      },
      patternRef
    };
  };
  var makeRedoIcon = (mirror) => {
    const icon2 = document.createElementNS(svgNamespace, "svg");
    icon2.innerHTML = `
		<style>
			.toolbar-svg-undo-redo-icon {
				stroke: var(--icon-color);
				stroke-width: 12;
				stroke-linejoin: round;
				stroke-linecap: round;
				fill: none;

				transform-origin: center;
			}
		</style>
	`;
    const path = document.createElementNS(svgNamespace, "path");
    path.setAttribute("d", "M20,20 A15,15 0 0 1 70,80 L80,90 L60,70 L65,90 L87,90 L65,80");
    path.classList.add("toolbar-svg-undo-redo-icon");
    if (mirror) {
      path.style.transform = "scale(-1, 1)";
    }
    icon2.appendChild(path);
    icon2.setAttribute("viewBox", "0 0 100 100");
    return icon2;
  };
  var IconProvider = class {
    constructor() {
      _IconProvider_instances.add(this);
    }
    makeUndoIcon() {
      return makeRedoIcon(true);
    }
    // @returns a redo icon.
    makeRedoIcon() {
      return makeRedoIcon(false);
    }
    makeDropdownIcon() {
      const icon2 = this.makeIconFromPath("M5,10 L50,90 L95,10 Z");
      icon2.setAttribute("viewBox", "-10 -10 110 110");
      return icon2;
    }
    makeEraserIcon(eraserSize, mode) {
      eraserSize ??= 10;
      const scaledSize = eraserSize / 4;
      const eraserColor = "#ff70af";
      const icon2 = createSvgElement("svg", {
        viewBox: "0 0 120 120",
        children: [
          createSvgElement("defs", {
            children: [
              createSvgElement("linearGradient", {
                id: "dash-pattern",
                children: createSvgElements("stop", [
                  { offset: "80%", "stop-color": eraserColor },
                  { offset: "85%", "stop-color": "white" },
                  { offset: "90%", "stop-color": eraserColor }
                ])
              })
            ]
          }),
          createSvgElement("path", {
            fill: mode === EraserMode.PartialStroke ? "url(#dash-pattern)" : eraserColor,
            stroke: "black",
            transform: "rotate(41.35)",
            d: `
						M 52.5 27
						C 50 28.9 48.9 31.7 48.9 34.8
						L 48.9 39.8
						C 48.9 45.3 53.4 49.8 58.9 49.8
						L 103.9 49.8
						C 105.8 49.8 107.6 49.2 109.1 48.3
						L 110.2 ${scaledSize + 49.5} L 159.7 ${scaledSize + 5}
						L 157.7 ${-scaledSize + 5.2} L 112.4 ${49.5 - scaledSize}
						C 113.4 43.5 113.9 41.7 113.9 39.8
						L 113.9 34.8
						C 113.9 29.3 109.4 24.8 103.9 24.8
						L 58.9 24.8
						C 56.5 24.8 54.3 25.7 52.5 27
						z
					`
          }),
          createSvgElement("rect", {
            stroke: "#cc8077",
            fill: "var(--icon-color)",
            width: 65,
            height: 75,
            x: 48.9,
            y: -38.7,
            transform: "rotate(41.35)"
          })
        ]
      });
      return icon2;
    }
    makeSelectionIcon(mode = SelectionMode.Rectangle) {
      const icon2 = document.createElementNS(svgNamespace, "svg");
      if (mode === SelectionMode.Rectangle) {
        icon2.innerHTML = `
			<g>
				<rect x="10" y="10" width="70" height="70" fill="pink" stroke="black" stroke-dasharray="32 9"/>
				<rect x="75" y="75" width="10" height="10" fill="white" stroke="black"/>
			</g>
			`;
      } else {
        icon2.innerHTML = `
			<g>
				<rect x="10" y="10" width="76" height="76" rx="50" stroke-dasharray="32 9" fill="pink" stroke="black"/>
				<rect x="71" y="71" width="10" height="10" fill="white" stroke="black"/>
			</g>
			`;
      }
      icon2.setAttribute("viewBox", "0 0 100 100");
      return icon2;
    }
    makeRotateIcon() {
      const icon2 = document.createElementNS(svgNamespace, "svg");
      icon2.innerHTML = `
			<defs>
				<marker
					id="arrow-marker"
					viewBox="0 0 10 10"
					refX="3" refY="5"
					markerWidth="3" markerHeight="3"
					orient="auto-start-reverse"
				>
					<path
						d="M0,0 L8,5 L0,10z"
						fill="var(--icon-color)"
					/>
				</marker>
			</defs>

			<path
				marker-start="url(#arrow-marker)"
				d="
					M20,20
					A30,30 0 1 1 80 80
				"
				fill="none"
				stroke="var(--icon-color)"
				stroke-width="12"
			/>
			<path
				d="
					M80,80
					A30,30 0 1 1 20 20
				"
				fill="none"
				stroke="var(--icon-color)"
				stroke-width="12"
				stroke-dasharray="30 10 20 10 20 10 10"
				style="stroke-linecap: butt;"
			/>
		`;
      icon2.setAttribute("viewBox", "-5 -5 110 110");
      return icon2;
    }
    makeHandToolIcon() {
      const fill = "none";
      const strokeColor = "var(--icon-color)";
      const strokeWidth = "3";
      return this.makeIconFromPath(`
			m 10,60
				5,30
			H 90
			V 30
			C 90,20 75,20 75,30
			V 60
				20
			C 75,10 60,10 60,20
			V 60
				15
			C 60,5 45,5 45,15
			V 60
				25
			C 45,15 30,15 30,25
			V 60
				75
			L 25,60
			C 20,45 10,50 10,60
			Z
		`, fill, strokeColor, strokeWidth);
    }
    makeTouchPanningIcon() {
      const fill = "none";
      const strokeColor = "var(--icon-color)";
      const strokeWidth = "3";
      return this.makeIconFromPath(`
			M 5,5.5
			V 17.2
			L 16.25,5.46
			Z
	
			m 33.75,0
			L 50,17
			V 5.5
			Z
	
			M 5,40.7
			v 11.7
			h 11.25
			z
	
			M 26,19
			C 19.8,19.4 17.65,30.4 21.9,34.8
			L 50,70
			H 27.5
			c -11.25,0 -11.25,17.6 0,17.6
			H 61.25
			C 94.9,87.8 95,87.6 95,40.7 78.125,23 67,29 55.6,46.5
			L 33.1,23
			C 30.3125,20.128192 27.9,19 25.830078,19.119756
			Z
		`, fill, strokeColor, strokeWidth);
    }
    /** Unused by js-draw. @deprecated */
    makeAllDevicePanningIcon() {
      const fill = "none";
      const strokeColor = "var(--icon-color)";
      const strokeWidth = "3";
      return this.makeIconFromPath(`
			M 5 5
			L 5 17.5
				17.5 5
				5 5
			z
	
			M 42.5 5
			L 55 17.5
				55 5
				42.5 5
			z
	
			M 70 10
			L 70 21
				61 15
				55.5 23
				66 30
				56 37
				61 45
				70 39
				70 50
				80 50
				80 39
				89 45
				95 36
				84 30
				95 23
				89 15
				80 21
				80 10
				70 10
			z
	
			M 27.5 26.25
			L 27.5 91.25
			L 43.75 83.125
			L 52 99
			L 68 91
			L 60 75
			L 76.25 66.875
			L 27.5 26.25
			z
	
			M 5 42.5
			L 5 55
			L 17.5 55
			L 5 42.5
			z
		`, fill, strokeColor, strokeWidth);
    }
    makeZoomIcon() {
      const icon2 = document.createElementNS(svgNamespace, "svg");
      icon2.setAttribute("viewBox", "0 0 100 100");
      const addTextNode = (text, x, y) => {
        const textNode = document.createElementNS(svgNamespace, "text");
        textNode.appendChild(document.createTextNode(text));
        textNode.setAttribute("x", x.toString());
        textNode.setAttribute("y", y.toString());
        textNode.style.textAlign = "center";
        textNode.style.textAnchor = "middle";
        textNode.style.fontSize = "55px";
        textNode.style.fill = "var(--icon-color)";
        textNode.style.fontFamily = "monospace";
        icon2.appendChild(textNode);
      };
      addTextNode("+", 40, 45);
      addTextNode("-", 70, 75);
      return icon2;
    }
    makeRotationLockIcon() {
      const icon2 = this.makeIconFromPath(`
			M 40.1 25.1 
			C 32.5 25 27.9 34.1 27.9 34.1 
			L 25.7 30 
			L 28 44.7 
			L 36.6 40.3 
			L 32.3 38.3 
			C 33.6 28 38.1 25.2 45.1 31.8 
			L 49.4 29.6 
			C 45.9 26.3 42.8 25.1 40.1 25.1 
			z

			M 51.7 34.2 
			L 43.5 39.1 
			L 48 40.8 
			C 47.4 51.1 43.1 54.3 35.7 48.2 
			L 31.6 50.7 
			C 45.5 62.1 52.6 44.6 52.6 44.6 
			L 55.1 48.6 
			L 51.7 34.2 
			z

			M 56.9 49.9 
			C 49.8 49.9 49.2 57.3 49.3 60.9 
			L 47.6 60.9 
			L 47.6 73.7 
			L 66.1 73.7 
			L 66.1 60.9 
			L 64.4 60.9 
			C 64.5 57.3 63.9 49.9 56.9 49.9 
			z

			M 56.9 53.5 
			C 60.8 53.5 61 58.2 60.8 60.9 
			L 52.9 60.9 
			C 52.7 58.2 52.9 53.5 56.9 53.5 
			z
		`);
      icon2.setAttribute("viewBox", "10 10 70 70");
      return icon2;
    }
    makeInsertImageIcon() {
      return this.makeIconFromPath(`
			M 5 10 L 5 90 L 95 90 L 95 10 L 5 10 z
			M 10 15 L 90 15 L 90 50 L 70 75 L 40 50 L 10 75 L 10 15 z
			M 22.5 25 A 7.5 7.5 0 0 0 15 32.5 A 7.5 7.5 0 0 0 22.5 40 A 7.5 7.5 0 0 0 30 32.5 A 7.5 7.5 0 0 0 22.5 25 z 
		`);
    }
    makeUploadFileIcon() {
      return this.makeIconFromPath(`
			M 48,10 32,34 43,33 42,68
			H 54
			L 53,33 64,34 Z
	
			M 8,66 V 86 H 88 V 66 H 78 V 76 H 18 V 66 Z
		`);
    }
    makeTextIcon(textStyle) {
      const icon2 = document.createElementNS(svgNamespace, "svg");
      icon2.setAttribute("viewBox", "0 0 100 100");
      const textNode = document.createElementNS(svgNamespace, "text");
      textNode.appendChild(document.createTextNode("T"));
      textNode.style.fontFamily = textStyle.fontFamily;
      textNode.style.fontWeight = textStyle.fontWeight ?? "";
      textNode.style.fontVariant = textStyle.fontVariant ?? "";
      textNode.style.fill = textStyle.renderingStyle.fill.toHexString();
      textNode.style.textAnchor = "middle";
      textNode.setAttribute("x", "50");
      textNode.setAttribute("y", "75");
      textNode.style.fontSize = "65px";
      textNode.style.filter = "drop-shadow(0px 0px 10px var(--shadow-color))";
      icon2.appendChild(textNode);
      return icon2;
    }
    makePenIcon(penStyle) {
      const strokeSize = Math.round(Math.sqrt(penStyle.thickness) * 4);
      const color = penStyle.color;
      const rounded = this.isRoundedTipPen(penStyle);
      const tipThickness = strokeSize / 2;
      const inkTipPath = `
			M ${15 - tipThickness},${80 - tipThickness}
			  ${15 - tipThickness},${80 + tipThickness}
			  30,83
			  15,65
			Z
		`;
      const trailStartEndY = 80 + tipThickness;
      const inkTrailPath = `
			m ${15 - tipThickness * 1.1},${trailStartEndY}
			c 35,10 55,15 60,30
			l ${35 + tipThickness * 1.2},${-10 - tipThickness}
			C 80.47,98.32 50.5,${90 + tipThickness} 20,${trailStartEndY} Z
		`;
      const colorBubblePath = `
			M 72.45,35.67
			A 10,15 41.8 0 1 55,40.2 10,15 41.8 0 1 57.55,22.3 10,15 41.8 0 1 75,17.8 10,15 41.8 0 1 72.5,35.67
			Z
		`;
      let gripMainPath = "M 85,-25 25,35 h 10 v 10 h 10 v 10 h 10 v 10 h 10 l -5,10 60,-60 z";
      let gripShadow1Path = "M 25,35 H 35 L 90,-15 85,-25 Z";
      let gripShadow2Path = "M 60,75 65,65 H 55 l 55,-55 10,5 z";
      if (rounded) {
        gripMainPath = "M 85,-25 25,35 c 15,0 40,30 35,40 l 60,-60 z";
        gripShadow1Path = "m 25,35 c 3.92361,0.384473 7.644275,0.980572 10,3 l 55,-53 -5,-10 z";
        gripShadow2Path = "M 60,75 C 61,66 59,65 56,59 l 54,-54 10,10 z";
      }
      const penTipPath = `M 25,35 ${10 - tipThickness / 4},${70 - tipThickness / 2} 20,75 25,85 60,75 70,55 45,25 Z`;
      const pencilTipColor = Color4.fromHex("#f4d7d7");
      const tipColor = pencilTipColor.mix(color, tipThickness / 40 - 0.1).toHexString();
      const checkerboardPattern = makeCheckerboardPattern();
      const colorString = color.toHexString();
      const ink = createSvgPaths({
        fill: checkerboardPattern.patternRef,
        d: inkTipPath
      }, {
        fill: checkerboardPattern.patternRef,
        d: inkTrailPath
      }, {
        fill: colorString,
        d: inkTipPath
      }, {
        fill: colorString,
        d: inkTrailPath
      });
      const penTip = createSvgPaths({ fill: checkerboardPattern.patternRef, d: penTipPath }, { fill: tipColor, stroke: colorString, d: penTipPath });
      const grip = createSvgPaths(
        { fill: "var(--icon-color)", stroke: "var(--icon-color)", d: gripMainPath },
        // Shadows
        { fill: "rgba(150, 150, 150, 0.3)", d: gripShadow1Path },
        { fill: "rgba(100, 100, 100, 0.2)", d: gripShadow2Path },
        // Color bubble
        { fill: checkerboardPattern.patternRef, d: colorBubblePath },
        { fill: colorString, d: colorBubblePath }
      );
      const icon2 = document.createElementNS(svgNamespace, "svg");
      icon2.setAttribute("viewBox", "0 0 100 100");
      const iconMainContent = createSvgElement("g", {
        children: [ink, penTip, grip].flat()
      });
      const defs = createSvgElement("defs", {
        children: [checkerboardPattern.patternDefElement]
      });
      icon2.replaceChildren(defs, iconMainContent);
      return icon2;
    }
    makeIconFromFactory(penStyle) {
      const thickness = Math.sqrt(penStyle.thickness) * 3;
      const nowTime = performance.now();
      const startPoint = {
        pos: Vec2.of(10, 10),
        width: thickness,
        color: penStyle.color,
        time: nowTime - 100
      };
      const endPoint = {
        pos: Vec2.of(90, 90),
        width: thickness,
        color: penStyle.color,
        time: nowTime
      };
      const viewport = new Viewport_default(() => {
      });
      const builder = penStyle.factory(startPoint, viewport);
      builder.addPoint(endPoint);
      const icon2 = document.createElementNS(svgNamespace, "svg");
      icon2.setAttribute("viewBox", "0 0 100 100");
      viewport.updateScreenSize(Vec2.of(100, 100));
      let renderer;
      const includeTransparencyGrid = penStyle.color.a < 1;
      if (includeTransparencyGrid) {
        const checkerboardPattern = makeCheckerboardPattern();
        const defs = document.createElementNS(svgNamespace, "defs");
        defs.appendChild(checkerboardPattern.patternDefElement);
        icon2.appendChild(defs);
        const background = document.createElementNS(svgNamespace, "g");
        icon2.appendChild(background);
        renderer = new class extends SVGRenderer {
          constructor() {
            super(icon2, viewport);
          }
          addPathToSVG() {
            const addedPath = super.addPathToSVG();
            if (addedPath) {
              const copy = addedPath.cloneNode(true);
              copy.style.zIndex = "-1";
              if (copy.hasAttribute("stroke")) {
                copy.setAttribute("stroke", checkerboardPattern.patternRef);
              } else if (copy.hasAttribute("fill")) {
                copy.setAttribute("fill", checkerboardPattern.patternRef);
              }
              background.appendChild(copy);
            }
            return addedPath;
          }
        }();
      } else {
        renderer = new SVGRenderer(icon2, viewport);
      }
      builder.preview(renderer);
      const bbox = builder.getBBox();
      icon2.setAttribute("viewBox", `${bbox.x} ${bbox.y} ${bbox.w} ${bbox.h}`);
      return icon2;
    }
    makePipetteIcon(color) {
      const icon2 = document.createElementNS(svgNamespace, "svg");
      const mainGroup = document.createElementNS(svgNamespace, "g");
      mainGroup.style.rotate = "45deg";
      mainGroup.style.transformOrigin = "center";
      const pipette = document.createElementNS(svgNamespace, "g");
      pipette.innerHTML = `
		<path
			style="fill: var(--icon-color); stroke-linecap:round; stroke-linejoin:round;"
			d="
				m 32,12 v 68
				c 0,1 0.5,2 1.33,2.5 1.67,1.15 3.67,2.1 5.17,3.2 1.4,1.1 2.3,2.1 2.5,3.1 0.6,2.1 1,4.6 1,6.2 0,3.7 5.45,4.1 6,0.4 l 0.9,-6.8
				c 0.3,-0.9 1.1,-1.9 2.6,-2.9 1.5,-1.1 3.4,-2 5.1,-3.2
				C 57.5,82 58,81 58,80
				V 12 Z m 20,25 v 41.3
				c 0,1.7 -2.5,1.6 -4,2.7 -1,0.76 -2.1,1.5 -3,2.6
				C 44,82.5 43.02,81.75 42,81 40.51,79.92 38,80 38,78.34
				V 51 Z
			"
		/>
		<rect
			style="fill: var(--icon-color);"
			width="32"
			height="9"
			x="29"
			y="2"
			ry="4.5"
		/>
		<path
			style="fill: var(--icon-color);"
			d="m 45,-25 c -5.54,0 -11,4.26 -11,9 V 0 h 22 v -16 c 0,-4.74 -5.46,-9 -11,-9 z"
		/>
		`;
      if (color) {
        const checkerboardPattern = makeCheckerboardPattern();
        const defs = document.createElementNS(svgNamespace, "defs");
        defs.appendChild(checkerboardPattern.patternDefElement);
        icon2.appendChild(defs);
        const fluidBackground = document.createElementNS(svgNamespace, "path");
        const fluid = document.createElementNS(svgNamespace, "path");
        const fluidPathData = `
				M 35,36 H 55 V 78.678012 83 L 45,87 35,83 Z
			`;
        fluid.setAttribute("d", fluidPathData);
        fluidBackground.setAttribute("d", fluidPathData);
        fluid.style.fill = color.toHexString();
        fluidBackground.style.fill = checkerboardPattern.patternRef;
        mainGroup.appendChild(fluidBackground);
        mainGroup.appendChild(fluid);
      }
      mainGroup.appendChild(pipette);
      icon2.appendChild(mainGroup);
      icon2.setAttribute("viewBox", "5 -40 140 140");
      return icon2;
    }
    makeShapeAutocorrectIcon() {
      const fill = "none";
      const strokeColor = "var(--icon-color)";
      return this.makeIconFromPath(`
			m 79.129476,33.847107 9.967823,-0.03218 v 55 h -55 l 0.03218,-9.96782
			M 71.1,40.8 a 30,30 0 0 1 -30,30 30,30 0 0 1 -30,-30 30,30 0 0 1 30,-30 30,30 0 0 1 30,30 L 71.1,40.8
			M 34.1,58.8 v -25 h 25 v 0
		`, fill, strokeColor, "7px");
    }
    makeStrokeSmoothingIcon() {
      const fill = "none";
      const strokeColor = "var(--icon-color)";
      return this.makeIconFromPath(`
			m 31,83.2 c -50,0 30,-65 -20,-65
			M 75,17.3 40,59.7 38.2,77.6 55.5,72.4 90.5,30 Z
		`, fill, strokeColor, "7px");
    }
    makePressureSensitivityIcon() {
      const icon2 = document.createElementNS(svgNamespace, "svg");
      icon2.setAttribute("viewBox", "4 -10 100 100");
      icon2.replaceChildren(...createSvgPaths({
        d: `
					M 39.7,77.7
					C 39.7,77.7 3.4,78.1 4.2,60 4.7,45.2 33.2,30.5 40,25 55.9,12.1 7.4,4.8 7.4,4.8
					c 0,0 40.2,5.5 40.2,15.4
					C 47.6,29.1 21.2,35.1 23.9,60 25,70 39.7,77.7 39.7,77.7
					Z`,
        fill: "var(--icon-color)",
        stroke: "var(--icon-color)",
        "stroke-width": "2px"
      }, {
        d: "M 86.4,15.6 101.4,28.8 65,70 47.5,74.6 50,56.7Z",
        fill: "transparent",
        stroke: "var(--icon-color)",
        "stroke-width": "6px"
      }));
      return icon2;
    }
    /** Unused. @deprecated */
    makeFormatSelectionIcon() {
      return this.makeIconFromPath(`
			M 5 10
			L 5 20 L 10 20 L 10 15 L 20 15 L 20 40 L 15 40 L 15 45 L 35 45 L 35 40 L 30 40 L 30 15 L 40 15 L 40 20 L 45 20 L 45 15 L 45 10 L 5 10 z
			M 90 10 C 90 10 86.5 13.8 86 14 C 86 14 76.2 24.8 76 25 L 60 25 L 60 65 C 75 70 85 70 90 65 L 90 25 L 80 25 L 76.7 25 L 90 10 z
			M 60 25 L 55 25 L 50 30 L 60 25 z
			M 10 55 L 10 90 L 41 90 L 41 86 L 45 86 L 45 55 L 10 55 z
			M 42 87 L 42 93 L 48 93 L 48 87 L 42 87 z 
		`);
    }
    makeResizeImageToSelectionIcon() {
      return this.makeIconFromPath(`
			M 75 5 75 10 90 10 90 25 95 25 95 5 75 5 z
			M 15 15 15 30 20 30 20 20 30 20 30 15 15 15 z
			M 84 15 82 17 81 16 81 20 85 20 84 19 86 17 84 15 z
			M 26 24 24 26 26 28 25 29 29 29 29 25 28 26 26 24 z
			M 25 71 26 72 24 74 26 76 28 74 29 75 29 71 25 71 z
			M 15 75 15 85 25 85 25 80 20 80 20 75 15 75 z
			M 90 75 90 90 75 90 75 95 95 95 95 75 90 75 z
			M 81 81 81 85 82 84 84 86 86 84 84 82 85 81 81 81 z
		`);
    }
    /** Renamed to {@link makeResizeImageToSelectionIcon} @deprecated */
    makeResizeViewportIcon() {
      return this.makeResizeImageToSelectionIcon();
    }
    makeDuplicateSelectionIcon() {
      return this.makeIconFromPath(`
			M 45,10 45,55 90,55 90,10 45,10 z
			M 10,25 10,90 70,90 70,60 40,60 40,25 10,25 z 
		`);
    }
    makeCopyIcon() {
      return this.makeIconFromPath(`
			M 45,10 45,55 90,55 90,10 45,10 z
			M 10,25 10,90 70,90 70,60 40,60 40,25 10,25 z 
		`);
    }
    makePasteIcon() {
      const icon2 = this.makeIconFromPath(`
			M 50 0 L 50 5 L 35 5 L 40 24.75 L 20 25 L 20 100 L 85 100 L 100 90 L 100 24 L 75.1 24.3 L 80 5 L 65 5 L 65 0 L 50 0 z
			M 10 15 L 10 115 L 110 115 L 110 15 L 85 15 L 83 20 L 105 20 L 105 110 L 15 110 L 15 20 L 32 20 L 30 15 L 10 15 z
			M 25 35 L 90 35 L 90 40 L 25 40 L 25 35 z
			M 25 45 L 90 45 L 90 50 L 25 50 L 25 45 z
			M 25 55 L 85 55 L 85 60 L 25 60 L 25 55 z
			M 25 65 L 90 65 L 90 70 L 25 70 L 25 65 z 
		`);
      icon2.setAttribute("viewBox", "0 0 120 120");
      return icon2;
    }
    makeDeleteSelectionIcon() {
      return __classPrivateFieldGet10(this, _IconProvider_instances, "m", _IconProvider_makeXIcon).call(this);
    }
    makeCloseIcon() {
      return __classPrivateFieldGet10(this, _IconProvider_instances, "m", _IconProvider_makeXIcon).call(this);
    }
    makeSaveIcon() {
      const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      svg.innerHTML = `
			<style>
				.toolbar-save-icon {
					stroke: var(--icon-color);
					stroke-width: 6;
					stroke-linejoin: round;
					stroke-linecap: round;
					fill: none;
				}
			</style>
			<path
				d='
					M 15,55 30,70 85,20
				'
				class='toolbar-save-icon'
			/>
		`;
      svg.setAttribute("viewBox", "0 0 100 100");
      return svg;
    }
    makeConfigureDocumentIcon() {
      const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      svg.innerHTML = `
			<path
				d='
					M 5,5 V 95 H 95 V 5 Z m 5,5 H 90 V 90 H 10 Z
					m 5,10 V 30 H 50 V 25 H 20 v -5 z
					m 40,0 V 50 H 85 V 20 Z
					m 2,2 H 83 V 39 L 77,28 70,42 64,35 57,45 Z
					m 8.5,5 C 64.67,27 64,27.67 64,28.5 64,29.33 64.67,30 65.5,30 66.33,30 67,29.33 67,28.5 67,27.67 66.33,27 65.5,27 Z
					M 15,40 v 5 h 35 v -5 z
					m 0,15 v 5 h 70 v -5 z
					m 0,15 v 5 h 70 v -5 z
				'
				style='fill: var(--icon-color);'
			/>
		`;
      svg.setAttribute("viewBox", "0 0 100 100");
      return svg;
    }
    makeOverflowIcon() {
      return this.makeIconFromPath(`
			M 15 40
			A 12.5 12.5 0 0 0 2.5 52.5
			A 12.5 12.5 0 0 0 15 65
			A 12.5 12.5 0 0 0 27.5 52.5
			A 12.5 12.5 0 0 0 15 40
			z
	
			M 50 40
			A 12.5 12.5 0 0 0 37.5 52.5
			A 12.5 12.5 0 0 0 50 65
			A 12.5 12.5 0 0 0 62.5 52.5
			A 12.5 12.5 0 0 0 50 40
			z
			
			M 85 40
			A 12.5 12.5 0 0 0 72.5 52.5
			A 12.5 12.5 0 0 0 85 65
			A 12.5 12.5 0 0 0 97.5 52.5
			A 12.5 12.5 0 0 0 85 40
			z
		`);
    }
    makeHelpIcon() {
      const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      svg.innerHTML = `
			<circle
				style="stroke-width:1.587; stroke: var(--icon-color);"
				fill="none"
				cx="13.23"
				cy="13.23"
				r="11.9"
			/>
			<path
				style="stroke-width: 3; stroke-linecap: butt; stroke: var(--icon-color);"
				fill="none"
				d="M 9.26,6.61 C 18.7,3.25 19.95,10.4 14.3,13.4 c -1.15,0.61 -1.32,1.32 -1.32,2.65 v 2.12"
			/>
			<circle
				style="fill: var(--icon-color);"
				cx="13"
				cy="21.32"
				r="1.9"
			/>
		`;
      svg.setAttribute("viewBox", "0 0 26.46 26.46");
      svg.setAttribute("width", "100");
      svg.setAttribute("height", "100");
      return svg;
    }
    /**
     * @param pathData - SVG path data (e.g. `m10,10l30,30z`)
     * @param fill - A valid CSS color (e.g. `var(--icon-color)` or `#f0f`). This can be `none`.
     */
    makeIconFromPath(pathData, fill = "var(--icon-color)", strokeColor = "none", strokeWidth = "0px") {
      const icon2 = document.createElementNS(svgNamespace, "svg");
      const path = document.createElementNS(svgNamespace, "path");
      path.setAttribute("d", pathData);
      path.style.fill = fill;
      path.style.stroke = strokeColor;
      path.style.strokeWidth = strokeWidth;
      icon2.appendChild(path);
      icon2.setAttribute("viewBox", "0 0 100 100");
      return icon2;
    }
    /**
     * @returns An object with both the definition of a checkerboard pattern and the syntax to
     * reference that pattern. The defs provided by this function should be wrapped within a
     * `<defs></defs>` element.
     *
     * **Note**: This function's return value includes both `patternDefElement` (which returns
     * an Element) and a (deprecated) `patternDef` string. Avoid using the `patternDef` result.
     */
    makeCheckerboardPattern() {
      return makeCheckerboardPattern();
    }
    /**
     * @returns true if the given `penStyle` is known to match a rounded tip type of pen.
     */
    isRoundedTipPen(penStyle) {
      return penStyle.factory === makeFreehandLineBuilder || penStyle.factory === makePolylineBuilder;
    }
    isPolylinePen(penStyle) {
      return penStyle.factory === makePolylineBuilder;
    }
    /** Must be overridden by icon packs that need attribution. */
    licenseInfo() {
      return null;
    }
  };
  _IconProvider_instances = /* @__PURE__ */ new WeakSet(), _IconProvider_makeXIcon = function _IconProvider_makeXIcon2() {
    const strokeWidth = "6px";
    const strokeColor = "var(--icon-color)";
    const fillColor = "none";
    return this.makeIconFromPath(`
			M 15,15 85,85
			M 15,85 85,15
		`, fillColor, strokeColor, strokeWidth);
  };
  var IconProvider_default = IconProvider;

  // node_modules/js-draw/dist/mjs/testing/getUniquePointerId.mjs
  var getUniquePointerId = (pointers) => {
    let ptrId = 0;
    const pointerIds = pointers.map((ptr) => ptr.id);
    pointerIds.sort();
    for (const pointerId of pointerIds) {
      if (ptrId === pointerId) {
        ptrId = pointerId + 1;
      }
    }
    return ptrId;
  };
  var getUniquePointerId_default = getUniquePointerId;

  // node_modules/js-draw/dist/mjs/testing/sendPenEvent.mjs
  var sendPenEvent = (editor, eventType, point, allPointers, deviceType = PointerDevice.Pen) => {
    const id = getUniquePointerId_default(allPointers ?? []);
    const mainPointer = Pointer.ofCanvasPoint(point, eventType !== InputEvtType.PointerUpEvt, editor.viewport, id, deviceType);
    editor.toolController.dispatchInputEvent({
      kind: eventType,
      allPointers: allPointers ?? [mainPointer],
      current: mainPointer
    });
    return mainPointer;
  };
  var sendPenEvent_default = sendPenEvent;

  // node_modules/js-draw/dist/mjs/toolbar/constants.mjs
  var toolbarCSSPrefix = "toolbar-";

  // node_modules/js-draw/dist/mjs/toolbar/widgets/layout/DropdownLayoutManager.mjs
  var DropdownEventType;
  (function(DropdownEventType2) {
    DropdownEventType2[DropdownEventType2["DropdownShown"] = 0] = "DropdownShown";
    DropdownEventType2[DropdownEventType2["DropdownHidden"] = 1] = "DropdownHidden";
  })(DropdownEventType || (DropdownEventType = {}));
  var Dropdown = class {
    constructor(parent, notifier, onDestroy) {
      this.parent = parent;
      this.notifier = notifier;
      this.onDestroy = onDestroy;
      this.dropdownToggleListener = null;
      this.hideDropdownTimeout = null;
      this.visible = ReactiveValue.fromInitialValue(false);
      this.dropdownContainer = document.createElement("div");
      this.dropdownContainer.classList.add(`${toolbarCSSPrefix}dropdown`);
      this.dropdownContainer.classList.add("hidden");
      parent.target.insertAdjacentElement("afterend", this.dropdownContainer);
      this.dropdownToggleListener = this.notifier.on(DropdownEventType.DropdownShown, (evt) => {
        if (evt.dropdown !== this && // Don't hide if a submenu was shown (it might be a submenu of
        // the current menu).
        evt.fromToplevelDropdown) {
          this.setVisible(false);
        }
      });
    }
    onActivated() {
    }
    repositionDropdown() {
      const dropdownBBox = this.dropdownContainer.getBoundingClientRect();
      const screenWidth = document.scrollingElement?.clientWidth ?? document.body.clientHeight;
      const screenHeight = document.scrollingElement?.clientHeight ?? document.body.clientHeight;
      let translateX = void 0;
      let translateY = void 0;
      if (dropdownBBox.left > screenWidth / 2) {
        const targetElem = this.parent.target;
        translateX = `calc(${targetElem.clientWidth + "px"} - 100%)`;
      }
      if (dropdownBBox.bottom > screenHeight && dropdownBBox.top - dropdownBBox.height > 0) {
        const targetElem = this.parent.target;
        translateY = `calc(-${targetElem.clientHeight}px - 100%)`;
      }
      if (translateX || translateY) {
        this.dropdownContainer.style.translate = `${translateX ?? "0"} ${translateY ?? "0"}`;
      } else {
        this.dropdownContainer.style.translate = "";
      }
    }
    setVisible(visible) {
      const currentlyVisible = this.visible.get();
      if (currentlyVisible === visible) {
        return;
      }
      if (this.hideDropdownTimeout) {
        clearTimeout(this.hideDropdownTimeout);
        this.hideDropdownTimeout = null;
        this.dropdownContainer.classList.remove("hiding");
        this.repositionDropdown();
      }
      const animationDuration = 150;
      this.visible.set(visible);
      if (visible) {
        this.dropdownContainer.classList.remove("hidden");
        this.notifier.dispatch(DropdownEventType.DropdownShown, {
          dropdown: this,
          fromToplevelDropdown: this.parent.isToplevel()
        });
        this.repositionDropdown();
      } else {
        this.notifier.dispatch(DropdownEventType.DropdownHidden, {
          dropdown: this,
          fromToplevelDropdown: this.parent.isToplevel()
        });
        this.dropdownContainer.classList.add("hiding");
        const hideDelay = animationDuration * 0.95;
        this.hideDropdownTimeout = setTimeout(() => {
          this.dropdownContainer.classList.add("hidden");
          this.dropdownContainer.classList.remove("hiding");
          this.repositionDropdown();
        }, hideDelay);
      }
      const animationName = `var(--dropdown-${visible ? "show" : "hide"}-animation)`;
      this.dropdownContainer.style.animation = `${animationDuration}ms ease ${animationName}`;
    }
    requestShow() {
      this.setVisible(true);
    }
    requestHide() {
      this.setVisible(false);
    }
    appendChild(item) {
      this.dropdownContainer.appendChild(item);
    }
    clearChildren() {
      this.dropdownContainer.replaceChildren();
    }
    destroy() {
      this.setVisible(false);
      this.dropdownContainer.remove();
      this.dropdownToggleListener?.remove();
      this.clearChildren();
      this.onDestroy();
    }
  };
  var DropdownLayoutManager = class {
    constructor(announceForAccessibility, localization7) {
      this.localization = localization7;
      this.dropdowns = /* @__PURE__ */ new Set();
      this.listeners = [];
      this.connectedNotifiers = [];
      this.notifier = new EventDispatcher();
      this.notifier.on(DropdownEventType.DropdownShown, ({ dropdown, fromToplevelDropdown }) => {
        if (!dropdown)
          return;
        announceForAccessibility(this.localization.dropdownShown(dropdown.parent.getTitle()));
        this.connectedNotifiers.forEach((notifier) => {
          notifier.dispatch(EditorEventType.ToolbarDropdownShown, {
            kind: EditorEventType.ToolbarDropdownShown,
            fromToplevelDropdown,
            layoutManager: this
          });
        });
      });
      this.notifier.on(DropdownEventType.DropdownHidden, ({ dropdown }) => {
        if (!dropdown)
          return;
        announceForAccessibility(this.localization.dropdownHidden(dropdown.parent.getTitle()));
      });
    }
    connectToEditorNotifier(notifier) {
      this.connectedNotifiers.push(notifier);
      this.refreshListeners();
    }
    /** Creates a dropdown within `parent`. */
    createToolMenu(parent) {
      const dropdown = new Dropdown(parent, this.notifier, () => {
        this.dropdowns.delete(dropdown);
        this.refreshListeners();
      });
      this.dropdowns.add(dropdown);
      this.refreshListeners();
      return dropdown;
    }
    /**
     * Adds/removes listeners based on whether we have any managed dropdowns.
     *
     * We attempt to clean up all resources when `dropdowns.size == 0`, at which
     * point, an instance of this could be safely garbage collected.
     */
    refreshListeners() {
      const clearListeners = () => {
        this.listeners.forEach((l) => l.remove());
        this.listeners = [];
      };
      if (this.dropdowns.size === 0) {
        clearListeners();
      } else if (this.listeners.length !== this.connectedNotifiers.length) {
        clearListeners();
        this.listeners = this.connectedNotifiers.map((notifier) => {
          return notifier.on(EditorEventType.ToolbarDropdownShown, (evt) => {
            if (evt.kind !== EditorEventType.ToolbarDropdownShown || // Don't forward to ourselves events that we originally triggered.
            evt.layoutManager === this) {
              return;
            }
            this.notifier.dispatch(DropdownEventType.DropdownShown, {
              fromToplevelDropdown: evt.fromToplevelDropdown
            });
          });
        });
      }
    }
  };

  // node_modules/js-draw/dist/mjs/util/dom/listenForLongPressOrHover.mjs
  var listenForLongPressOrHover = (target, options) => {
    const pointersInside = /* @__PURE__ */ new Map();
    let timeoutId = null;
    let isLongPressInProgress = false;
    const updateTimeout = () => {
      if (pointersInside.size === 0) {
        if (isLongPressInProgress) {
          isLongPressInProgress = false;
          options.onEnd();
        } else if (timeoutId !== null) {
          clearTimeout(timeoutId);
          timeoutId = null;
        }
      } else {
        const nowTime = Date.now();
        let timeSinceFirstPointer = 0;
        for (const record of pointersInside.values()) {
          const timeSince = nowTime - record.timeEnter;
          timeSinceFirstPointer = Math.max(timeSince, timeSinceFirstPointer);
        }
        const longPressTimeout = options.longPressTimeout ?? 700;
        if (timeoutId !== null) {
          clearTimeout(timeoutId);
          timeoutId = null;
        }
        const timeLeft = longPressTimeout - timeSinceFirstPointer;
        if (timeLeft <= 0) {
          options.onStart();
          isLongPressInProgress = true;
        } else {
          timeoutId = setTimeout(() => {
            timeoutId = null;
            updateTimeout();
          }, timeLeft);
        }
      }
    };
    const pointerEventListener = (event) => {
      const eventRecord = {
        timeEnter: Date.now()
      };
      if (event.type === "pointerenter") {
        pointersInside.set(event.pointerId, eventRecord);
      } else if (event.type === "pointerleave" || event.type === "pointercancel") {
        pointersInside.clear();
      }
      updateTimeout();
    };
    target.addEventListener("pointerenter", pointerEventListener);
    target.addEventListener("pointerleave", pointerEventListener);
    target.addEventListener("pointercancel", pointerEventListener);
    return {
      removeListeners: () => {
        target.removeEventListener("pointerenter", pointerEventListener);
        target.removeEventListener("pointerleave", pointerEventListener);
        target.removeEventListener("pointercancel", pointerEventListener);
      }
    };
  };
  var listenForLongPressOrHover_default = listenForLongPressOrHover;

  // node_modules/js-draw/dist/mjs/util/dom/addLongPressOrHoverCssClasses.mjs
  var addLongPressOrHoverCssClasses = (element, options) => {
    const hasLongPressClass = "has-long-press-or-hover";
    const noLongPressClass = "no-long-press-or-hover";
    element.classList.add("no-long-press-or-hover");
    const { removeListeners } = listenForLongPressOrHover_default(element, {
      onStart() {
        element.classList.remove(noLongPressClass);
        element.classList.add(hasLongPressClass);
      },
      onEnd() {
        element.classList.add(noLongPressClass);
        element.classList.remove(hasLongPressClass);
      },
      longPressTimeout: options?.timeout
    });
    return {
      removeEventListeners: () => {
        element.classList.remove(noLongPressClass);
        removeListeners();
      }
    };
  };
  var addLongPressOrHoverCssClasses_default = addLongPressOrHoverCssClasses;

  // node_modules/js-draw/dist/mjs/toolbar/utils/makeDraggable.mjs
  var makeDraggable = (dragElement, options) => {
    const dragElements = [...options.draggableChildElements, dragElement];
    let lastX = 0;
    let lastY = 0;
    let startX = 0;
    let startY = 0;
    let pointerDown = false;
    let capturedPointerId = null;
    const isDraggableElement = (element) => {
      if (!element) {
        return false;
      }
      if (dragElements.includes(element)) {
        return true;
      }
      const undraggableElementTypes = ["INPUT", "SELECT"];
      let hasSuitableAncestors = false;
      let ancestor = element.parentElement;
      while (ancestor) {
        if (undraggableElementTypes.includes(ancestor.tagName))
          break;
        if (dragElements.includes(ancestor)) {
          hasSuitableAncestors = true;
          break;
        }
        ancestor = ancestor.parentElement;
      }
      return !undraggableElementTypes.includes(element.tagName) && hasSuitableAncestors;
    };
    const canScrollAncestorVertically = (element, direction) => {
      if (!(element instanceof HTMLElement))
        return false;
      let ancestor = element;
      while (ancestor && !dragElements.includes(ancestor)) {
        const epsilon2 = 10;
        if (ancestor.scrollHeight > ancestor.clientHeight + epsilon2) {
          const canScrollUp = ancestor.scrollTop > epsilon2;
          const canScrollDown = ancestor.scrollTop + ancestor.clientHeight < ancestor.scrollHeight - epsilon2;
          if (direction.y < 0 && canScrollDown)
            return true;
          if (direction.y > 0 && canScrollUp)
            return true;
        }
        ancestor = ancestor.parentElement;
      }
      return false;
    };
    const removeEventListenerCallbacks = [];
    const addEventListener2 = (listenerType, listener, options2) => {
      dragElement.addEventListener(listenerType, listener, options2);
      removeEventListenerCallbacks.push(() => {
        dragElement.removeEventListener(listenerType, listener);
      });
    };
    const clickThreshold = 5;
    const isRoughlyClick = (currentX, currentY) => {
      return Math.hypot(currentX - startX, currentY - startY) < clickThreshold;
    };
    let startedDragging = false;
    addEventListener2("pointerdown", (event) => {
      if (event.defaultPrevented || !isDraggableElement(event.target)) {
        return;
      }
      if (event.isPrimary) {
        startedDragging = false;
        lastX = event.clientX;
        lastY = event.clientY;
        startX = event.clientX;
        startY = event.clientY;
        capturedPointerId = null;
        pointerDown = true;
      }
    }, { passive: true });
    const onGestureEnd = (_event) => {
      if (!pointerDown) {
        return;
      }
      if (capturedPointerId !== null) {
        dragElement.releasePointerCapture(capturedPointerId);
        capturedPointerId = null;
      }
      options.onDragEnd({
        roughlyClick: isRoughlyClick(lastX, lastY),
        endTimestamp: performance.now(),
        displacement: Vec2.of(lastX - startX, lastY - startY)
      });
      pointerDown = false;
      startedDragging = false;
    };
    addEventListener2("pointermove", (event) => {
      if (!event.isPrimary || !pointerDown) {
        return void 0;
      }
      if (event.pointerType === "mouse" && event.buttons === 0) {
        onGestureEnd(event);
        return void 0;
      }
      const x = event.clientX;
      const y = event.clientY;
      const isClick = isRoughlyClick(x, y);
      const dx = x - lastX;
      const dy = y - lastY;
      const deltaToStart = Vec2.of(x - startX, y - startY);
      const isScroll = () => canScrollAncestorVertically(event.target, deltaToStart);
      if (startedDragging || !isClick && !isScroll()) {
        options.onDrag(dx, dy, deltaToStart);
        if (capturedPointerId === null) {
          dragElement.setPointerCapture(event.pointerId);
          capturedPointerId = event.pointerId;
        }
        lastX = x;
        lastY = y;
        startedDragging = true;
      }
    });
    addEventListener2("pointerleave", (event) => {
      if (capturedPointerId === null && pointerDown && event.isPrimary) {
        dragElement.setPointerCapture(event.pointerId);
        capturedPointerId = event.pointerId;
      }
    });
    addEventListener2("pointerup", onGestureEnd);
    addEventListener2("pointercancel", onGestureEnd);
    addEventListener2("touchmove", (event) => {
      if (startedDragging && event.touches.length > 0) {
        event.preventDefault();
      }
    });
    return {
      removeListeners: () => {
        for (const removeListenerCallback of removeEventListenerCallbacks) {
          removeListenerCallback();
        }
      }
    };
  };
  var makeDraggable_default = makeDraggable;

  // node_modules/js-draw/dist/mjs/util/dom/cloneElementWithStyles.mjs
  var cloneElementWithStyles = (element) => {
    const restyle = (originalElement, clonedElement) => {
      const originalComputedStyle = getComputedStyle(originalElement);
      for (let index = 0; index < originalComputedStyle.length; index++) {
        const propertyName = originalComputedStyle.item(index);
        const propertyValue = originalComputedStyle.getPropertyValue(propertyName);
        clonedElement.style?.setProperty(propertyName, propertyValue);
      }
      for (let i = 0; i < originalElement.children.length; i++) {
        const originalChild = originalElement.children.item(i);
        const clonedChild = clonedElement.children.item(i);
        if (originalChild && clonedChild) {
          restyle(originalChild, clonedChild);
        } else {
          console.warn("CloneElement: Missing child");
        }
      }
    };
    const elementClone = element.cloneNode(true);
    restyle(element, elementClone);
    return elementClone;
  };
  var cloneElementWithStyles_default = cloneElementWithStyles;

  // node_modules/js-draw/dist/mjs/toolbar/utils/HelpDisplay.mjs
  var __classPrivateFieldGet11 = function(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var _HelpDisplay_helpData;
  var createHelpPage = (helpItems, onItemClick, onBackgroundClick, context) => {
    const container = document.createElement("div");
    container.classList.add("help-page-container");
    const textLabel = document.createElement("div");
    textLabel.classList.add("label", "-space-above");
    textLabel.setAttribute("aria-live", "polite");
    let currentItemIndex = 0;
    let currentItem = helpItems[0] ?? null;
    let clonedElementContainers = [];
    container.addEventListener("click", (event) => {
      if (event.target === container) {
        onBackgroundClick();
      }
    });
    const getCombinedBBox = () => {
      if (!currentItem) {
        return Rect2.empty;
      }
      const itemBoundingBoxes = currentItem.targetElements.map((element) => Rect2.of(element.getBoundingClientRect()));
      return Rect2.union(...itemBoundingBoxes);
    };
    const updateClonedElementStates = () => {
      const currentItemBBox = getCombinedBBox();
      for (let index = 0; index < clonedElementContainers.length; index++) {
        for (const { container: container2, bbox: containerBBox } of clonedElementContainers[index]) {
          if (index === currentItemIndex) {
            container2.classList.add("-active");
            container2.classList.remove("-clickable", "-background");
            container2.onclick = () => {
            };
          } else {
            if (!containerBBox.containsRect(currentItemBBox)) {
              container2.classList.add("-clickable");
              container2.classList.remove("-active", "-background");
            } else {
              container2.classList.add("-background");
              container2.classList.remove("-active", "-clickable");
            }
            const containerIndex = index;
            container2.onclick = () => {
              onItemClick(containerIndex);
            };
          }
        }
      }
    };
    const updateLabelPosition = () => {
      const labelBBox = Rect2.of(textLabel.getBoundingClientRect());
      const combinedBBox = getCombinedBBox();
      if (labelBBox.intersects(combinedBBox)) {
        const containerBBox = Rect2.of(container.getBoundingClientRect());
        const spaceAboveCombined = combinedBBox.topLeft.y;
        const spaceBelowCombined = containerBBox.bottomLeft.y - combinedBBox.bottomLeft.y;
        if (spaceAboveCombined > spaceBelowCombined && spaceAboveCombined > labelBBox.height / 3) {
          textLabel.classList.remove("-small-space-above", "-large-space-above");
          textLabel.classList.add("-large-space-below");
        }
        if (spaceAboveCombined < spaceBelowCombined && spaceBelowCombined > labelBBox.height) {
          textLabel.classList.add("-large-space-above");
          textLabel.classList.remove("-large-space-below");
        }
      }
    };
    const refreshContent = () => {
      container.replaceChildren();
      textLabel.classList.remove("-large-space-above");
      textLabel.classList.add("-small-space-above", "-large-space-below");
      container.appendChild(textLabel);
      const screenBBox = new Rect2(0, 0, window.innerWidth, window.innerHeight);
      clonedElementContainers = [];
      for (let itemIndex = 0; itemIndex < helpItems.length; itemIndex++) {
        const item = helpItems[itemIndex];
        const itemCloneContainers = [];
        for (const targetElement of item.targetElements) {
          let targetBBox = Rect2.of(targetElement.getBoundingClientRect());
          if (!screenBBox.intersects(targetBBox)) {
            const screenBottomCenter = screenBBox.bottomLeft.lerp(screenBBox.bottomRight, 0.5);
            const targetBottomCenter = targetBBox.bottomLeft.lerp(targetBBox.bottomRight, 0.5);
            const delta = screenBottomCenter.minus(targetBottomCenter);
            targetBBox = targetBBox.translatedBy(delta);
          }
          const clonedElement = cloneElementWithStyles_default(targetElement);
          for (const input of clonedElement.querySelectorAll("input")) {
            input.disabled = true;
          }
          clonedElement.style.margin = "0";
          const clonedElementContainer = document.createElement("div");
          clonedElementContainer.classList.add("cloned-element-container");
          clonedElementContainer.role = "group";
          clonedElementContainer.ariaLabel = context.localization.helpControlsAccessibilityLabel;
          clonedElementContainer.style.position = "absolute";
          clonedElementContainer.style.left = `${targetBBox.topLeft.x}px`;
          clonedElementContainer.style.top = `${targetBBox.topLeft.y}px`;
          clonedElementContainer.replaceChildren(clonedElement);
          addLongPressOrHoverCssClasses_default(clonedElementContainer, { timeout: 0 });
          itemCloneContainers.push({ container: clonedElementContainer, bbox: targetBBox });
          container.appendChild(clonedElementContainer);
        }
        clonedElementContainers.push(itemCloneContainers);
      }
      updateClonedElementStates();
    };
    const refresh = () => {
      refreshContent();
      updateLabelPosition();
    };
    const onItemChange = () => {
      const helpTextElement = document.createElement("div");
      helpTextElement.textContent = currentItem?.helpText ?? "";
      helpTextElement.classList.add("current-item-help");
      const navigationHelpElement = document.createElement("div");
      navigationHelpElement.textContent = context.localization.helpScreenNavigationHelp;
      navigationHelpElement.classList.add("navigation-help");
      textLabel.replaceChildren(helpTextElement, ...currentItemIndex === 0 ? [navigationHelpElement] : []);
      updateClonedElementStates();
    };
    onItemChange();
    return {
      addToParent: (parent) => {
        refreshContent();
        parent.appendChild(container);
        updateLabelPosition();
      },
      refresh,
      setPageIndex: (pageIndex) => {
        currentItemIndex = pageIndex;
        currentItem = helpItems[pageIndex];
        onItemChange();
      }
    };
  };
  var HelpDisplay = class {
    /** Constructed internally by BaseWidget. @internal */
    constructor(createOverlay, context) {
      this.createOverlay = createOverlay;
      this.context = context;
      _HelpDisplay_helpData.set(this, []);
    }
    /** @internal */
    showHelpOverlay() {
      const overlay = document.createElement("dialog");
      overlay.setAttribute("autofocus", "true");
      overlay.classList.add("toolbar-help-overlay");
      const closing = false;
      const closeOverlay = () => {
        if (closing)
          return;
        const animationDelay = 250;
        overlay.classList.add("-hiding");
        setTimeout(() => overlay.close(), animationDelay);
      };
      let lastDragTimestamp = 0;
      const onBackgroundClick = () => {
        const wasJustDragging = performance.now() - lastDragTimestamp < 100;
        if (!wasJustDragging) {
          closeOverlay();
        }
      };
      const makeCloseButton = () => {
        const closeButton = createButton_default();
        closeButton.classList.add("close-button");
        closeButton.appendChild(this.context.icons.makeCloseIcon());
        const label = this.context.localization.close;
        closeButton.setAttribute("aria-label", label);
        closeButton.setAttribute("title", label);
        closeButton.onclick = () => {
          closeOverlay();
        };
        return closeButton;
      };
      const makeNavigationContent = () => {
        const currentPage = MutableReactiveValue.fromInitialValue(0);
        const content = document.createElement("div");
        content.classList.add("navigation-content");
        const helpPage = createHelpPage(__classPrivateFieldGet11(this, _HelpDisplay_helpData, "f"), (newPageIndex) => currentPage.set(newPageIndex), onBackgroundClick, this.context);
        helpPage.addToParent(content);
        const showPage = (pageIndex) => {
          if (pageIndex >= __classPrivateFieldGet11(this, _HelpDisplay_helpData, "f").length || pageIndex < 0) {
            console.warn("Help screen: Navigated to out-of-bounds page", pageIndex);
            content.style.display = "none";
          } else {
            content.style.display = "";
            helpPage.setPageIndex(pageIndex);
          }
        };
        currentPage.onUpdateAndNow(showPage);
        const navigationControl = {
          content,
          currentPage,
          toNext: () => {
            if (navigationControl.hasNext()) {
              currentPage.set(currentPage.get() + 1);
            }
          },
          toPrevious: () => {
            if (navigationControl.hasPrevious()) {
              currentPage.set(currentPage.get() - 1);
            }
          },
          hasNext: () => {
            return currentPage.get() + 1 < __classPrivateFieldGet11(this, _HelpDisplay_helpData, "f").length;
          },
          hasPrevious: () => {
            return currentPage.get() > 0;
          },
          refreshCurrent: () => {
            helpPage.refresh();
          }
        };
        return navigationControl;
      };
      const makeNavigationButtons = (navigation2) => {
        const navigationButtonContainer = document.createElement("div");
        navigationButtonContainer.classList.add("navigation-buttons");
        const nextButton = createButton_default();
        const previousButton = createButton_default();
        nextButton.textContent = this.context.localization.next;
        previousButton.textContent = this.context.localization.previous;
        nextButton.classList.add("next");
        previousButton.classList.add("previous");
        const updateButtonVisibility = () => {
          navigationButtonContainer.classList.remove("-has-next", "-has-previous");
          if (navigation2.hasNext()) {
            navigationButtonContainer.classList.add("-has-next");
            nextButton.disabled = false;
          } else {
            navigationButtonContainer.classList.remove("-has-next");
            nextButton.disabled = true;
          }
          if (navigation2.hasPrevious()) {
            navigationButtonContainer.classList.add("-has-previous");
            previousButton.disabled = false;
          } else {
            navigationButtonContainer.classList.remove("-has-previous");
            previousButton.disabled = true;
          }
        };
        navigation2.currentPage.onUpdateAndNow(updateButtonVisibility);
        nextButton.onclick = () => {
          navigation2.toNext();
        };
        previousButton.onclick = () => {
          navigation2.toPrevious();
        };
        navigationButtonContainer.replaceChildren(previousButton, nextButton);
        return navigationButtonContainer;
      };
      const navigation = makeNavigationContent();
      const navigationButtons = makeNavigationButtons(navigation);
      overlay.replaceChildren(makeCloseButton(), navigationButtons, navigation.content);
      this.createOverlay(overlay);
      overlay.showModal();
      const minDragOffsetToTransition = 30;
      const setDragOffset = (offset) => {
        if (offset > 0 && !navigation.hasPrevious()) {
          offset = 0;
        }
        if (offset < 0 && !navigation.hasNext()) {
          offset = 0;
        }
        if (offset > minDragOffsetToTransition || offset < -minDragOffsetToTransition) {
          offset = minDragOffsetToTransition * Math.sign(offset);
        }
        overlay.style.transform = `translate(${offset}px, 0px)`;
        if (offset >= minDragOffsetToTransition) {
          navigationButtons.classList.add("-highlight-previous");
        } else {
          navigationButtons.classList.remove("-highlight-previous");
        }
        if (offset <= -minDragOffsetToTransition) {
          navigationButtons.classList.add("-highlight-next");
        } else {
          navigationButtons.classList.remove("-highlight-next");
        }
      };
      const dragListener = makeDraggable_default(overlay, {
        draggableChildElements: [navigation.content],
        onDrag: (_deltaX, _deltaY, totalDisplacement) => {
          overlay.classList.add("-dragging");
          setDragOffset(totalDisplacement.x);
        },
        onDragEnd: (dragStatistics) => {
          overlay.classList.remove("-dragging");
          setDragOffset(0);
          if (!dragStatistics.roughlyClick) {
            const xDisplacement = dragStatistics.displacement.x;
            if (xDisplacement > minDragOffsetToTransition) {
              navigation.toPrevious();
            } else if (xDisplacement < -minDragOffsetToTransition) {
              navigation.toNext();
            }
            lastDragTimestamp = dragStatistics.endTimestamp;
          }
        }
      });
      let resizeObserver;
      if (window.ResizeObserver) {
        resizeObserver = new ResizeObserver(() => {
          navigation.refreshCurrent();
        });
        resizeObserver.observe(overlay);
      }
      const onMediaChangeListener = () => {
        requestAnimationFrame(() => navigation.refreshCurrent());
      };
      const mediaQueryList = window.matchMedia?.("(prefers-color-scheme: dark)");
      mediaQueryList?.addEventListener("change", onMediaChangeListener);
      const closeOverlayTriggers = [navigation.content, navigationButtons, overlay];
      overlay.onclick = (event) => {
        if (closeOverlayTriggers.includes(event.target)) {
          onBackgroundClick();
        }
      };
      overlay.onkeyup = (event) => {
        if (event.code === "Escape") {
          closeOverlay();
          event.preventDefault();
        } else if (event.code === "ArrowRight") {
          navigation.toNext();
          event.preventDefault();
        } else if (event.code === "ArrowLeft") {
          navigation.toPrevious();
          event.preventDefault();
        }
      };
      overlay.addEventListener("close", () => {
        this.context.announceForAccessibility(this.context.localization.helpHidden);
        mediaQueryList?.removeEventListener("change", onMediaChangeListener);
        dragListener.removeListeners();
        resizeObserver?.disconnect();
        overlay.remove();
      });
    }
    /** Marks `helpText` as associated with a single `targetElement`. */
    registerTextHelpForElement(targetElement, helpText) {
      this.registerTextHelpForElements([targetElement], helpText);
    }
    /** Marks `helpText` as associated with all elements in `targetElements`. */
    registerTextHelpForElements(targetElements, helpText) {
      __classPrivateFieldGet11(this, _HelpDisplay_helpData, "f").push({ targetElements: [...targetElements], helpText });
    }
    /** Returns true if any help text has been registered. */
    hasHelpText() {
      return __classPrivateFieldGet11(this, _HelpDisplay_helpData, "f").length > 0;
    }
    /**
     * Creates and returns a button that toggles the help display.
     */
    createToggleButton() {
      const buttonContainer = document.createElement("div");
      buttonContainer.classList.add("toolbar-help-overlay-button");
      const helpButton = createButton_default();
      helpButton.classList.add("button");
      const icon2 = this.context.icons.makeHelpIcon();
      icon2.classList.add("icon");
      helpButton.appendChild(icon2);
      helpButton.setAttribute("aria-label", this.context.localization.help);
      helpButton.onclick = () => {
        this.showHelpOverlay();
      };
      buttonContainer.appendChild(helpButton);
      return buttonContainer;
    }
  };
  _HelpDisplay_helpData = /* @__PURE__ */ new WeakMap();
  var HelpDisplay_default = HelpDisplay;

  // node_modules/js-draw/dist/mjs/toolbar/widgets/BaseWidget.mjs
  var __classPrivateFieldSet10 = function(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var __classPrivateFieldGet12 = function(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var _BaseWidget_instances;
  var _a5;
  var _BaseWidget_hasDropdown;
  var _BaseWidget_disabledDueToReadOnlyEditor;
  var _BaseWidget_tags;
  var _BaseWidget_removeEditorListeners;
  var _BaseWidget_addEditorListeners;
  var ToolbarWidgetTag;
  (function(ToolbarWidgetTag2) {
    ToolbarWidgetTag2["Save"] = "save";
    ToolbarWidgetTag2["Exit"] = "exit";
    ToolbarWidgetTag2["Undo"] = "undo";
    ToolbarWidgetTag2["Redo"] = "redo";
  })(ToolbarWidgetTag || (ToolbarWidgetTag = {}));
  var BaseWidget = class {
    constructor(editor, id, localizationTable) {
      _BaseWidget_instances.add(this);
      this.editor = editor;
      this.id = id;
      this.dropdown = null;
      _BaseWidget_hasDropdown.set(this, void 0);
      this.disabled = false;
      _BaseWidget_disabledDueToReadOnlyEditor.set(this, false);
      _BaseWidget_tags.set(this, []);
      this.subWidgets = {};
      this.toplevel = true;
      _BaseWidget_removeEditorListeners.set(this, null);
      this.localizationTable = localizationTable ?? editor.localization;
      const defaultLayoutManager = new DropdownLayoutManager((text) => this.editor.announceForAccessibility(text), this.localizationTable);
      defaultLayoutManager.connectToEditorNotifier(editor.notifier);
      this.layoutManager = defaultLayoutManager;
      this.icon = null;
      this.container = document.createElement("div");
      this.container.classList.add(`${toolbarCSSPrefix}toolContainer`, `${toolbarCSSPrefix}toolButtonContainer`, `${toolbarCSSPrefix}internalWidgetId--${id.replace(/[^a-zA-Z0-9_]/g, "-")}`);
      this.dropdownContent = document.createElement("div");
      __classPrivateFieldSet10(this, _BaseWidget_hasDropdown, false, "f");
      this.button = document.createElement("div");
      this.button.classList.add(`${toolbarCSSPrefix}button`);
      this.label = document.createElement("label");
      this.button.setAttribute("role", "button");
      this.button.tabIndex = 0;
      this.button.oncontextmenu = (event) => {
        event.preventDefault();
      };
      addLongPressOrHoverCssClasses_default(this.button);
    }
    /**
     * Should return a constant true or false value. If true (the default),
     * this widget must be automatically disabled when its editor is read-only.
     */
    shouldAutoDisableInReadOnlyEditor() {
      return true;
    }
    getId() {
      return this.id;
    }
    /**
     * Note: Tags should be set *before* a tool widget is added to a toolbar.
     *
     *
     * Associates tags with this widget that can be used by toolbar themes
     * to customize the layout/appearance of this button. Prefer tags in
     * the `ToolbarWidgetTag` enum, where possible.
     *
     * In addition to being readable from the {@link getTags} method, tags are
     * added to a button's main container as CSS classes with the `toolwidget-tag--` prefix.
     *
     * For example, the `undo` tag would result in `toolwidget-tag--undo`
     * being added to the button's container's class list.
     *
     */
    setTags(tags) {
      const toClassName = (tag) => {
        return `toolwidget-tag--${tag}`;
      };
      for (const tag of __classPrivateFieldGet12(this, _BaseWidget_tags, "f")) {
        this.container.classList.remove(toClassName(tag));
      }
      __classPrivateFieldSet10(this, _BaseWidget_tags, [...tags], "f");
      for (const tag of __classPrivateFieldGet12(this, _BaseWidget_tags, "f")) {
        this.container.classList.add(toClassName(tag));
      }
    }
    getTags() {
      return [...__classPrivateFieldGet12(this, _BaseWidget_tags, "f")];
    }
    /**
     * Returns the ID of this widget in `container`. Adds a suffix to this' ID
     * if an item in `container` already has this' ID.
     *
     * For example, if `this` has ID `foo` and if
     * `container = { 'foo': somethingNotThis, 'foo-1': somethingElseNotThis }`, this method
     * returns `foo-2` because elements with IDs `foo` and `foo-1` are already present in
     * `container`.
     *
     * If `this` is already in `container`, returns the id given to `this` in the container.
     */
    getUniqueIdIn(container) {
      let id = this.getId();
      let idCounter5 = 0;
      while (id in container && container[id] !== this) {
        id = this.getId() + "-" + idCounter5.toString();
        idCounter5++;
      }
      return id;
    }
    // Add content to the widget's associated dropdown menu.
    // Returns true if such a menu should be created, false otherwise.
    fillDropdown(dropdown, helpDisplay) {
      if (Object.keys(this.subWidgets).length === 0) {
        return false;
      }
      for (const widgetId in this.subWidgets) {
        const widget = this.subWidgets[widgetId];
        const widgetElement = widget.addTo(dropdown);
        widget.setIsToplevel(false);
        const helpText = widget.getHelpText();
        if (helpText) {
          helpDisplay?.registerTextHelpForElement(widgetElement, helpText);
        }
      }
      return true;
    }
    /**
     * Should return a 1-2 sentence description of the widget.
     *
     * At present, this is only used if this widget has an associated dropdown.
     */
    getHelpText() {
      return void 0;
    }
    /** @deprecated Renamed to `setUpButtonEventListeners`. */
    setupActionBtnClickListener(button) {
      return this.setUpButtonEventListeners(button);
    }
    setUpButtonEventListeners(button) {
      const clickTriggers = { Enter: true, " ": true };
      button.onkeydown = (evt) => {
        let handled = false;
        if (evt.key in clickTriggers) {
          if (!this.disabled) {
            this.handleClick();
            handled = true;
          }
        }
        if (!handled) {
          const editorEvent = keyPressEventFromHTMLEvent(evt);
          handled = this.editor.toolController.dispatchInputEvent(editorEvent);
        }
        if (handled) {
          evt.preventDefault();
        }
      };
      button.onkeyup = (htmlEvent) => {
        if (htmlEvent.key in clickTriggers) {
          return;
        }
        const event = keyUpEventFromHTMLEvent(htmlEvent);
        const handled = this.editor.toolController.dispatchInputEvent(event);
        if (handled) {
          htmlEvent.preventDefault();
        }
      };
      button.onclick = () => {
        if (!this.disabled) {
          this.handleClick();
        }
      };
      button.ondblclick = (event) => {
        event.preventDefault();
      };
    }
    // Add a listener that is triggered when a key is pressed.
    // Listeners will fire regardless of whether this widget is selected and require that
    // {@link Editor.toolController} to have an enabled {@link ToolbarShortcutHandler} tool.
    onKeyPress(_event) {
      return false;
    }
    get hasDropdown() {
      return __classPrivateFieldGet12(this, _BaseWidget_hasDropdown, "f");
    }
    // Add a widget to this' dropdown. Must be called before this.addTo.
    addSubWidget(widget) {
      const id = widget.getUniqueIdIn(this.subWidgets);
      this.subWidgets[id] = widget;
    }
    setLayoutManager(manager) {
      if (manager === this.layoutManager) {
        return;
      }
      this.layoutManager = manager;
      if (this.container.parentElement) {
        this.addTo(this.container.parentElement);
      }
    }
    /**
     * Adds this to `parent`.
     * Returns the element that was just added to `parent`.
     * @internal
     */
    addTo(parent) {
      this.icon = null;
      this.updateIcon();
      this.label.innerText = this.getTitle();
      const longLabelCSSClass = "long-label";
      if (this.label.innerText.length > 7) {
        this.label.classList.add(longLabelCSSClass);
      } else {
        this.label.classList.remove(longLabelCSSClass);
      }
      this.setUpButtonEventListeners(this.button);
      this.container.replaceChildren();
      this.button.replaceChildren(this.icon, this.label);
      this.container.appendChild(this.button);
      const helpDisplay = new HelpDisplay_default((content) => this.editor.createHTMLOverlay(content), this.editor);
      const helpText = this.getHelpText();
      if (helpText) {
        helpDisplay.registerTextHelpForElement(this.dropdownContent, [this.getTitle(), helpText].join("\n\n"));
      }
      this.dropdownContent.replaceChildren();
      __classPrivateFieldSet10(this, _BaseWidget_hasDropdown, this.fillDropdown(this.dropdownContent, helpDisplay), "f");
      if (__classPrivateFieldGet12(this, _BaseWidget_hasDropdown, "f")) {
        this.button.classList.add("has-dropdown");
        this.dropdown?.destroy();
        this.dropdownIcon = this.createDropdownIcon();
        this.button.appendChild(this.dropdownIcon);
        this.dropdown = this.layoutManager.createToolMenu({
          target: this.button,
          getTitle: () => this.getTitle(),
          isToplevel: () => this.toplevel
        });
        this.dropdown.visible.onUpdate((visible) => {
          if (visible) {
            this.container.classList.add("dropdownVisible");
          } else {
            this.container.classList.remove("dropdownVisible");
          }
          if (!visible) {
            this.focus();
          }
        });
        if (helpDisplay.hasHelpText()) {
          this.dropdown.appendChild(helpDisplay.createToggleButton());
        }
        this.dropdown.appendChild(this.dropdownContent);
      }
      this.setDropdownVisible(false);
      if (this.container.parentElement) {
        this.container.remove();
      }
      __classPrivateFieldGet12(this, _BaseWidget_instances, "m", _BaseWidget_addEditorListeners).call(this);
      parent.appendChild(this.container);
      return this.container;
    }
    /**
     * Remove this. This allows the widget to be added to a toolbar again
     * in the future using `addTo`.
     */
    remove() {
      this.container.remove();
      __classPrivateFieldGet12(this, _BaseWidget_removeEditorListeners, "f")?.call(this);
    }
    focus() {
      this.button.focus();
    }
    /**
     * @internal
     */
    addCSSClassToContainer(className) {
      this.container.classList.add(className);
    }
    removeCSSClassFromContainer(className) {
      this.container.classList.remove(className);
    }
    updateIcon() {
      let newIcon = this.createIcon();
      if (!newIcon) {
        newIcon = document.createElement("div");
        this.container.classList.add("no-icon");
      } else {
        this.container.classList.remove("no-icon");
      }
      this.icon?.replaceWith(newIcon);
      this.icon = newIcon;
      this.icon.classList.add(`${toolbarCSSPrefix}icon`);
    }
    setDisabled(disabled) {
      this.disabled = disabled;
      __classPrivateFieldSet10(this, _BaseWidget_disabledDueToReadOnlyEditor, false, "f");
      if (this.disabled) {
        this.button.classList.add("disabled");
        this.button.setAttribute("aria-disabled", "true");
      } else {
        this.button.classList.remove("disabled");
        this.button.removeAttribute("aria-disabled");
      }
    }
    setSelected(selected) {
      const currentlySelected = this.isSelected();
      if (currentlySelected === selected) {
        return;
      }
      this.button.setAttribute("role", "switch");
      if (selected) {
        this.container.classList.add("selected");
        this.button.setAttribute("aria-checked", "true");
      } else {
        this.container.classList.remove("selected");
        this.button.setAttribute("aria-checked", "false");
      }
    }
    setDropdownVisible(visible) {
      if (visible) {
        this.dropdown?.requestShow();
      } else {
        this.dropdown?.requestHide();
      }
    }
    /**
     * Only used by some layout managers.
     * In those layout managers, makes this dropdown visible.
     */
    activateDropdown() {
      this.dropdown?.onActivated();
    }
    /**
     * Returns `true` if this widget must always be in a toplevel menu and not
     * in a scrolling/overflow menu.
     *
     * This method can be overidden to override the default of `true`.
     */
    mustBeInToplevelMenu() {
      return false;
    }
    /**
     * Returns true iff this widget can be in a nontoplevel menu.
     *
     * @deprecated Use `!mustBeInToplevelMenu()` instead.
     */
    canBeInOverflowMenu() {
      return !this.mustBeInToplevelMenu();
    }
    getButtonWidth() {
      return this.button.clientWidth;
    }
    isHidden() {
      return this.container.style.display === "none";
    }
    setHidden(hidden) {
      this.container.style.display = hidden ? "none" : "";
    }
    /** Set whether the widget is contained within another. @internal */
    setIsToplevel(toplevel) {
      this.toplevel = toplevel;
    }
    /** Returns true if the menu for this widget is open. */
    isDropdownVisible() {
      return this.dropdown?.visible?.get() ?? false;
    }
    isSelected() {
      return this.container.classList.contains("selected");
    }
    createDropdownIcon() {
      const icon2 = this.editor.icons.makeDropdownIcon();
      icon2.classList.add(`${toolbarCSSPrefix}showHideDropdownIcon`);
      return icon2;
    }
    /**
     * Serialize state associated with this widget.
     * Override this method to allow saving/restoring from state on application load.
     *
     * Overriders should call `super` and include the output of `super.serializeState` in
     * the output dictionary.
     *
     * Clients should not rely on the output from `saveState` being in any particular
     * format.
     */
    serializeState() {
      const subwidgetState = {};
      for (const subwidgetId in this.subWidgets) {
        subwidgetState[subwidgetId] = this.subWidgets[subwidgetId].serializeState();
      }
      return {
        subwidgetState
      };
    }
    /**
     * Restore widget state from serialized data. See also `saveState`.
     *
     * Overriders must call `super`.
     */
    deserializeFrom(state) {
      if (state.subwidgetState) {
        assertIsObject(state.subwidgetState);
        for (const subwidgetId in state.subwidgetState) {
          if (subwidgetId in this.subWidgets) {
            const serializedSubwidgetState = state.subwidgetState[subwidgetId];
            if (serializedSubwidgetState) {
              this.subWidgets[subwidgetId].deserializeFrom(serializedSubwidgetState);
            }
          }
        }
      }
    }
  };
  _a5 = BaseWidget, _BaseWidget_hasDropdown = /* @__PURE__ */ new WeakMap(), _BaseWidget_disabledDueToReadOnlyEditor = /* @__PURE__ */ new WeakMap(), _BaseWidget_tags = /* @__PURE__ */ new WeakMap(), _BaseWidget_removeEditorListeners = /* @__PURE__ */ new WeakMap(), _BaseWidget_instances = /* @__PURE__ */ new WeakSet(), _BaseWidget_addEditorListeners = function _BaseWidget_addEditorListeners2() {
    __classPrivateFieldGet12(this, _BaseWidget_removeEditorListeners, "f")?.call(this);
    const toolbarShortcutHandlers = this.editor.toolController.getMatchingTools(ToolbarShortcutHandler);
    let removeKeyPressListener = null;
    if (toolbarShortcutHandlers.length > 0 && this.onKeyPress !== _a5.prototype.onKeyPress) {
      const keyPressListener = (event) => this.onKeyPress(event);
      const handler = toolbarShortcutHandlers[0];
      handler.registerListener(keyPressListener);
      removeKeyPressListener = () => {
        handler.removeListener(keyPressListener);
      };
    }
    const readOnlyListener = this.editor.isReadOnlyReactiveValue().onUpdateAndNow((readOnly) => {
      if (readOnly && this.shouldAutoDisableInReadOnlyEditor() && !this.disabled) {
        this.setDisabled(true);
        __classPrivateFieldSet10(this, _BaseWidget_disabledDueToReadOnlyEditor, true, "f");
        if (__classPrivateFieldGet12(this, _BaseWidget_hasDropdown, "f")) {
          this.dropdown?.requestHide();
        }
      } else if (!readOnly && __classPrivateFieldGet12(this, _BaseWidget_disabledDueToReadOnlyEditor, "f")) {
        __classPrivateFieldSet10(this, _BaseWidget_disabledDueToReadOnlyEditor, false, "f");
        this.setDisabled(false);
      }
    });
    __classPrivateFieldSet10(this, _BaseWidget_removeEditorListeners, () => {
      readOnlyListener.remove();
      removeKeyPressListener?.();
      __classPrivateFieldSet10(this, _BaseWidget_removeEditorListeners, null, "f");
    }, "f");
  };
  var BaseWidget_default = BaseWidget;

  // node_modules/js-draw/dist/mjs/toolbar/widgets/layout/EdgeToolbarLayoutManager.mjs
  var EdgeToolbarLayoutManager = class {
    // @internal
    constructor(setSidebarContent, sidebarTitle, sidebarVisibility, announceForAccessibility, localization7) {
      this.setSidebarContent = setSidebarContent;
      this.sidebarTitle = sidebarTitle;
      this.sidebarVisibility = sidebarVisibility;
      this.announceForAccessibility = announceForAccessibility;
      this.localization = localization7;
      this.visibleWidgetContent = ReactiveValue.fromInitialValue(null);
    }
    /** Creates a dropdown within `parent`. */
    createToolMenu(parent) {
      const contentElem = document.createElement("div");
      let result = null;
      const visible = ReactiveValue.fromCallback(() => {
        return this.visibleWidgetContent.get() === result && this.sidebarVisibility.get();
      }, [this.visibleWidgetContent, this.sidebarVisibility]);
      result = {
        visible,
        requestShow: () => {
          this.setSidebarContent(contentElem);
          this.sidebarTitle.set(parent.getTitle());
          this.visibleWidgetContent.set(result);
          this.sidebarVisibility.set(true);
          this.announceForAccessibility(this.localization.dropdownShown(parent.getTitle()));
        },
        onActivated: () => {
        },
        requestHide: () => {
          if (visible.get()) {
            this.sidebarVisibility.set(false);
          }
        },
        appendChild: (item) => {
          contentElem.appendChild(item);
        },
        clearChildren: () => {
          contentElem.replaceChildren();
        },
        destroy: () => {
          result?.requestHide();
          if (contentElem.parentElement) {
            contentElem.remove();
          }
          if (this.visibleWidgetContent.get() === result) {
            this.visibleWidgetContent.set(null);
          }
        }
      };
      return result;
    }
  };

  // node_modules/@melloware/coloris/dist/esm/coloris.js
  var Coloris = (() => {
    return ((window2, document2, Math2, undefined2) => {
      const ctx = document2.createElement("canvas").getContext("2d");
      const currentColor = { r: 0, g: 0, b: 0, h: 0, s: 0, v: 0, a: 1 };
      let container, picker, colorArea, colorMarker, colorPreview, colorValue, clearButton, closeButton, hueSlider, hueMarker, alphaSlider, alphaMarker, currentEl, currentFormat, oldColor, keyboardNav, colorAreaDims = {};
      const settings = {
        el: "[data-coloris]",
        parent: "body",
        theme: "default",
        themeMode: "light",
        rtl: false,
        wrap: true,
        margin: 2,
        format: "hex",
        formatToggle: false,
        swatches: [],
        swatchesOnly: false,
        alpha: true,
        forceAlpha: false,
        focusInput: true,
        selectInput: false,
        inline: false,
        defaultColor: "#000000",
        clearButton: false,
        clearLabel: "Clear",
        closeButton: false,
        closeLabel: "Close",
        onChange: () => undefined2,
        a11y: {
          open: "Open color picker",
          close: "Close color picker",
          clear: "Clear the selected color",
          marker: "Saturation: {s}. Brightness: {v}.",
          hueSlider: "Hue slider",
          alphaSlider: "Opacity slider",
          input: "Color value field",
          format: "Color format",
          swatch: "Color swatch",
          instruction: "Saturation and brightness selector. Use up, down, left and right arrow keys to select."
        }
      };
      const instances = {};
      let currentInstanceId = "";
      let defaultInstance = {};
      let hasInstance = false;
      function configure(options) {
        if (typeof options !== "object") {
          return;
        }
        for (const key in options) {
          switch (key) {
            case "el":
              bindFields(options.el);
              if (options.wrap !== false) {
                wrapFields(options.el);
              }
              break;
            case "parent":
              container = document2.querySelector(options.parent);
              if (container) {
                container.appendChild(picker);
                settings.parent = options.parent;
                if (container === document2.body) {
                  container = undefined2;
                }
              }
              break;
            case "themeMode":
              settings.themeMode = options.themeMode;
              if (options.themeMode === "auto" && window2.matchMedia && window2.matchMedia("(prefers-color-scheme: dark)").matches) {
                settings.themeMode = "dark";
              }
            // The lack of a break statement is intentional
            case "theme":
              if (options.theme) {
                settings.theme = options.theme;
              }
              picker.className = `clr-picker clr-${settings.theme} clr-${settings.themeMode}`;
              if (settings.inline) {
                updatePickerPosition();
              }
              break;
            case "rtl":
              settings.rtl = !!options.rtl;
              document2.querySelectorAll(".clr-field").forEach((field) => field.classList.toggle("clr-rtl", settings.rtl));
              break;
            case "margin":
              options.margin *= 1;
              settings.margin = !isNaN(options.margin) ? options.margin : settings.margin;
              break;
            case "wrap":
              if (options.el && options.wrap) {
                wrapFields(options.el);
              }
              break;
            case "formatToggle":
              settings.formatToggle = !!options.formatToggle;
              getEl("clr-format").style.display = settings.formatToggle ? "block" : "none";
              if (settings.formatToggle) {
                settings.format = "auto";
              }
              break;
            case "swatches":
              if (Array.isArray(options.swatches)) {
                const swatches = [];
                options.swatches.forEach((swatch, i) => {
                  swatches.push(`<button type="button" id="clr-swatch-${i}" aria-labelledby="clr-swatch-label clr-swatch-${i}" style="color: ${swatch};">${swatch}</button>`);
                });
                getEl("clr-swatches").innerHTML = swatches.length ? `<div>${swatches.join("")}</div>` : "";
                settings.swatches = options.swatches.slice();
              }
              break;
            case "swatchesOnly":
              settings.swatchesOnly = !!options.swatchesOnly;
              picker.setAttribute("data-minimal", settings.swatchesOnly);
              break;
            case "alpha":
              settings.alpha = !!options.alpha;
              picker.setAttribute("data-alpha", settings.alpha);
              break;
            case "inline":
              settings.inline = !!options.inline;
              picker.setAttribute("data-inline", settings.inline);
              if (settings.inline) {
                const defaultColor = options.defaultColor || settings.defaultColor;
                currentFormat = getColorFormatFromStr(defaultColor);
                updatePickerPosition();
                setColorFromStr(defaultColor);
              }
              break;
            case "clearButton":
              if (typeof options.clearButton === "object") {
                if (options.clearButton.label) {
                  settings.clearLabel = options.clearButton.label;
                  clearButton.innerHTML = settings.clearLabel;
                }
                options.clearButton = options.clearButton.show;
              }
              settings.clearButton = !!options.clearButton;
              clearButton.style.display = settings.clearButton ? "block" : "none";
              break;
            case "clearLabel":
              settings.clearLabel = options.clearLabel;
              clearButton.innerHTML = settings.clearLabel;
              break;
            case "closeButton":
              settings.closeButton = !!options.closeButton;
              if (settings.closeButton) {
                picker.insertBefore(closeButton, colorPreview);
              } else {
                colorPreview.appendChild(closeButton);
              }
              break;
            case "closeLabel":
              settings.closeLabel = options.closeLabel;
              closeButton.innerHTML = settings.closeLabel;
              break;
            case "a11y":
              const labels = options.a11y;
              let update = false;
              if (typeof labels === "object") {
                for (const label in labels) {
                  if (labels[label] && settings.a11y[label]) {
                    settings.a11y[label] = labels[label];
                    update = true;
                  }
                }
              }
              if (update) {
                const openLabel = getEl("clr-open-label");
                const swatchLabel = getEl("clr-swatch-label");
                openLabel.innerHTML = settings.a11y.open;
                swatchLabel.innerHTML = settings.a11y.swatch;
                closeButton.setAttribute("aria-label", settings.a11y.close);
                clearButton.setAttribute("aria-label", settings.a11y.clear);
                hueSlider.setAttribute("aria-label", settings.a11y.hueSlider);
                alphaSlider.setAttribute("aria-label", settings.a11y.alphaSlider);
                colorValue.setAttribute("aria-label", settings.a11y.input);
                colorArea.setAttribute("aria-label", settings.a11y.instruction);
              }
              break;
            default:
              settings[key] = options[key];
          }
        }
      }
      function setVirtualInstance(selector, options) {
        if (typeof selector === "string" && typeof options === "object") {
          instances[selector] = options;
          hasInstance = true;
        }
      }
      function removeVirtualInstance(selector) {
        delete instances[selector];
        if (Object.keys(instances).length === 0) {
          hasInstance = false;
          if (selector === currentInstanceId) {
            resetVirtualInstance();
          }
        }
      }
      function attachVirtualInstance(element) {
        if (hasInstance) {
          const unsupportedOptions = ["el", "wrap", "rtl", "inline", "defaultColor", "a11y"];
          for (let selector in instances) {
            const options = instances[selector];
            if (element.matches(selector)) {
              currentInstanceId = selector;
              defaultInstance = {};
              unsupportedOptions.forEach((option) => delete options[option]);
              for (let option in options) {
                defaultInstance[option] = Array.isArray(settings[option]) ? settings[option].slice() : settings[option];
              }
              configure(options);
              break;
            }
          }
        }
      }
      function resetVirtualInstance() {
        if (Object.keys(defaultInstance).length > 0) {
          configure(defaultInstance);
          currentInstanceId = "";
          defaultInstance = {};
        }
      }
      function bindFields(selector) {
        addListener(document2, "click", selector, (event) => {
          if (settings.inline) {
            return;
          }
          attachVirtualInstance(event.target);
          currentEl = event.target;
          oldColor = currentEl.value;
          currentFormat = getColorFormatFromStr(oldColor);
          picker.classList.add("clr-open");
          updatePickerPosition();
          setColorFromStr(oldColor);
          if (settings.focusInput || settings.selectInput) {
            colorValue.focus({ preventScroll: true });
            colorValue.setSelectionRange(currentEl.selectionStart, currentEl.selectionEnd);
          }
          if (settings.selectInput) {
            colorValue.select();
          }
          if (keyboardNav || settings.swatchesOnly) {
            getFocusableElements().shift().focus();
          }
          currentEl.dispatchEvent(new Event("open", { bubbles: true }));
        });
        addListener(document2, "input", selector, (event) => {
          const parent = event.target.parentNode;
          if (parent.classList.contains("clr-field")) {
            parent.style.color = event.target.value;
          }
        });
      }
      function updatePickerPosition() {
        if (!picker || !currentEl && !settings.inline) return;
        const parent = container;
        const scrollY = window2.scrollY;
        const pickerWidth = picker.offsetWidth;
        const pickerHeight = picker.offsetHeight;
        const reposition = { left: false, top: false };
        let parentStyle, parentMarginTop, parentBorderTop;
        let offset = { x: 0, y: 0 };
        if (parent) {
          parentStyle = window2.getComputedStyle(parent);
          parentMarginTop = parseFloat(parentStyle.marginTop);
          parentBorderTop = parseFloat(parentStyle.borderTopWidth);
          offset = parent.getBoundingClientRect();
          offset.y += parentBorderTop + scrollY;
        }
        if (!settings.inline) {
          const coords = currentEl.getBoundingClientRect();
          let left = coords.x;
          let top = scrollY + coords.y + coords.height + settings.margin;
          if (parent) {
            left -= offset.x;
            top -= offset.y;
            if (left + pickerWidth > parent.clientWidth) {
              left += coords.width - pickerWidth;
              reposition.left = true;
            }
            if (top + pickerHeight > parent.clientHeight - parentMarginTop) {
              if (pickerHeight + settings.margin <= coords.top - (offset.y - scrollY)) {
                top -= coords.height + pickerHeight + settings.margin * 2;
                reposition.top = true;
              }
            }
            top += parent.scrollTop;
          } else {
            if (left + pickerWidth > document2.documentElement.clientWidth) {
              left += coords.width - pickerWidth;
              reposition.left = true;
            }
            if (top + pickerHeight - scrollY > document2.documentElement.clientHeight) {
              if (pickerHeight + settings.margin <= coords.top) {
                top = scrollY + coords.y - pickerHeight - settings.margin;
                reposition.top = true;
              }
            }
          }
          picker.classList.toggle("clr-left", reposition.left);
          picker.classList.toggle("clr-top", reposition.top);
          picker.style.left = `${left}px`;
          picker.style.top = `${top}px`;
          offset.x += picker.offsetLeft;
          offset.y += picker.offsetTop;
        }
        colorAreaDims = {
          width: colorArea.offsetWidth,
          height: colorArea.offsetHeight,
          x: colorArea.offsetLeft + offset.x,
          y: colorArea.offsetTop + offset.y
        };
      }
      function wrapFields(selector) {
        document2.querySelectorAll(selector).forEach((field) => {
          const parentNode = field.parentNode;
          if (!parentNode.classList.contains("clr-field")) {
            const wrapper = document2.createElement("div");
            let classes = "clr-field";
            if (settings.rtl || field.classList.contains("clr-rtl")) {
              classes += " clr-rtl";
            }
            wrapper.innerHTML = `<button type="button" aria-labelledby="clr-open-label"></button>`;
            parentNode.insertBefore(wrapper, field);
            wrapper.setAttribute("class", classes);
            wrapper.style.color = field.value;
            wrapper.appendChild(field);
          }
        });
      }
      function closePicker(revert) {
        if (currentEl && !settings.inline) {
          const prevEl = currentEl;
          if (revert) {
            currentEl = undefined2;
            if (oldColor !== prevEl.value) {
              prevEl.value = oldColor;
              prevEl.dispatchEvent(new Event("input", { bubbles: true }));
            }
          }
          setTimeout(() => {
            if (oldColor !== prevEl.value) {
              prevEl.dispatchEvent(new Event("change", { bubbles: true }));
            }
          });
          picker.classList.remove("clr-open");
          if (hasInstance) {
            resetVirtualInstance();
          }
          prevEl.dispatchEvent(new Event("close", { bubbles: true }));
          if (settings.focusInput) {
            prevEl.focus({ preventScroll: true });
          }
          currentEl = undefined2;
        }
      }
      function setColorFromStr(str) {
        const rgba = strToRGBA(str);
        const hsva = RGBAtoHSVA(rgba);
        updateMarkerA11yLabel(hsva.s, hsva.v);
        updateColor(rgba, hsva);
        hueSlider.value = hsva.h;
        picker.style.color = `hsl(${hsva.h}, 100%, 50%)`;
        hueMarker.style.left = `${hsva.h / 360 * 100}%`;
        colorMarker.style.left = `${colorAreaDims.width * hsva.s / 100}px`;
        colorMarker.style.top = `${colorAreaDims.height - colorAreaDims.height * hsva.v / 100}px`;
        alphaSlider.value = hsva.a * 100;
        alphaMarker.style.left = `${hsva.a * 100}%`;
      }
      function getColorFormatFromStr(str) {
        const format = str.substring(0, 3).toLowerCase();
        if (format === "rgb" || format === "hsl") {
          return format;
        }
        return "hex";
      }
      function pickColor(color) {
        color = color !== undefined2 ? color : colorValue.value;
        if (currentEl) {
          currentEl.value = color;
          currentEl.dispatchEvent(new Event("input", { bubbles: true }));
        }
        if (settings.onChange) {
          settings.onChange.call(window2, color, currentEl);
        }
        document2.dispatchEvent(new CustomEvent("coloris:pick", { detail: { color, currentEl } }));
      }
      function setColorAtPosition(x, y) {
        const hsva = {
          h: hueSlider.value * 1,
          s: x / colorAreaDims.width * 100,
          v: 100 - y / colorAreaDims.height * 100,
          a: alphaSlider.value / 100
        };
        const rgba = HSVAtoRGBA(hsva);
        updateMarkerA11yLabel(hsva.s, hsva.v);
        updateColor(rgba, hsva);
        pickColor();
      }
      function updateMarkerA11yLabel(saturation, value) {
        let label = settings.a11y.marker;
        saturation = saturation.toFixed(1) * 1;
        value = value.toFixed(1) * 1;
        label = label.replace("{s}", saturation);
        label = label.replace("{v}", value);
        colorMarker.setAttribute("aria-label", label);
      }
      function getPointerPosition(event) {
        return {
          pageX: event.changedTouches ? event.changedTouches[0].pageX : event.pageX,
          pageY: event.changedTouches ? event.changedTouches[0].pageY : event.pageY
        };
      }
      function moveMarker(event) {
        const pointer = getPointerPosition(event);
        let x = pointer.pageX - colorAreaDims.x;
        let y = pointer.pageY - colorAreaDims.y;
        if (container) {
          y += container.scrollTop;
        }
        setMarkerPosition(x, y);
        event.preventDefault();
        event.stopPropagation();
      }
      function moveMarkerOnKeydown(offsetX, offsetY) {
        let x = colorMarker.style.left.replace("px", "") * 1 + offsetX;
        let y = colorMarker.style.top.replace("px", "") * 1 + offsetY;
        setMarkerPosition(x, y);
      }
      function setMarkerPosition(x, y) {
        x = x < 0 ? 0 : x > colorAreaDims.width ? colorAreaDims.width : x;
        y = y < 0 ? 0 : y > colorAreaDims.height ? colorAreaDims.height : y;
        colorMarker.style.left = `${x}px`;
        colorMarker.style.top = `${y}px`;
        setColorAtPosition(x, y);
        colorMarker.focus();
      }
      function updateColor(rgba, hsva) {
        if (rgba === void 0) {
          rgba = {};
        }
        if (hsva === void 0) {
          hsva = {};
        }
        let format = settings.format;
        for (const key in rgba) {
          currentColor[key] = rgba[key];
        }
        for (const key in hsva) {
          currentColor[key] = hsva[key];
        }
        const hex = RGBAToHex(currentColor);
        const opaqueHex = hex.substring(0, 7);
        colorMarker.style.color = opaqueHex;
        alphaMarker.parentNode.style.color = opaqueHex;
        alphaMarker.style.color = hex;
        colorPreview.style.color = hex;
        colorArea.style.display = "none";
        colorArea.offsetHeight;
        colorArea.style.display = "";
        alphaMarker.nextElementSibling.style.display = "none";
        alphaMarker.nextElementSibling.offsetHeight;
        alphaMarker.nextElementSibling.style.display = "";
        if (format === "mixed") {
          format = currentColor.a === 1 ? "hex" : "rgb";
        } else if (format === "auto") {
          format = currentFormat;
        }
        switch (format) {
          case "hex":
            colorValue.value = hex;
            break;
          case "rgb":
            colorValue.value = RGBAToStr(currentColor);
            break;
          case "hsl":
            colorValue.value = HSLAToStr(HSVAtoHSLA(currentColor));
            break;
        }
        document2.querySelector(`.clr-format [value="${format}"]`).checked = true;
      }
      function setHue() {
        const hue = hueSlider.value * 1;
        const x = colorMarker.style.left.replace("px", "") * 1;
        const y = colorMarker.style.top.replace("px", "") * 1;
        picker.style.color = `hsl(${hue}, 100%, 50%)`;
        hueMarker.style.left = `${hue / 360 * 100}%`;
        setColorAtPosition(x, y);
      }
      function setAlpha() {
        const alpha = alphaSlider.value / 100;
        alphaMarker.style.left = `${alpha * 100}%`;
        updateColor({ a: alpha });
        pickColor();
      }
      function HSVAtoRGBA(hsva) {
        const saturation = hsva.s / 100;
        const value = hsva.v / 100;
        let chroma = saturation * value;
        let hueBy60 = hsva.h / 60;
        let x = chroma * (1 - Math2.abs(hueBy60 % 2 - 1));
        let m = value - chroma;
        chroma = chroma + m;
        x = x + m;
        const index = Math2.floor(hueBy60) % 6;
        const red = [chroma, x, m, m, x, chroma][index];
        const green = [x, chroma, chroma, x, m, m][index];
        const blue = [m, m, x, chroma, chroma, x][index];
        return {
          r: Math2.round(red * 255),
          g: Math2.round(green * 255),
          b: Math2.round(blue * 255),
          a: hsva.a
        };
      }
      function HSVAtoHSLA(hsva) {
        const value = hsva.v / 100;
        const lightness = value * (1 - hsva.s / 100 / 2);
        let saturation;
        if (lightness > 0 && lightness < 1) {
          saturation = Math2.round((value - lightness) / Math2.min(lightness, 1 - lightness) * 100);
        }
        return {
          h: hsva.h,
          s: saturation || 0,
          l: Math2.round(lightness * 100),
          a: hsva.a
        };
      }
      function RGBAtoHSVA(rgba) {
        const red = rgba.r / 255;
        const green = rgba.g / 255;
        const blue = rgba.b / 255;
        const xmax = Math2.max(red, green, blue);
        const xmin = Math2.min(red, green, blue);
        const chroma = xmax - xmin;
        const value = xmax;
        let hue = 0;
        let saturation = 0;
        if (chroma) {
          if (xmax === red) {
            hue = (green - blue) / chroma;
          }
          if (xmax === green) {
            hue = 2 + (blue - red) / chroma;
          }
          if (xmax === blue) {
            hue = 4 + (red - green) / chroma;
          }
          if (xmax) {
            saturation = chroma / xmax;
          }
        }
        hue = Math2.floor(hue * 60);
        return {
          h: hue < 0 ? hue + 360 : hue,
          s: Math2.round(saturation * 100),
          v: Math2.round(value * 100),
          a: rgba.a
        };
      }
      function strToRGBA(str) {
        const regex = /^((rgba)|rgb)[\D]+([\d.]+)[\D]+([\d.]+)[\D]+([\d.]+)[\D]*?([\d.]+|$)/i;
        let match, rgba;
        ctx.fillStyle = "#000";
        ctx.fillStyle = str;
        match = regex.exec(ctx.fillStyle);
        if (match) {
          rgba = {
            r: match[3] * 1,
            g: match[4] * 1,
            b: match[5] * 1,
            a: match[6] * 1
          };
          rgba.a = +rgba.a.toFixed(2);
        } else {
          match = ctx.fillStyle.replace("#", "").match(/.{2}/g).map((h) => parseInt(h, 16));
          rgba = {
            r: match[0],
            g: match[1],
            b: match[2],
            a: 1
          };
        }
        return rgba;
      }
      function RGBAToHex(rgba) {
        let R = rgba.r.toString(16);
        let G = rgba.g.toString(16);
        let B = rgba.b.toString(16);
        let A = "";
        if (rgba.r < 16) {
          R = "0" + R;
        }
        if (rgba.g < 16) {
          G = "0" + G;
        }
        if (rgba.b < 16) {
          B = "0" + B;
        }
        if (settings.alpha && (rgba.a < 1 || settings.forceAlpha)) {
          const alpha = rgba.a * 255 | 0;
          A = alpha.toString(16);
          if (alpha < 16) {
            A = "0" + A;
          }
        }
        return "#" + R + G + B + A;
      }
      function RGBAToStr(rgba) {
        if (!settings.alpha || rgba.a === 1 && !settings.forceAlpha) {
          return `rgb(${rgba.r}, ${rgba.g}, ${rgba.b})`;
        } else {
          return `rgba(${rgba.r}, ${rgba.g}, ${rgba.b}, ${rgba.a})`;
        }
      }
      function HSLAToStr(hsla) {
        if (!settings.alpha || hsla.a === 1 && !settings.forceAlpha) {
          return `hsl(${hsla.h}, ${hsla.s}%, ${hsla.l}%)`;
        } else {
          return `hsla(${hsla.h}, ${hsla.s}%, ${hsla.l}%, ${hsla.a})`;
        }
      }
      function init() {
        if (document2.getElementById("clr-picker")) return;
        container = undefined2;
        picker = document2.createElement("div");
        picker.setAttribute("id", "clr-picker");
        picker.className = "clr-picker";
        picker.innerHTML = `<input id="clr-color-value" name="clr-color-value" class="clr-color" type="text" value="" spellcheck="false" aria-label="${settings.a11y.input}"><div id="clr-color-area" class="clr-gradient" role="application" aria-label="${settings.a11y.instruction}"><div id="clr-color-marker" class="clr-marker" tabindex="0"></div></div><div class="clr-hue"><input id="clr-hue-slider" name="clr-hue-slider" type="range" min="0" max="360" step="1" aria-label="${settings.a11y.hueSlider}"><div id="clr-hue-marker"></div></div><div class="clr-alpha"><input id="clr-alpha-slider" name="clr-alpha-slider" type="range" min="0" max="100" step="1" aria-label="${settings.a11y.alphaSlider}"><div id="clr-alpha-marker"></div><span></span></div><div id="clr-format" class="clr-format"><fieldset class="clr-segmented"><legend>${settings.a11y.format}</legend><input id="clr-f1" type="radio" name="clr-format" value="hex"><label for="clr-f1">Hex</label><input id="clr-f2" type="radio" name="clr-format" value="rgb"><label for="clr-f2">RGB</label><input id="clr-f3" type="radio" name="clr-format" value="hsl"><label for="clr-f3">HSL</label><span></span></fieldset></div><div id="clr-swatches" class="clr-swatches"></div><button type="button" id="clr-clear" class="clr-clear" aria-label="${settings.a11y.clear}">${settings.clearLabel}</button><div id="clr-color-preview" class="clr-preview"><button type="button" id="clr-close" class="clr-close" aria-label="${settings.a11y.close}">${settings.closeLabel}</button></div><span id="clr-open-label" hidden>${settings.a11y.open}</span><span id="clr-swatch-label" hidden>${settings.a11y.swatch}</span>`;
        document2.body.appendChild(picker);
        colorArea = getEl("clr-color-area");
        colorMarker = getEl("clr-color-marker");
        clearButton = getEl("clr-clear");
        closeButton = getEl("clr-close");
        colorPreview = getEl("clr-color-preview");
        colorValue = getEl("clr-color-value");
        hueSlider = getEl("clr-hue-slider");
        hueMarker = getEl("clr-hue-marker");
        alphaSlider = getEl("clr-alpha-slider");
        alphaMarker = getEl("clr-alpha-marker");
        bindFields(settings.el);
        wrapFields(settings.el);
        addListener(picker, "mousedown", (event) => {
          picker.classList.remove("clr-keyboard-nav");
          event.stopPropagation();
        });
        addListener(colorArea, "mousedown", (event) => {
          addListener(document2, "mousemove", moveMarker);
        });
        addListener(colorArea, "touchstart", (event) => {
          document2.addEventListener("touchmove", moveMarker, { passive: false });
        });
        addListener(colorMarker, "mousedown", (event) => {
          addListener(document2, "mousemove", moveMarker);
        });
        addListener(colorMarker, "touchstart", (event) => {
          document2.addEventListener("touchmove", moveMarker, { passive: false });
        });
        addListener(colorValue, "change", (event) => {
          const value = colorValue.value;
          if (currentEl || settings.inline) {
            const color = value === "" ? value : setColorFromStr(value);
            pickColor(color);
          }
        });
        addListener(clearButton, "click", (event) => {
          pickColor("");
          closePicker();
        });
        addListener(closeButton, "click", (event) => {
          pickColor();
          closePicker();
        });
        addListener(getEl("clr-format"), "click", ".clr-format input", (event) => {
          currentFormat = event.target.value;
          updateColor();
          pickColor();
        });
        addListener(picker, "click", ".clr-swatches button", (event) => {
          setColorFromStr(event.target.textContent);
          pickColor();
          if (settings.swatchesOnly) {
            closePicker();
          }
        });
        addListener(document2, "mouseup", (event) => {
          document2.removeEventListener("mousemove", moveMarker);
        });
        addListener(document2, "touchend", (event) => {
          document2.removeEventListener("touchmove", moveMarker);
        });
        addListener(document2, "mousedown", (event) => {
          keyboardNav = false;
          picker.classList.remove("clr-keyboard-nav");
          closePicker();
        });
        addListener(document2, "keydown", (event) => {
          const key = event.key;
          const target = event.target;
          const shiftKey = event.shiftKey;
          const navKeys = ["Tab", "ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"];
          if (key === "Escape") {
            closePicker(true);
          } else if (navKeys.includes(key)) {
            keyboardNav = true;
            picker.classList.add("clr-keyboard-nav");
          }
          if (key === "Tab" && target.matches(".clr-picker *")) {
            const focusables = getFocusableElements();
            const firstFocusable = focusables.shift();
            const lastFocusable = focusables.pop();
            if (shiftKey && target === firstFocusable) {
              lastFocusable.focus();
              event.preventDefault();
            } else if (!shiftKey && target === lastFocusable) {
              firstFocusable.focus();
              event.preventDefault();
            }
          }
        });
        addListener(document2, "click", ".clr-field button", (event) => {
          if (hasInstance) {
            resetVirtualInstance();
          }
          event.target.nextElementSibling.dispatchEvent(new Event("click", { bubbles: true }));
        });
        addListener(colorMarker, "keydown", (event) => {
          const movements = {
            ArrowUp: [0, -1],
            ArrowDown: [0, 1],
            ArrowLeft: [-1, 0],
            ArrowRight: [1, 0]
          };
          if (Object.keys(movements).includes(event.key)) {
            moveMarkerOnKeydown(...movements[event.key]);
            event.preventDefault();
          }
        });
        addListener(colorArea, "click", moveMarker);
        addListener(hueSlider, "input", setHue);
        addListener(alphaSlider, "input", setAlpha);
      }
      function getFocusableElements() {
        const controls = Array.from(picker.querySelectorAll("input, button"));
        const focusables = controls.filter((node) => !!node.offsetWidth);
        return focusables;
      }
      function getEl(id) {
        return document2.getElementById(id);
      }
      function addListener(context, type, selector, fn) {
        const matches = Element.prototype.matches || Element.prototype.msMatchesSelector;
        if (typeof selector === "string") {
          context.addEventListener(type, (event) => {
            if (matches.call(event.target, selector)) {
              fn.call(event.target, event);
            }
          });
        } else {
          fn = selector;
          context.addEventListener(type, fn);
        }
      }
      function DOMReady(fn, args) {
        args = args !== undefined2 ? args : [];
        if (document2.readyState !== "loading") {
          fn(...args);
        } else {
          document2.addEventListener("DOMContentLoaded", () => {
            fn(...args);
          });
        }
      }
      if (NodeList !== undefined2 && NodeList.prototype && !NodeList.prototype.forEach) {
        NodeList.prototype.forEach = Array.prototype.forEach;
      }
      function setColor(color, target) {
        currentEl = target;
        oldColor = currentEl.value;
        attachVirtualInstance(target);
        currentFormat = getColorFormatFromStr(color);
        updatePickerPosition();
        setColorFromStr(color);
        pickColor();
        if (oldColor !== color) {
          currentEl.dispatchEvent(new Event("change", { bubbles: true }));
        }
      }
      const Coloris2 = (() => {
        const methods = {
          init,
          set: configure,
          wrap: wrapFields,
          close: closePicker,
          setInstance: setVirtualInstance,
          setColor,
          removeInstance: removeVirtualInstance,
          updatePosition: updatePickerPosition,
          ready: DOMReady
        };
        function Coloris3(options) {
          DOMReady(() => {
            if (options) {
              if (typeof options === "string") {
                bindFields(options);
              } else {
                configure(options);
              }
            }
          });
        }
        for (const key in methods) {
          Coloris3[key] = function() {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            DOMReady(methods[key], args);
          };
        }
        DOMReady(() => {
          window2.addEventListener("resize", (event) => {
            Coloris3.updatePosition();
          });
          window2.addEventListener("scroll", (event) => {
            Coloris3.updatePosition();
          });
        });
        return Coloris3;
      })();
      Coloris2.coloris = Coloris2;
      return Coloris2;
    })(window, document, Math);
  })();
  var _coloris = Coloris.coloris;
  var _init = Coloris.init;
  var _set = Coloris.set;
  var _wrap = Coloris.wrap;
  var _close = Coloris.close;
  var _setInstance = Coloris.setInstance;
  var _removeInstance = Coloris.removeInstance;
  var _updatePosition = Coloris.updatePosition;

  // node_modules/js-draw/dist/mjs/components/builders/autocorrect/makeSnapToGridAutocorrect.mjs
  var makeSnapToGridAutocorrect = (sourceFactory) => {
    return (startPoint, viewport) => {
      return new SnapToGridAutocompleteBuilder(sourceFactory, startPoint, viewport);
    };
  };
  var makeSnapToGridAutocorrect_default = makeSnapToGridAutocorrect;
  var SnapToGridAutocompleteBuilder = class {
    constructor(sourceFactory, startPoint, viewport) {
      this.sourceFactory = sourceFactory;
      this.startPoint = startPoint;
      this.viewport = viewport;
      this.builder = sourceFactory(startPoint, viewport);
      this.points = [startPoint];
      if (this.builder.inkTrailStyle) {
        this.inkTrailStyle = this.builder.inkTrailStyle.bind(this.builder);
      }
    }
    getBBox() {
      return this.builder.getBBox();
    }
    build() {
      return this.builder.build();
    }
    preview(renderer) {
      this.builder.preview(renderer);
    }
    addPoint(point) {
      this.points.push(point);
      this.builder.addPoint(point);
    }
    async autocorrectShape() {
      const snapToGrid = (point) => {
        return {
          ...point,
          pos: this.viewport.snapToGrid(point.pos)
        };
      };
      const startPoint = snapToGrid(this.startPoint);
      const builder = this.sourceFactory(startPoint, this.viewport);
      const points = this.points.map((point) => snapToGrid(point));
      for (const point of points) {
        builder.addPoint(point);
      }
      return builder.build();
    }
  };

  // node_modules/js-draw/dist/mjs/components/builders/ArrowBuilder.mjs
  var makeArrowBuilder = makeSnapToGridAutocorrect_default((initialPoint, viewport) => {
    return new ArrowBuilder(initialPoint, viewport);
  });
  var ArrowBuilder = class {
    constructor(startPoint, viewport) {
      this.startPoint = startPoint;
      this.viewport = viewport;
      this.endPoint = startPoint;
    }
    getLineWidth() {
      return Math.max(this.endPoint.width, this.startPoint.width);
    }
    getBBox() {
      const preview = this.buildPreview();
      return preview.getBBox();
    }
    buildPreview() {
      const lineStartPoint = this.startPoint.pos;
      const endPoint = this.endPoint.pos;
      const toEnd = endPoint.minus(lineStartPoint).normalized();
      const arrowLength = endPoint.distanceTo(lineStartPoint);
      const arrowTipSize = Math.min(this.getLineWidth(), arrowLength / 2);
      const startSize = this.startPoint.width / 2;
      const endSize = this.endPoint.width / 2;
      const arrowTipBase = endPoint.minus(toEnd.times(arrowTipSize));
      const lineNormal = toEnd.orthog();
      const scaledStartNormal = lineNormal.times(startSize);
      const scaledBaseNormal = lineNormal.times(endSize);
      const path = new Path(arrowTipBase.minus(scaledBaseNormal), [
        // Stem
        {
          kind: PathCommandType.LineTo,
          point: lineStartPoint.minus(scaledStartNormal)
        },
        {
          kind: PathCommandType.LineTo,
          point: lineStartPoint.plus(scaledStartNormal)
        },
        {
          kind: PathCommandType.LineTo,
          point: arrowTipBase.plus(scaledBaseNormal)
        },
        // Head
        {
          kind: PathCommandType.LineTo,
          point: arrowTipBase.plus(lineNormal.times(arrowTipSize).plus(scaledBaseNormal))
        },
        {
          kind: PathCommandType.LineTo,
          point: endPoint.plus(toEnd.times(endSize))
        },
        {
          kind: PathCommandType.LineTo,
          point: arrowTipBase.plus(lineNormal.times(-arrowTipSize).minus(scaledBaseNormal))
        },
        {
          kind: PathCommandType.LineTo,
          point: arrowTipBase.minus(scaledBaseNormal)
        }
        // Round all points in the arrow (to remove unnecessary decimal places)
      ]).mapPoints((point) => this.viewport.roundPoint(point));
      const preview = new Stroke([
        {
          startPoint: path.startPoint,
          commands: path.parts,
          style: {
            fill: this.startPoint.color
          }
        }
      ]);
      return preview;
    }
    build() {
      return this.buildPreview();
    }
    preview(renderer) {
      this.buildPreview().render(renderer);
    }
    addPoint(point) {
      this.endPoint = point;
    }
  };

  // node_modules/js-draw/dist/mjs/components/builders/LineBuilder.mjs
  var makeLineBuilder = makeSnapToGridAutocorrect_default((initialPoint, viewport) => {
    return new LineBuilder(initialPoint, viewport);
  });
  var LineBuilder = class {
    constructor(startPoint, viewport) {
      this.startPoint = startPoint;
      this.viewport = viewport;
      this.endPoint = startPoint;
    }
    getBBox() {
      const preview = this.buildPreview();
      return preview.getBBox();
    }
    buildPreview() {
      const startPoint = this.startPoint.pos;
      const endPoint = this.endPoint.pos;
      const toEnd = endPoint.minus(startPoint).normalized();
      const startSize = this.startPoint.width / 2;
      const endSize = this.endPoint.width / 2;
      const lineNormal = toEnd.orthog();
      const scaledStartNormal = lineNormal.times(startSize);
      const scaledEndNormal = lineNormal.times(endSize);
      const strokeStartPoint = startPoint.minus(scaledStartNormal);
      const path = new Path(strokeStartPoint, [
        {
          kind: PathCommandType.LineTo,
          point: startPoint.plus(scaledStartNormal)
        },
        {
          kind: PathCommandType.LineTo,
          point: endPoint.plus(scaledEndNormal)
        },
        {
          kind: PathCommandType.LineTo,
          point: endPoint.minus(scaledEndNormal)
        },
        {
          kind: PathCommandType.LineTo,
          point: startPoint.minus(scaledStartNormal)
        }
      ]).mapPoints((point) => this.viewport.roundPoint(point));
      const preview = new Stroke([pathToRenderable(path, { fill: this.startPoint.color })]);
      return preview;
    }
    build() {
      return this.buildPreview();
    }
    preview(renderer) {
      this.buildPreview().render(renderer);
    }
    addPoint(point) {
      this.endPoint = point;
    }
  };

  // node_modules/js-draw/dist/mjs/components/builders/RectangleBuilder.mjs
  var makeFilledRectangleBuilder = makeSnapToGridAutocorrect_default((initialPoint, viewport) => {
    return new RectangleBuilder(initialPoint, true, viewport);
  });
  var makeOutlinedRectangleBuilder = makeSnapToGridAutocorrect_default((initialPoint, viewport) => {
    return new RectangleBuilder(initialPoint, false, viewport);
  });
  var RectangleBuilder = class {
    constructor(startPoint, filled, viewport) {
      this.startPoint = startPoint;
      this.filled = filled;
      this.viewport = viewport;
      this.endPoint = startPoint;
    }
    getBBox() {
      const preview = this.buildPreview();
      return preview.getBBox();
    }
    buildPreview() {
      const canvasAngle = this.viewport.getRotationAngle();
      const rotationMat = Mat33.zRotation(-canvasAngle);
      const startPoint = rotationMat.inverse().transformVec2(this.startPoint.pos);
      const endPoint = rotationMat.inverse().transformVec2(this.endPoint.pos);
      const rect = Rect2.fromCorners(startPoint, endPoint);
      const path = Path.fromRect(rect, this.filled ? null : this.endPoint.width).transformedBy(
        // Rotate the canvas rectangle so that its rotation matches the screen
        rotationMat
      ).mapPoints((point) => this.viewport.roundPoint(point));
      const preview = new Stroke([
        pathToRenderable(path, {
          fill: this.endPoint.color
        })
      ]);
      return preview;
    }
    build() {
      return this.buildPreview();
    }
    preview(renderer) {
      this.buildPreview().render(renderer);
    }
    addPoint(point) {
      this.endPoint = point;
    }
  };

  // node_modules/js-draw/dist/mjs/components/builders/CircleBuilder.mjs
  var makeOutlinedCircleBuilder = makeSnapToGridAutocorrect_default((initialPoint, viewport) => {
    return new CircleBuilder(initialPoint, viewport);
  });
  var CircleBuilder = class {
    constructor(startPoint, viewport) {
      this.startPoint = startPoint;
      this.viewport = viewport;
      this.endPoint = startPoint;
    }
    getBBox() {
      const preview = this.buildPreview();
      return preview.getBBox();
    }
    buildPreview() {
      const pathCommands = [];
      const numDivisions = 6;
      const stepSize = Math.PI * 2 / numDivisions;
      const strokeWidth = Viewport_default.roundPoint(this.endPoint.width, 5 / this.viewport.getScaleFactor());
      const center = this.startPoint.pos.lerp(this.endPoint.pos, 0.5);
      const startEndDelta = this.endPoint.pos.minus(center);
      const radius = startEndDelta.length() - strokeWidth / 2;
      const startPoint = center.plus(Vec2.of(radius, 0));
      for (let t2 = stepSize; t2 <= Math.PI * 2; t2 += stepSize) {
        const endPoint = Vec2.of(radius * Math.cos(t2), -radius * Math.sin(t2)).plus(center);
        const controlPointRadiusScale = 1.141;
        const controlPoint = Vec2.of(Math.cos(t2 - stepSize / 2), -Math.sin(t2 - stepSize / 2)).times(radius * controlPointRadiusScale).plus(center);
        pathCommands.push({
          kind: PathCommandType.QuadraticBezierTo,
          controlPoint,
          endPoint
        });
      }
      pathCommands.push({
        kind: PathCommandType.LineTo,
        point: startPoint
      });
      const path = new Path(startPoint, pathCommands).mapPoints((point) => this.viewport.roundPoint(point));
      const preview = new Stroke([
        pathToRenderable(path, {
          fill: Color4.transparent,
          stroke: {
            width: strokeWidth,
            color: this.endPoint.color
          }
        })
      ]);
      return preview;
    }
    build() {
      return this.buildPreview();
    }
    preview(renderer) {
      this.buildPreview().render(renderer);
    }
    addPoint(point) {
      this.endPoint = point;
    }
  };

  // node_modules/js-draw/dist/mjs/toolbar/widgets/components/makeColorInput.mjs
  var makeColorInput = (editor, onColorChange) => {
    const container = document.createElement("span");
    const inputWrapper = document.createElement("span");
    const colorInput = document.createElement("input");
    colorInput.type = "button";
    colorInput.classList.add("coloris_input");
    container.classList.add("color-input-container");
    inputWrapper.classList.add("color-input-wrapper");
    inputWrapper.appendChild(colorInput);
    container.appendChild(inputWrapper);
    const pipetteController = addPipetteTool(editor, container, (color) => {
      colorInput.value = color.toHexString();
      onInputEnd();
      const parentElem = colorInput.parentElement;
      if (parentElem && parentElem.classList.contains("clr-field")) {
        parentElem.style.color = colorInput.value;
      }
    });
    let currentColor;
    const handleColorInput = () => {
      currentColor = Color4.fromHex(colorInput.value);
    };
    const onInputEnd = () => {
      handleColorInput();
      if (currentColor) {
        editor.announceForAccessibility(editor.localization.colorChangedAnnouncement(currentColor.toHexString()));
        onColorChange(currentColor);
        editor.notifier.dispatch(EditorEventType.ColorPickerColorSelected, {
          kind: EditorEventType.ColorPickerColorSelected,
          color: currentColor
        });
      }
    };
    colorInput.oninput = handleColorInput;
    let isOpen = false;
    colorInput.addEventListener("open", () => {
      isOpen = true;
      editor.notifier.dispatch(EditorEventType.ColorPickerToggled, {
        kind: EditorEventType.ColorPickerToggled,
        open: true
      });
      pipetteController.cancel();
      container.classList.add("picker-open");
      const colorPickerElem = document.querySelector("#clr-picker #clr-hue-slider");
      colorPickerElem?.focus();
    });
    const onClose = () => {
      isOpen = false;
      editor.notifier.dispatch(EditorEventType.ColorPickerToggled, {
        kind: EditorEventType.ColorPickerToggled,
        open: false
      });
      onInputEnd();
      colorInput.focus();
      container.classList.remove("picker-open");
    };
    colorInput.addEventListener("close", () => {
      onClose();
    });
    const setColorInputValue = (color) => {
      if (typeof color === "object") {
        color = color.toHexString();
      }
      colorInput.value = color;
      colorInput.dispatchEvent(new Event("input", { bubbles: true }));
    };
    return {
      input: colorInput,
      container,
      setValue: setColorInputValue,
      closePicker: () => {
        if (isOpen) {
          onInputEnd();
        }
      },
      registerWithHelpTextDisplay: (helpDisplay) => {
        helpDisplay.registerTextHelpForElement(inputWrapper, editor.localization.colorPickerToggleHelpText);
        pipetteController.registerWithHelpTextDisplay(helpDisplay);
      }
    };
  };
  var addPipetteTool = (editor, container, onColorChange) => {
    const pipetteButton = createButton_default();
    pipetteButton.classList.add("pipetteButton");
    pipetteButton.title = editor.localization.pickColorFromScreen;
    pipetteButton.setAttribute("alt", pipetteButton.title);
    const pickColorLabel = document.createElement("span");
    pickColorLabel.classList.add("pickColorInstructions");
    pickColorLabel.innerText = editor.localization.clickToPickColorAnnouncement;
    const updatePipetteButtonContent = (color) => {
      pipetteButton.replaceChildren(editor.icons.makePipetteIcon(color), pickColorLabel);
    };
    updatePipetteButtonContent();
    const pipetteTool = editor.toolController.getMatchingTools(PipetteTool)[0];
    const endColorSelectMode = () => {
      pipetteTool?.clearColorListener();
      updatePipetteButtonContent();
      pipetteButton.classList.remove("active");
    };
    const pipetteColorSelect = (color) => {
      endColorSelectMode();
      if (color) {
        onColorChange(color);
      }
    };
    const pipetteColorPreview = (color) => {
      if (color) {
        updatePipetteButtonContent(color);
      } else {
        updatePipetteButtonContent();
      }
    };
    pipetteButton.onclick = () => {
      if (pipetteButton.classList.contains("active")) {
        endColorSelectMode();
        editor.announceForAccessibility(editor.localization.colorSelectionCanceledAnnouncement);
        return;
      }
      pipetteTool?.setColorListener(pipetteColorPreview, pipetteColorSelect);
      if (pipetteTool) {
        pipetteButton.classList.add("active");
        editor.announceForAccessibility(editor.localization.clickToPickColorAnnouncement);
      }
    };
    container.appendChild(pipetteButton);
    return {
      // Cancel a pipette color selection if one is in progress.
      cancel: () => {
        endColorSelectMode();
      },
      registerWithHelpTextDisplay: (helpDisplay) => {
        helpDisplay.registerTextHelpForElement(pipetteButton, editor.localization.colorPickerPipetteHelpText);
      }
    };
  };
  var makeColorInput_default = makeColorInput;

  // node_modules/js-draw/dist/mjs/toolbar/widgets/BaseToolWidget.mjs
  var isToolWidgetFocused = () => {
    const currentFocus = [...document.querySelectorAll("*:focus")];
    return currentFocus.length && currentFocus.some((elem) => elem.classList.contains(`${toolbarCSSPrefix}button`));
  };
  var BaseToolWidget = class extends BaseWidget_default {
    constructor(editor, targetTool, id, localizationTable) {
      super(editor, id, localizationTable);
      this.targetTool = targetTool;
      this.targetTool.enabledValue().onUpdateAndNow((enabled) => {
        if (enabled) {
          this.setSelected(true);
          if (isToolWidgetFocused()) {
            this.focus();
          }
        } else {
          this.setSelected(false);
          this.setDropdownVisible(false);
        }
      });
    }
    shouldAutoDisableInReadOnlyEditor() {
      return !this.targetTool.canReceiveInputInReadOnlyEditor();
    }
    handleClick() {
      if (this.hasDropdown) {
        if (!this.targetTool.isEnabled()) {
          this.targetTool.setEnabled(true);
          this.activateDropdown();
        } else {
          this.setDropdownVisible(!this.isDropdownVisible());
        }
      } else {
        this.targetTool.setEnabled(!this.targetTool.isEnabled());
      }
    }
    onKeyPress(event) {
      if (this.isSelected() && event.code === "Space" && this.hasDropdown) {
        this.handleClick();
        return true;
      }
      return false;
    }
    addTo(parent) {
      const result = super.addTo(parent);
      this.setSelected(this.targetTool.isEnabled());
      return result;
    }
  };

  // node_modules/js-draw/dist/mjs/toolbar/widgets/keybindings.mjs
  var resizeImageToSelectionKeyboardShortcut = "jsdraw.toolbar.SelectionTool.resizeImageToSelection";
  KeyboardShortcutManager_default.registerDefaultKeyboardShortcut(resizeImageToSelectionKeyboardShortcut, ["ctrlOrMeta+r"], "Resize image to selection");
  var selectStrokeTypeKeyboardShortcutIds = [1, 2, 3, 4, 5, 6, 7, 8, 9].map((id) => `jsdraw.toolbar.PenTool.select-pen-${id}`);
  for (let i = 0; i < selectStrokeTypeKeyboardShortcutIds.length; i++) {
    const id = selectStrokeTypeKeyboardShortcutIds[i];
    KeyboardShortcutManager_default.registerDefaultKeyboardShortcut(id, [`CtrlOrMeta+Digit${i + 1}`], "Select pen style " + (i + 1));
  }
  var saveKeyboardShortcut = "jsdraw.toolbar.SaveActionWidget.save";
  KeyboardShortcutManager_default.registerDefaultKeyboardShortcut(saveKeyboardShortcut, ["ctrlOrMeta+KeyS"], "Save");
  var exitKeyboardShortcut = "jsdraw.toolbar.ExitActionWidget.exit";
  KeyboardShortcutManager_default.registerDefaultKeyboardShortcut(exitKeyboardShortcut, ["Alt+KeyQ"], "Exit");

  // node_modules/js-draw/dist/mjs/toolbar/widgets/components/makeThicknessSlider.mjs
  var idCounter2 = 0;
  var makeThicknessSlider = (context, onChange) => {
    const container = document.createElement("div");
    const thicknessLabel = document.createElement("label");
    const thicknessInput = document.createElement("input");
    container.classList.add(`${toolbarCSSPrefix}thicknessSliderContainer`);
    thicknessInput.id = `${toolbarCSSPrefix}thicknessInput${idCounter2++}`;
    thicknessLabel.innerText = context.localization.thicknessLabel;
    thicknessLabel.setAttribute("for", thicknessInput.id);
    const inverseThicknessInputFn = (t2) => Math.log10(t2);
    const thicknessInputFn = (t2) => 10 ** t2;
    thicknessInput.type = "range";
    thicknessInput.oninput = () => {
      onChange(thicknessInputFn(parseFloat(thicknessInput.value)));
    };
    container.appendChild(thicknessLabel);
    container.appendChild(thicknessInput);
    const setBounds = (min2, max2) => {
      const round = (value, roundUp) => {
        const roundFn = roundUp ? Math.ceil : Math.floor;
        return roundFn(value * 100) / 100;
      };
      const sliderMin = round(inverseThicknessInputFn(min2), false);
      const sliderMax = round(inverseThicknessInputFn(max2), true);
      thicknessInput.min = `${sliderMin}`;
      thicknessInput.max = `${sliderMax}`;
      thicknessInput.step = `${toRoundedString((sliderMax - sliderMin) / 20)}`;
    };
    setBounds(2, 262);
    return {
      container,
      addTo: (parent) => {
        parent.appendChild(container);
      },
      setBounds,
      setValue: (thickness) => {
        thicknessInput.value = inverseThicknessInputFn(thickness).toString();
      }
    };
  };
  var makeThicknessSlider_default = makeThicknessSlider;

  // node_modules/js-draw/dist/mjs/util/dom/stopPropagationOfScrollingWheelEvents.mjs
  var stopPropagationOfScrollingWheelEvents = (scrollingContainer) => {
    const scrollsAxis = (delta, clientSize, scrollOffset, scrollSize) => {
      const hasScroll = clientSize !== scrollSize && delta !== 0;
      const eventScrollsPastStart = scrollOffset + delta <= 0;
      const scrollEnd = scrollOffset + clientSize;
      const eventScrollsPastEnd = scrollEnd + delta > scrollSize;
      return hasScroll && !eventScrollsPastStart && !eventScrollsPastEnd;
    };
    scrollingContainer.onwheel = (event) => {
      const scrollsX = scrollsAxis(event.deltaX, scrollingContainer.clientWidth, scrollingContainer.scrollLeft, scrollingContainer.scrollWidth);
      const scrollsY = scrollsAxis(event.deltaY, scrollingContainer.clientHeight, scrollingContainer.scrollTop, scrollingContainer.scrollHeight);
      if (scrollsX || scrollsY) {
        event.stopPropagation();
      }
    };
  };
  var stopPropagationOfScrollingWheelEvents_default = stopPropagationOfScrollingWheelEvents;

  // node_modules/js-draw/dist/mjs/toolbar/widgets/components/makeGridSelector.mjs
  var idCounter3 = 0;
  var makeGridSelector = (labelText, defaultId, choices) => {
    const outerContainer = document.createElement("div");
    outerContainer.classList.add(`${toolbarCSSPrefix}grid-selector`);
    const selectedValue = MutableReactiveValue.fromInitialValue(defaultId);
    const menuContainer = document.createElement("div");
    menuContainer.role = "group";
    menuContainer.id = `${toolbarCSSPrefix}-grid-select-id-${idCounter3++}`;
    stopPropagationOfScrollingWheelEvents_default(menuContainer);
    const label = document.createElement("label");
    label.textContent = labelText;
    label.htmlFor = menuContainer.id;
    outerContainer.appendChild(label);
    let radiogroupName = `${toolbarCSSPrefix}-grid-selector-${idCounter3++}`;
    const createChoiceButton = (record) => {
      const buttonContainer = document.createElement("div");
      buttonContainer.classList.add("choice-button");
      const button = document.createElement("input");
      button.type = "radio";
      button.id = `${toolbarCSSPrefix}-grid-select-button-${idCounter3++}`;
      addLongPressOrHoverCssClasses_default(buttonContainer);
      const labelContainer = document.createElement("label");
      const rebuildLabel = () => {
        labelContainer.setAttribute("title", record.title);
        const labelText2 = document.createElement("span");
        labelText2.classList.add("button-label-text");
        const icon2 = record.makeIcon();
        icon2.classList.add("icon");
        labelText2.innerText = record.title;
        labelContainer.htmlFor = button.id;
        labelContainer.replaceChildren(icon2, labelText2);
      };
      rebuildLabel();
      const updateButtonRadiogroupName = () => {
        button.name = radiogroupName;
      };
      updateButtonRadiogroupName();
      const updateButtonCSS = () => {
        if (button.checked) {
          buttonContainer.classList.add("checked");
        } else {
          buttonContainer.classList.remove("checked");
        }
      };
      button.oninput = () => {
        if (button.checked) {
          selectedValue.set(record.id);
        }
        updateButtonCSS();
      };
      button.onfocus = () => {
        if (buttonContainer.querySelector(":focus-visible")) {
          buttonContainer.classList.add("focus-visible");
        }
      };
      button.onblur = () => {
        buttonContainer.classList.remove("focus-visible");
      };
      buttonContainer.oncontextmenu = (event) => {
        event.preventDefault();
      };
      buttonContainer.replaceChildren(button, labelContainer);
      menuContainer.appendChild(buttonContainer);
      const setChecked = (checked) => {
        button.checked = checked;
        updateButtonCSS();
      };
      setChecked(false);
      const updateIcon = () => {
        rebuildLabel();
      };
      return {
        choiceRecord: record,
        setChecked,
        updateIcon,
        updateButtonRadiogroupName
      };
    };
    const buttons = [];
    for (const choice of choices) {
      buttons.push(createChoiceButton(choice));
    }
    outerContainer.appendChild(menuContainer);
    selectedValue.onUpdateAndNow((choiceId) => {
      for (let i = 0; i < buttons.length; i++) {
        buttons[i].setChecked(buttons[i].choiceRecord.id === choiceId);
      }
    });
    const result = {
      value: selectedValue,
      _radiogroupName: radiogroupName,
      linkWith: (other) => {
        result._radiogroupName = other._radiogroupName;
        radiogroupName = other._radiogroupName;
        for (const button of buttons) {
          button.updateButtonRadiogroupName();
        }
      },
      updateIcons: () => {
        buttons.forEach((button) => button.updateIcon());
      },
      getRootElement() {
        return outerContainer;
      },
      addTo: (parent) => {
        parent.appendChild(outerContainer);
      }
    };
    return result;
  };
  var makeGridSelector_default = makeGridSelector;

  // node_modules/js-draw/dist/mjs/toolbar/widgets/PenToolWidget.mjs
  var PenToolWidget = class _PenToolWidget extends BaseToolWidget {
    constructor(editor, tool, localization7) {
      super(editor, tool, "pen", localization7);
      this.tool = tool;
      this.updateInputs = () => {
      };
      this.shapelikeIDs = ["pressure-sensitive-pen", "freehand-pen"];
      const additionalPens = editor.getCurrentSettings().pens?.additionalPenTypes ?? [];
      const filterPens = editor.getCurrentSettings().pens?.filterPenTypes ?? (() => true);
      this.penTypes = [
        // Non-shape pens
        {
          name: this.localizationTable.flatTipPen,
          id: "pressure-sensitive-pen",
          factory: makePressureSensitiveFreehandLineBuilder
        },
        {
          name: this.localizationTable.roundedTipPen,
          id: "freehand-pen",
          factory: makeFreehandLineBuilder
        },
        {
          name: this.localizationTable.roundedTipPen2,
          id: "polyline-pen",
          factory: makePolylineBuilder
        },
        ...additionalPens.filter((pen) => !pen.isShapeBuilder),
        // Shape pens
        {
          name: this.localizationTable.arrowPen,
          id: "arrow",
          isShapeBuilder: true,
          factory: makeArrowBuilder
        },
        {
          name: this.localizationTable.linePen,
          id: "line",
          isShapeBuilder: true,
          factory: makeLineBuilder
        },
        {
          name: this.localizationTable.filledRectanglePen,
          id: "filled-rectangle",
          isShapeBuilder: true,
          factory: makeFilledRectangleBuilder
        },
        {
          name: this.localizationTable.outlinedRectanglePen,
          id: "outlined-rectangle",
          isShapeBuilder: true,
          factory: makeOutlinedRectangleBuilder
        },
        {
          name: this.localizationTable.outlinedCirclePen,
          id: "outlined-circle",
          isShapeBuilder: true,
          factory: makeOutlinedCircleBuilder
        },
        ...additionalPens.filter((pen) => pen.isShapeBuilder)
      ].filter(filterPens);
      this.editor.notifier.on(EditorEventType.ToolUpdated, (toolEvt) => {
        if (toolEvt.kind !== EditorEventType.ToolUpdated) {
          throw new Error("Invalid event type!");
        }
        if (toolEvt.tool === this.tool) {
          this.updateIcon();
          this.updateInputs();
        }
      });
    }
    getTitle() {
      return this.targetTool.description;
    }
    // Return the index of this tool's stroke factory in the list of
    // all stroke factories.
    //
    // Returns -1 if the stroke factory is not in the list of all stroke factories.
    getCurrentPenTypeIdx() {
      const currentFactory = this.tool.getStrokeFactory();
      for (let i = 0; i < this.penTypes.length; i++) {
        if (this.penTypes[i].factory === currentFactory) {
          return i;
        }
      }
      return -1;
    }
    getCurrentPenType() {
      for (const penType of this.penTypes) {
        if (penType.factory === this.tool.getStrokeFactory()) {
          return penType;
        }
      }
      return null;
    }
    createIconForRecord(record) {
      const style = {
        ...this.tool.getStyleValue().get()
      };
      if (record?.factory) {
        style.factory = record.factory;
      }
      const strokeFactory = record?.factory;
      if (!strokeFactory || strokeFactory === makeFreehandLineBuilder || strokeFactory === makePressureSensitiveFreehandLineBuilder || strokeFactory === makePolylineBuilder) {
        return this.editor.icons.makePenIcon(style);
      } else {
        return this.editor.icons.makeIconFromFactory(style);
      }
    }
    createIcon() {
      return this.createIconForRecord(this.getCurrentPenType());
    }
    // Creates a widget that allows selecting different pen types
    createPenTypeSelector(helpOverlay) {
      const allChoices = this.penTypes.map((penType, index) => {
        return {
          id: index,
          makeIcon: () => this.createIconForRecord(penType),
          title: penType.name,
          isShapeBuilder: penType.isShapeBuilder ?? false
        };
      });
      const penItems = allChoices.filter((choice) => !choice.isShapeBuilder);
      const penSelector = makeGridSelector_default(this.localizationTable.selectPenType, this.getCurrentPenTypeIdx(), penItems);
      const shapeItems = allChoices.filter((choice) => choice.isShapeBuilder);
      const shapeSelector = makeGridSelector_default(this.localizationTable.selectShape, this.getCurrentPenTypeIdx(), shapeItems);
      const onSelectorUpdate = (newPenTypeIndex) => {
        this.tool.setStrokeFactory(this.penTypes[newPenTypeIndex].factory);
      };
      penSelector.value.onUpdate(onSelectorUpdate);
      shapeSelector.value.onUpdate(onSelectorUpdate);
      helpOverlay?.registerTextHelpForElements([penSelector.getRootElement(), shapeSelector.getRootElement()], this.localizationTable.penDropdown__penTypeHelpText);
      return {
        setValue: (penTypeIndex) => {
          penSelector.value.set(penTypeIndex);
          shapeSelector.value.set(penTypeIndex);
        },
        updateIcons: () => {
          penSelector.updateIcons();
          shapeSelector.updateIcons();
        },
        addTo: (parent) => {
          if (penItems.length) {
            penSelector.addTo(parent);
          }
          if (shapeItems.length) {
            shapeSelector.addTo(parent);
          }
        }
      };
    }
    createStrokeCorrectionOptions(helpOverlay) {
      const container = document.createElement("div");
      container.classList.add("action-button-row", `${toolbarCSSPrefix}-pen-tool-toggle-buttons`);
      const addToggleButton = (labelText, icon2) => {
        const button = createElement_default("button", { type: "button" });
        button.classList.add(`${toolbarCSSPrefix}-toggle-button`);
        const iconElement = icon2.cloneNode(true);
        iconElement.classList.add("icon");
        const label = document.createElement("span");
        label.innerText = labelText;
        button.replaceChildren(iconElement, label);
        button.setAttribute("role", "switch");
        container.appendChild(button);
        let checked = false;
        let onChangeListener = (_checked) => {
        };
        const result = {
          setChecked(newChecked) {
            checked = newChecked;
            button.setAttribute("aria-checked", `${checked}`);
            onChangeListener(checked);
          },
          setOnInputListener(listener) {
            onChangeListener = listener;
          },
          addHelpText(text) {
            helpOverlay?.registerTextHelpForElement(button, text);
          }
        };
        button.onclick = () => {
          result.setChecked(!checked);
        };
        return result;
      };
      const stabilizationOption = addToggleButton(this.localizationTable.inputStabilization, this.editor.icons.makeStrokeSmoothingIcon());
      stabilizationOption.setOnInputListener((enabled) => {
        this.tool.setHasStabilization(enabled);
      });
      const autocorrectOption = addToggleButton(this.localizationTable.strokeAutocorrect, this.editor.icons.makeShapeAutocorrectIcon());
      autocorrectOption.setOnInputListener((enabled) => {
        this.tool.setStrokeAutocorrectEnabled(enabled);
      });
      const pressureSensitivityOption = addToggleButton(this.localizationTable.pressureSensitivity, this.editor.icons.makePressureSensitivityIcon());
      pressureSensitivityOption.setOnInputListener((enabled) => {
        this.tool.setPressureSensitivityEnabled(enabled);
      });
      autocorrectOption.addHelpText(this.localizationTable.penDropdown__autocorrectHelpText);
      stabilizationOption.addHelpText(this.localizationTable.penDropdown__stabilizationHelpText);
      pressureSensitivityOption.addHelpText(this.localizationTable.penDropdown__pressureSensitivityHelpText);
      return {
        update: () => {
          stabilizationOption.setChecked(!!this.tool.getInputMapper());
          autocorrectOption.setChecked(this.tool.getStrokeAutocorrectionEnabled());
          pressureSensitivityOption.setChecked(this.tool.getPressureSensitivityEnabled());
        },
        addTo: (parent) => {
          parent.appendChild(container);
        }
      };
    }
    getHelpText() {
      return this.localizationTable.penDropdown__baseHelpText;
    }
    fillDropdown(dropdown, helpDisplay) {
      const container = document.createElement("div");
      container.classList.add(`${toolbarCSSPrefix}spacedList`, `${toolbarCSSPrefix}nonbutton-controls-main-list`);
      const { container: thicknessRow, setValue: setThickness } = makeThicknessSlider_default(this.editor, (thickness) => {
        this.tool.setThickness(thickness);
      });
      const colorRow = document.createElement("div");
      const colorLabel = document.createElement("label");
      const colorInputControl = makeColorInput_default(this.editor, (color) => {
        this.tool.setColor(color);
      });
      const { input: colorInput, container: colorInputContainer } = colorInputControl;
      colorInput.id = `${toolbarCSSPrefix}colorInput${_PenToolWidget.idCounter++}`;
      colorLabel.innerText = this.localizationTable.colorLabel;
      colorLabel.setAttribute("for", colorInput.id);
      colorRow.appendChild(colorLabel);
      colorRow.appendChild(colorInputContainer);
      const toggleButtonRow = this.createStrokeCorrectionOptions(helpDisplay);
      const penTypeSelect = this.createPenTypeSelector(helpDisplay);
      helpDisplay?.registerTextHelpForElement(colorRow, this.localizationTable.penDropdown__colorHelpText);
      if (helpDisplay) {
        colorInputControl.registerWithHelpTextDisplay(helpDisplay);
      }
      helpDisplay?.registerTextHelpForElement(thicknessRow, this.localizationTable.penDropdown__thicknessHelpText);
      this.updateInputs = () => {
        colorInputControl.setValue(this.tool.getColor());
        setThickness(this.tool.getThickness());
        penTypeSelect.updateIcons();
        penTypeSelect.setValue(this.getCurrentPenTypeIdx());
        toggleButtonRow.update();
      };
      this.updateInputs();
      container.replaceChildren(colorRow, thicknessRow);
      penTypeSelect.addTo(container);
      dropdown.replaceChildren(container);
      toggleButtonRow.addTo(dropdown);
      return true;
    }
    onKeyPress(event) {
      if (!this.isSelected()) {
        return false;
      }
      for (let i = 0; i < selectStrokeTypeKeyboardShortcutIds.length; i++) {
        const shortcut = selectStrokeTypeKeyboardShortcutIds[i];
        if (this.editor.shortcuts.matchesShortcut(shortcut, event)) {
          const penTypeIdx = i;
          if (penTypeIdx < this.penTypes.length) {
            this.tool.setStrokeFactory(this.penTypes[penTypeIdx].factory);
            return true;
          }
        }
      }
      if (super.onKeyPress(event)) {
        return true;
      }
      return false;
    }
    serializeState() {
      return {
        ...super.serializeState(),
        color: this.tool.getColor().toHexString(),
        thickness: this.tool.getThickness(),
        strokeFactoryId: this.getCurrentPenType()?.id,
        inputStabilization: !!this.tool.getInputMapper(),
        strokeAutocorrect: this.tool.getStrokeAutocorrectionEnabled(),
        pressureSensitivity: this.tool.getPressureSensitivityEnabled()
      };
    }
    deserializeFrom(state) {
      super.deserializeFrom(state);
      const verifyPropertyType = (propertyName, expectedType) => {
        const actualType = typeof state[propertyName];
        if (actualType !== expectedType) {
          throw new Error(`Deserializing property ${propertyName}: Invalid type. Expected ${expectedType}, was ${actualType}.`);
        }
      };
      if (state.color) {
        verifyPropertyType("color", "string");
        this.tool.setColor(Color4.fromHex(state.color));
      }
      if (state.thickness) {
        verifyPropertyType("thickness", "number");
        this.tool.setThickness(state.thickness);
      }
      if (state.strokeFactoryId) {
        verifyPropertyType("strokeFactoryId", "string");
        const factoryId = state.strokeFactoryId;
        for (const penType of this.penTypes) {
          if (factoryId === penType.id) {
            this.tool.setStrokeFactory(penType.factory);
            break;
          }
        }
      }
      if (state.inputStabilization !== void 0) {
        this.tool.setHasStabilization(!!state.inputStabilization);
      }
      if (state.strokeAutocorrect !== void 0) {
        this.tool.setStrokeAutocorrectEnabled(!!state.strokeAutocorrect);
      }
      if (state.pressureSensitivity !== void 0) {
        this.tool.setPressureSensitivityEnabled(!!state.pressureSensitivity);
      }
    }
  };
  PenToolWidget.idCounter = 0;
  var PenToolWidget_default = PenToolWidget;

  // node_modules/js-draw/dist/mjs/toolbar/widgets/EraserToolWidget.mjs
  var EraserToolWidget = class _EraserToolWidget extends BaseToolWidget {
    constructor(editor, tool, localizationTable) {
      super(editor, tool, "eraser-tool-widget", localizationTable);
      this.tool = tool;
      this.updateInputs = () => {
      };
      this.editor.notifier.on(EditorEventType.ToolUpdated, (toolEvt) => {
        if (toolEvt.kind === EditorEventType.ToolUpdated && toolEvt.tool === this.tool) {
          this.updateInputs();
          this.updateIcon();
        }
      });
    }
    getHelpText() {
      return this.localizationTable.eraserDropdown__baseHelpText;
    }
    getTitle() {
      return this.localizationTable.eraser;
    }
    makeIconForType(mode) {
      return this.editor.icons.makeEraserIcon(this.tool.getThickness(), mode);
    }
    createIcon() {
      return this.makeIconForType(this.tool.getModeValue().get());
    }
    makeEraserTypeSelector(helpDisplay) {
      const container = document.createElement("div");
      const labelElement = document.createElement("label");
      const checkboxElement = document.createElement("input");
      checkboxElement.id = `${toolbarCSSPrefix}eraserToolWidget-${_EraserToolWidget.idCounter++}`;
      labelElement.htmlFor = checkboxElement.id;
      labelElement.innerText = this.localizationTable.fullStrokeEraser;
      checkboxElement.type = "checkbox";
      checkboxElement.oninput = () => {
        this.tool.getModeValue().set(checkboxElement.checked ? EraserMode.FullStroke : EraserMode.PartialStroke);
      };
      const updateValue = () => {
        checkboxElement.checked = this.tool.getModeValue().get() === EraserMode.FullStroke;
      };
      container.replaceChildren(labelElement, checkboxElement);
      helpDisplay?.registerTextHelpForElement(container, this.localizationTable.eraserDropdown__fullStrokeEraserHelpText);
      return {
        addTo: (parent) => {
          parent.appendChild(container);
        },
        updateValue
      };
    }
    fillDropdown(dropdown, helpDisplay) {
      const container = document.createElement("div");
      container.classList.add(`${toolbarCSSPrefix}spacedList`, `${toolbarCSSPrefix}nonbutton-controls-main-list`);
      const thicknessSlider = makeThicknessSlider_default(this.editor, (thickness) => {
        this.tool.setThickness(thickness);
      });
      thicknessSlider.setBounds(10, 55);
      helpDisplay?.registerTextHelpForElement(thicknessSlider.container, this.localizationTable.eraserDropdown__thicknessHelpText);
      const modeSelector = this.makeEraserTypeSelector(helpDisplay);
      this.updateInputs = () => {
        thicknessSlider.setValue(this.tool.getThickness());
        modeSelector.updateValue();
      };
      this.updateInputs();
      container.replaceChildren(thicknessSlider.container);
      modeSelector.addTo(container);
      dropdown.replaceChildren(container);
      return true;
    }
    serializeState() {
      return {
        ...super.serializeState(),
        thickness: this.tool.getThickness(),
        mode: this.tool.getModeValue().get()
      };
    }
    deserializeFrom(state) {
      super.deserializeFrom(state);
      if (state.thickness) {
        const parsedThickness = parseFloat(state.thickness);
        if (typeof parsedThickness !== "number" || !isFinite(parsedThickness)) {
          throw new Error(`Deserializing property ${parsedThickness} is not a number or is not finite.`);
        }
        this.tool.setThickness(parsedThickness);
      }
      if (state.mode) {
        const mode = state.mode;
        if (Object.values(EraserMode).includes(mode)) {
          this.tool.getModeValue().set(mode);
        }
      }
    }
  };
  EraserToolWidget.idCounter = 0;
  var EraserToolWidget_default = EraserToolWidget;

  // node_modules/js-draw/dist/mjs/toolbar/widgets/components/makeSeparator.mjs
  var makeSeparator = (header = "") => {
    const container = document.createElement("div");
    container.classList.add("tool-dropdown-separator");
    container.innerText = header;
    return {
      addTo: (parent) => {
        parent.appendChild(container);
      }
    };
  };
  var makeSeparator_default = makeSeparator;

  // node_modules/js-draw/dist/mjs/toolbar/widgets/components/makeButtonGrid.mjs
  var makeButtonGrid = (buttonSpecs, columnCount) => {
    const container = document.createElement("div");
    container.classList.add("toolbar-button-grid");
    container.style.setProperty("--column-count", `${columnCount}`);
    const makeButton = (buttonSpec) => {
      const buttonElement = createButton_default();
      buttonElement.classList.add("button");
      const iconElement = buttonSpec.icon();
      iconElement.classList.add("icon");
      const labelElement = document.createElement("label");
      labelElement.textContent = buttonSpec.label;
      labelElement.classList.add("button-label-text");
      buttonElement.onclick = buttonSpec.onClick;
      if (buttonSpec.enabled) {
        buttonSpec.enabled.onUpdateAndNow((enabled) => {
          buttonElement.disabled = !enabled;
        });
      }
      buttonElement.replaceChildren(iconElement, labelElement);
      container.appendChild(buttonElement);
      addLongPressOrHoverCssClasses_default(buttonElement);
      buttonSpec.onCreated?.(buttonElement);
      return buttonElement;
    };
    buttonSpecs.map(makeButton);
    return {
      container
    };
  };
  var makeButtonGrid_default = makeButtonGrid;

  // node_modules/js-draw/dist/mjs/toolbar/widgets/SelectionToolWidget.mjs
  var makeFormatMenu = (editor, selectionTool, localizationTable) => {
    const container = document.createElement("div");
    container.classList.add("selection-format-menu", `${toolbarCSSPrefix}spacedList`, `${toolbarCSSPrefix}indentedList`);
    const colorRow = document.createElement("div");
    const colorLabel = document.createElement("label");
    const colorInputControl = makeColorInput_default(editor, (color) => {
      const selection = selectionTool.getSelection();
      if (selection) {
        const updateStyleCommands = [];
        for (const elem of selection.getSelectedObjects()) {
          if (isRestylableComponent(elem)) {
            updateStyleCommands.push(elem.updateStyle({ color }));
          }
        }
        const unitedCommand = uniteCommands_default(updateStyleCommands);
        editor.dispatch(unitedCommand);
      }
    });
    const { input: colorInput, container: colorInputContainer } = colorInputControl;
    colorLabel.innerText = localizationTable.colorLabel;
    const update = () => {
      const selection = selectionTool.getSelection();
      if (selection && selection.getSelectedItemCount() > 0) {
        colorInput.disabled = false;
        container.classList.remove("disabled");
        const colors = [];
        for (const elem of selection.getSelectedObjects()) {
          if (isRestylableComponent(elem)) {
            const color = elem.getStyle().color;
            if (color) {
              colors.push(color);
            }
          }
        }
        colorInputControl.setValue(Color4.average(colors));
      } else {
        colorInput.disabled = true;
        container.classList.add("disabled");
        colorInputControl.setValue(Color4.transparent);
      }
    };
    colorRow.replaceChildren(colorLabel, colorInputContainer);
    container.replaceChildren(colorRow);
    return {
      addTo: (parent) => {
        parent.appendChild(container);
      },
      update,
      registerHelpText: (helpDisplay) => {
        helpDisplay.registerTextHelpForElement(colorRow, localizationTable.selectionDropdown__changeColorHelpText);
        colorInputControl.registerWithHelpTextDisplay(helpDisplay);
      }
    };
  };
  var LassoSelectToggle = class extends BaseWidget_default {
    constructor(editor, tool, localizationTable) {
      super(editor, "selection-mode-toggle", localizationTable);
      this.tool = tool;
      editor.notifier.on(EditorEventType.ToolUpdated, (toolEvt) => {
        if (toolEvt.kind === EditorEventType.ToolUpdated && toolEvt.tool === tool) {
          this.setSelected(tool.modeValue.get() === SelectionMode.Lasso);
        }
      });
      this.setSelected(false);
    }
    shouldAutoDisableInReadOnlyEditor() {
      return false;
    }
    setModeFlag(enabled) {
      this.tool.modeValue.set(enabled ? SelectionMode.Lasso : SelectionMode.Rectangle);
    }
    handleClick() {
      this.setModeFlag(!this.isSelected());
    }
    getTitle() {
      return this.localizationTable.selectionTool__lassoSelect;
    }
    createIcon() {
      return this.editor.icons.makeSelectionIcon(SelectionMode.Lasso);
    }
    fillDropdown(_dropdown) {
      return false;
    }
    getHelpText() {
      return this.localizationTable.selectionTool__lassoSelect__help;
    }
  };
  var SelectionToolWidget = class extends BaseToolWidget {
    constructor(editor, tool, localization7) {
      super(editor, tool, "selection-tool-widget", localization7);
      this.tool = tool;
      this.updateFormatMenu = () => {
      };
      this.addSubWidget(new LassoSelectToggle(editor, tool, this.localizationTable));
      const hasSelection = () => {
        const selection = this.tool.getSelection();
        return !!selection && selection.getSelectedItemCount() > 0;
      };
      this.hasSelectionValue = MutableReactiveValue.fromInitialValue(hasSelection());
      this.editor.notifier.on(EditorEventType.ToolUpdated, (toolEvt) => {
        if (toolEvt.kind !== EditorEventType.ToolUpdated) {
          throw new Error("Invalid event type!");
        }
        if (toolEvt.tool === this.tool) {
          this.hasSelectionValue.set(hasSelection());
          this.updateFormatMenu();
        }
      });
      tool.modeValue.onUpdate(() => {
        this.updateIcon();
      });
    }
    resizeImageToSelection() {
      const selection = this.tool.getSelection();
      if (selection) {
        this.editor.dispatch(this.editor.setImportExportRect(selection.region));
      }
    }
    onKeyPress(event) {
      const shortcuts = this.editor.shortcuts;
      if (shortcuts.matchesShortcut(resizeImageToSelectionKeyboardShortcut, event)) {
        this.resizeImageToSelection();
        return true;
      }
      if (super.onKeyPress(event)) {
        return true;
      }
      return false;
    }
    getTitle() {
      return this.localizationTable.select;
    }
    createIcon() {
      return this.editor.icons.makeSelectionIcon(this.tool.modeValue.get());
    }
    getHelpText() {
      return this.localizationTable.selectionDropdown__baseHelpText;
    }
    createSelectionActions(helpDisplay) {
      const icons = this.editor.icons;
      const grid = makeButtonGrid_default([
        {
          icon: () => icons.makeDeleteSelectionIcon(),
          label: this.localizationTable.deleteSelection,
          onCreated: (button) => {
            helpDisplay?.registerTextHelpForElement(button, this.localizationTable.selectionDropdown__deleteHelpText);
          },
          onClick: () => {
            const selection = this.tool.getSelection();
            this.editor.dispatch(selection.deleteSelectedObjects());
            this.tool.clearSelection();
          },
          enabled: this.hasSelectionValue
        },
        {
          icon: () => icons.makeDuplicateSelectionIcon(),
          label: this.localizationTable.duplicateSelection,
          onCreated: (button) => {
            helpDisplay?.registerTextHelpForElement(button, this.localizationTable.selectionDropdown__duplicateHelpText);
          },
          onClick: async () => {
            const selection = this.tool.getSelection();
            const command = await selection?.duplicateSelectedObjects();
            if (command) {
              this.editor.dispatch(command);
            }
          },
          enabled: this.hasSelectionValue
        },
        {
          icon: () => icons.makeResizeImageToSelectionIcon(),
          label: this.localizationTable.resizeImageToSelection,
          onCreated: (button) => {
            helpDisplay?.registerTextHelpForElement(button, this.localizationTable.selectionDropdown__resizeToHelpText);
          },
          onClick: () => {
            this.resizeImageToSelection();
          },
          enabled: this.hasSelectionValue
        }
      ], 3);
      return { container: grid.container };
    }
    fillDropdown(dropdown, helpDisplay) {
      super.fillDropdown(dropdown, helpDisplay);
      const controlsContainer = document.createElement("div");
      controlsContainer.classList.add(`${toolbarCSSPrefix}nonbutton-controls-main-list`);
      dropdown.appendChild(controlsContainer);
      makeSeparator_default().addTo(controlsContainer);
      const actions = this.createSelectionActions(helpDisplay);
      controlsContainer.appendChild(actions.container);
      makeSeparator_default(this.localizationTable.reformatSelection).addTo(controlsContainer);
      const formatMenu = makeFormatMenu(this.editor, this.tool, this.localizationTable);
      formatMenu.addTo(controlsContainer);
      this.updateFormatMenu = () => formatMenu.update();
      if (helpDisplay) {
        formatMenu.registerHelpText(helpDisplay);
      }
      formatMenu.update();
      return true;
    }
    serializeState() {
      return {
        ...super.serializeState(),
        selectionMode: this.tool.modeValue.get()
      };
    }
    deserializeFrom(state) {
      super.deserializeFrom(state);
      const isValidSelectionMode = Object.values(SelectionMode).includes(state.selectionMode);
      if (isValidSelectionMode) {
        this.tool.modeValue.set(state.selectionMode);
      }
    }
  };

  // node_modules/js-draw/dist/mjs/toolbar/widgets/TextToolWidget.mjs
  var TextToolWidget = class _TextToolWidget extends BaseToolWidget {
    constructor(editor, tool, localization7) {
      super(editor, tool, "text-tool-widget", localization7);
      this.tool = tool;
      this.updateDropdownInputs = null;
      editor.notifier.on(EditorEventType.ToolUpdated, (evt) => {
        if (evt.kind === EditorEventType.ToolUpdated && evt.tool === tool) {
          this.updateIcon();
          this.updateDropdownInputs?.();
        }
      });
    }
    getTitle() {
      return this.targetTool.description;
    }
    createIcon() {
      const textStyle = this.tool.getTextStyle();
      return this.editor.icons.makeTextIcon(textStyle);
    }
    fillDropdown(dropdown) {
      const container = document.createElement("div");
      container.classList.add(`${toolbarCSSPrefix}spacedList`, `${toolbarCSSPrefix}nonbutton-controls-main-list`);
      const fontRow = document.createElement("div");
      const colorRow = document.createElement("div");
      const sizeRow = document.createElement("div");
      const fontInput = document.createElement("select");
      const fontLabel = document.createElement("label");
      const sizeInput = document.createElement("input");
      const sizeLabel = document.createElement("label");
      const { input: colorInput, container: colorInputContainer, setValue: setColorInputValue } = makeColorInput_default(this.editor, (color) => {
        this.tool.setColor(color);
      });
      const colorLabel = document.createElement("label");
      const fontsInInput = /* @__PURE__ */ new Set();
      const addFontToInput = (fontName) => {
        const option = document.createElement("option");
        option.value = fontName;
        option.textContent = fontName;
        fontInput.appendChild(option);
        fontsInInput.add(fontName);
      };
      sizeInput.setAttribute("type", "number");
      sizeInput.min = "1";
      sizeInput.max = "128";
      fontLabel.innerText = this.localizationTable.fontLabel;
      colorLabel.innerText = this.localizationTable.colorLabel;
      sizeLabel.innerText = this.localizationTable.textSize;
      colorInput.id = `${toolbarCSSPrefix}-text-color-input-${_TextToolWidget.idCounter++}`;
      colorLabel.setAttribute("for", colorInput.id);
      sizeInput.id = `${toolbarCSSPrefix}-text-size-input-${_TextToolWidget.idCounter++}`;
      sizeLabel.setAttribute("for", sizeInput.id);
      const defaultFonts = this.editor.getCurrentSettings().text?.fonts ?? [];
      for (const font of defaultFonts) {
        addFontToInput(font);
      }
      fontInput.classList.add("font-selector");
      fontInput.id = `${toolbarCSSPrefix}-text-font-input-${_TextToolWidget.idCounter++}`;
      fontLabel.setAttribute("for", fontInput.id);
      fontInput.onchange = () => {
        this.tool.setFontFamily(fontInput.value);
      };
      sizeInput.onchange = () => {
        const size = parseInt(sizeInput.value);
        if (!isNaN(size) && size > 0) {
          this.tool.setFontSize(size);
        }
      };
      colorRow.appendChild(colorLabel);
      colorRow.appendChild(colorInputContainer);
      fontRow.appendChild(fontLabel);
      fontRow.appendChild(fontInput);
      sizeRow.appendChild(sizeLabel);
      sizeRow.appendChild(sizeInput);
      this.updateDropdownInputs = () => {
        const style = this.tool.getTextStyle();
        setColorInputValue(style.renderingStyle.fill);
        if (!fontsInInput.has(style.fontFamily)) {
          addFontToInput(style.fontFamily);
        }
        fontInput.value = style.fontFamily;
        sizeInput.value = `${style.size}`;
      };
      this.updateDropdownInputs();
      container.replaceChildren(colorRow, sizeRow, fontRow);
      dropdown.appendChild(container);
      return true;
    }
    serializeState() {
      const textStyle = this.tool.getTextStyle();
      return {
        ...super.serializeState(),
        fontFamily: textStyle.fontFamily,
        textSize: textStyle.size,
        color: textStyle.renderingStyle.fill.toHexString()
      };
    }
    deserializeFrom(state) {
      if (state.fontFamily && typeof state.fontFamily === "string") {
        this.tool.setFontFamily(state.fontFamily);
      }
      if (state.color && typeof state.color === "string") {
        this.tool.setColor(Color4.fromHex(state.color));
      }
      if (state.textSize && typeof state.textSize === "number") {
        this.tool.setFontSize(state.textSize);
      }
      super.deserializeFrom(state);
    }
  };
  TextToolWidget.idCounter = 0;
  var TextToolWidget_default = TextToolWidget;

  // node_modules/js-draw/dist/mjs/toolbar/widgets/HandToolWidget.mjs
  var makeZoomControl = (localizationTable, editor, helpDisplay) => {
    const zoomLevelRow = document.createElement("div");
    const increaseButton = createButton_default();
    const decreaseButton = createButton_default();
    const resetViewButton = createButton_default();
    const zoomLevelDisplay = document.createElement("span");
    increaseButton.innerText = "+";
    decreaseButton.innerText = "-";
    resetViewButton.innerText = localizationTable.resetView;
    zoomLevelRow.replaceChildren(zoomLevelDisplay, increaseButton, decreaseButton, resetViewButton);
    zoomLevelRow.classList.add(`${toolbarCSSPrefix}zoomLevelEditor`);
    zoomLevelDisplay.classList.add("zoomDisplay");
    let lastZoom;
    const updateZoomDisplay = () => {
      let zoomLevel = editor.viewport.getScaleFactor() * 100;
      if (zoomLevel > 0.1) {
        zoomLevel = Math.round(zoomLevel * 10) / 10;
      } else {
        zoomLevel = Math.round(zoomLevel * 1e3) / 1e3;
      }
      if (zoomLevel !== lastZoom) {
        zoomLevelDisplay.textContent = localizationTable.zoomLevel(zoomLevel);
        lastZoom = zoomLevel;
      }
    };
    updateZoomDisplay();
    editor.notifier.on(EditorEventType.ViewportChanged, (event) => {
      if (event.kind === EditorEventType.ViewportChanged) {
        updateZoomDisplay();
        resetViewButton.disabled = event.newTransform.eq(Mat33.identity);
      }
    });
    const zoomBy = (factor) => {
      const screenCenter = editor.viewport.visibleRect.center;
      const transformUpdate = Mat33.scaling2D(factor, screenCenter);
      editor.dispatch(Viewport_default.transformBy(transformUpdate), false);
    };
    increaseButton.onclick = () => {
      zoomBy(5 / 4);
    };
    decreaseButton.onclick = () => {
      zoomBy(4 / 5);
    };
    resetViewButton.onclick = () => {
      const addToHistory = false;
      editor.dispatch(Viewport_default.transformBy(editor.viewport.canvasToScreenTransform.inverse()), addToHistory);
    };
    helpDisplay?.registerTextHelpForElement(increaseButton, localizationTable.handDropdown__zoomInHelpText);
    helpDisplay?.registerTextHelpForElement(decreaseButton, localizationTable.handDropdown__zoomOutHelpText);
    helpDisplay?.registerTextHelpForElement(resetViewButton, localizationTable.handDropdown__resetViewHelpText);
    helpDisplay?.registerTextHelpForElement(zoomLevelDisplay, localizationTable.handDropdown__zoomDisplayHelpText);
    return zoomLevelRow;
  };
  var HandModeWidget = class extends BaseWidget_default {
    constructor(editor, tool, flag, makeIcon, title, helpText, localizationTable) {
      super(editor, `pan-mode-${flag}`, localizationTable);
      this.tool = tool;
      this.flag = flag;
      this.makeIcon = makeIcon;
      this.title = title;
      this.helpText = helpText;
      editor.notifier.on(EditorEventType.ToolUpdated, (toolEvt) => {
        if (toolEvt.kind === EditorEventType.ToolUpdated && toolEvt.tool === tool) {
          const allEnabled = !!(tool.getMode() & PanZoomMode.SinglePointerGestures);
          this.setSelected(!!(tool.getMode() & flag) || allEnabled);
          this.setDisabled(allEnabled && flag !== PanZoomMode.SinglePointerGestures);
        }
      });
      this.setSelected(false);
    }
    shouldAutoDisableInReadOnlyEditor() {
      return false;
    }
    setModeFlag(enabled) {
      this.tool.setModeEnabled(this.flag, enabled);
    }
    handleClick() {
      this.setModeFlag(!this.isSelected());
    }
    getTitle() {
      return this.title;
    }
    createIcon() {
      return this.makeIcon();
    }
    fillDropdown(_dropdown) {
      return false;
    }
    getHelpText() {
      return this.helpText;
    }
  };
  var HandToolWidget = class _HandToolWidget extends BaseToolWidget {
    constructor(editor, tool, localizationTable) {
      const isGivenToolPrimary = editor.toolController.getPrimaryTools().includes(tool);
      const primaryTool = (isGivenToolPrimary ? tool : _HandToolWidget.getPrimaryHandTool(editor.toolController)) ?? tool;
      super(editor, primaryTool, "hand-tool-widget", localizationTable);
      this.overridePanZoomTool = (isGivenToolPrimary ? _HandToolWidget.getOverrideHandTool(editor.toolController) : tool) ?? tool;
      this.allowTogglingBaseTool = primaryTool !== null;
      if (!this.allowTogglingBaseTool) {
        this.container.classList.add("dropdownShowable");
      }
      const touchPanningWidget = new HandModeWidget(editor, this.overridePanZoomTool, PanZoomMode.OneFingerTouchGestures, () => this.editor.icons.makeTouchPanningIcon(), localizationTable.touchPanning, localizationTable.handDropdown__touchPanningHelpText, localizationTable);
      const rotationLockWidget = new HandModeWidget(editor, this.overridePanZoomTool, PanZoomMode.RotationLocked, () => this.editor.icons.makeRotationLockIcon(), localizationTable.lockRotation, localizationTable.handDropdown__lockRotationHelpText, localizationTable);
      this.addSubWidget(touchPanningWidget);
      this.addSubWidget(rotationLockWidget);
    }
    static getPrimaryHandTool(toolController) {
      const primaryPanZoomToolList = toolController.getPrimaryTools().filter((tool) => tool instanceof PanZoom);
      const primaryPanZoomTool = primaryPanZoomToolList[0];
      return primaryPanZoomTool;
    }
    static getOverrideHandTool(toolController) {
      const panZoomToolList = toolController.getMatchingTools(PanZoom);
      const panZoomTool = panZoomToolList[0];
      return panZoomTool;
    }
    shouldAutoDisableInReadOnlyEditor() {
      return false;
    }
    getTitle() {
      return this.localizationTable.handTool;
    }
    createIcon() {
      return this.editor.icons.makeHandToolIcon();
    }
    handleClick() {
      if (this.allowTogglingBaseTool) {
        super.handleClick();
      } else {
        this.setDropdownVisible(!this.isDropdownVisible());
      }
    }
    getHelpText() {
      return this.localizationTable.handDropdown__baseHelpText;
    }
    fillDropdown(dropdown, helpDisplay) {
      super.fillDropdown(dropdown, helpDisplay);
      const nonbuttonActionContainer = document.createElement("div");
      nonbuttonActionContainer.classList.add(`${toolbarCSSPrefix}nonbutton-controls-main-list`);
      makeSeparator_default().addTo(nonbuttonActionContainer);
      const zoomControl = makeZoomControl(this.localizationTable, this.editor, helpDisplay);
      nonbuttonActionContainer.appendChild(zoomControl);
      dropdown.appendChild(nonbuttonActionContainer);
      return true;
    }
    setSelected(selected) {
      if (this.allowTogglingBaseTool) {
        super.setSelected(selected);
      }
    }
    serializeState() {
      const toolMode = this.overridePanZoomTool.getMode();
      return {
        ...super.serializeState(),
        touchPanning: toolMode & PanZoomMode.OneFingerTouchGestures,
        rotationLocked: toolMode & PanZoomMode.RotationLocked
      };
    }
    deserializeFrom(state) {
      if (state.touchPanning !== void 0) {
        this.overridePanZoomTool.setModeEnabled(PanZoomMode.OneFingerTouchGestures, !!state.touchPanning);
      }
      if (state.rotationLocked !== void 0) {
        this.overridePanZoomTool.setModeEnabled(PanZoomMode.RotationLocked, !!state.rotationLocked);
      }
      super.deserializeFrom(state);
    }
  };

  // node_modules/js-draw/dist/mjs/toolbar/widgets/ActionButtonWidget.mjs
  var __classPrivateFieldSet11 = function(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var __classPrivateFieldGet13 = function(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var _ActionButtonWidget_autoDisableInReadOnlyEditors;
  var _ActionButtonWidget_helpText;
  var ActionButtonWidget = class extends BaseWidget_default {
    constructor(editor, id, makeIcon, title, clickAction, localizationTable, mustBeToplevel = false, autoDisableInReadOnlyEditors = true) {
      super(editor, id, localizationTable);
      this.makeIcon = makeIcon;
      this.title = title;
      this.clickAction = clickAction;
      this.mustBeToplevel = mustBeToplevel;
      _ActionButtonWidget_autoDisableInReadOnlyEditors.set(this, void 0);
      _ActionButtonWidget_helpText.set(this, void 0);
      __classPrivateFieldSet11(this, _ActionButtonWidget_autoDisableInReadOnlyEditors, autoDisableInReadOnlyEditors, "f");
    }
    /**
     * Sets the text shown in a help overlay for this button.
     *
     * See {@link getHelpText}.
     */
    setHelpText(helpText) {
      __classPrivateFieldSet11(this, _ActionButtonWidget_helpText, helpText, "f");
    }
    getHelpText() {
      return __classPrivateFieldGet13(this, _ActionButtonWidget_helpText, "f");
    }
    shouldAutoDisableInReadOnlyEditor() {
      return __classPrivateFieldGet13(this, _ActionButtonWidget_autoDisableInReadOnlyEditors, "f");
    }
    handleClick() {
      this.clickAction();
    }
    getTitle() {
      return this.title;
    }
    createIcon() {
      return this.makeIcon();
    }
    fillDropdown(_dropdown) {
      return false;
    }
    mustBeInToplevelMenu() {
      return this.mustBeToplevel;
    }
  };
  _ActionButtonWidget_autoDisableInReadOnlyEditors = /* @__PURE__ */ new WeakMap(), _ActionButtonWidget_helpText = /* @__PURE__ */ new WeakMap();
  var ActionButtonWidget_default = ActionButtonWidget;

  // node_modules/js-draw/dist/mjs/toolbar/widgets/components/makeFileInput.mjs
  var idCounter4 = 0;
  var makeFileInput = (labelText, context, { accepts = "*", allowMultiSelect = false, customPickerAction } = {}) => {
    const container = document.createElement("div");
    const label = document.createElement("label");
    const input = document.createElement("input");
    const descriptionBox = document.createElement("div");
    descriptionBox.classList.add("toolbar--file-input-description");
    const descriptionText = document.createElement("span");
    container.classList.add("toolbar--file-input-container");
    label.appendChild(document.createTextNode(labelText));
    input.accept = accepts;
    input.type = customPickerAction ? "button" : "file";
    input.classList.add("file-input");
    input.multiple = allowMultiSelect;
    const inputId = `js-draw-file-input-${idCounter4++}`;
    input.setAttribute("id", inputId);
    label.htmlFor = inputId;
    const icon2 = context.icons.makeUploadFileIcon();
    icon2.classList.add("icon");
    descriptionBox.replaceChildren(icon2, descriptionText);
    label.appendChild(descriptionBox);
    container.replaceChildren(label, input);
    const selectedFiles = ReactiveValue_default.fromInitialValue([]);
    let loading = false;
    let cancelLoading = null;
    const updateStatusText = () => {
      const files = selectedFiles.get();
      if (loading) {
        descriptionText.textContent = context.localization.fileInput__loading;
        if (cancelLoading) {
          const cancelText = document.createElement("b");
          cancelText.textContent = context.localization.cancel;
          cancelText.classList.add("cancel-button");
          descriptionText.appendChild(cancelText);
        }
        icon2.style.display = "none";
      } else if (files.length > 0) {
        const fileNames = files.map((file) => file.name);
        const maxNames = 5;
        if (fileNames.length <= maxNames) {
          descriptionText.textContent = fileNames.join("\n");
        } else {
          const fileNamesToShow = fileNames.slice(0, maxNames - 1);
          descriptionText.textContent = [
            ...fileNamesToShow,
            context.localization.fileInput__andNMoreFiles(fileNames.length - fileNamesToShow.length)
          ].join("\n");
        }
        icon2.style.display = "none";
      } else {
        icon2.style.display = "";
        const text = context.localization.dragAndDropHereOrBrowse;
        const segments = text.split(/[{]{2}(.*)[}]{2}/g);
        descriptionText.replaceChildren();
        for (let i = 0; i < segments.length; i++) {
          if (i % 2 === 1) {
            const boldedText = document.createElement("b");
            boldedText.textContent = segments[i];
            descriptionText.appendChild(boldedText);
          } else {
            descriptionText.appendChild(document.createTextNode(segments[i]));
          }
        }
      }
    };
    const addFileEventListeners = () => {
      label.addEventListener("dragover", (event) => {
        event.preventDefault();
        label.classList.add("drag-target");
      });
      label.addEventListener("dragenter", (event) => {
        event.preventDefault();
        label.classList.add("drag-target");
      });
      label.addEventListener("dragleave", (event) => {
        event.preventDefault();
        const enteringElement = event.relatedTarget;
        if (!enteringElement || !label.contains(enteringElement)) {
          label.classList.remove("drag-target");
        }
      });
      label.addEventListener("drop", (event) => {
        event.preventDefault();
        label.classList.remove("drag-target");
        const fileList = [];
        if (event.dataTransfer) {
          fileList.push(...event.dataTransfer.files);
        }
        selectedFiles.set(fileList);
      });
      input.addEventListener("change", () => {
        const fileList = input.files ?? [];
        selectedFiles.set([...fileList]);
      });
    };
    addFileEventListeners();
    if (customPickerAction) {
      const promptForFiles = async () => {
        if (loading) {
          cancelLoading?.();
          return;
        }
        container.classList.add("-loading");
        loading = true;
        updateStatusText();
        try {
          const data = await customPickerAction({
            setOnCancelCallback: (onCancel) => {
              if (!loading) {
                throw new Error("Task already completed. Can't register cancel handler.");
              }
              cancelLoading = () => {
                cancelLoading = null;
                updateStatusText();
                onCancel();
              };
              updateStatusText();
            }
          });
          if (data) {
            selectedFiles.set(data);
          }
        } finally {
          container.classList.remove("-loading");
          loading = false;
          updateStatusText();
        }
      };
      input.onclick = promptForFiles;
    }
    selectedFiles.onUpdate((files) => {
      if (files.length === 0 && input.files && input.files.length > 0) {
        input.value = "";
      }
      cancelLoading?.();
    });
    selectedFiles.onUpdateAndNow(updateStatusText);
    return {
      container,
      input,
      selectedFiles,
      addTo: (parent) => {
        parent.appendChild(container);
      }
    };
  };
  var makeFileInput_default = makeFileInput;

  // node_modules/js-draw/dist/mjs/util/bytesToSizeString.mjs
  var bytesToSizeString = (sizeBytes) => {
    const sizeInKiB = sizeBytes / 1024;
    const sizeInMiB = sizeInKiB / 1024;
    const sizeInGiB = sizeInMiB / 1024;
    let units = "B";
    let size = sizeBytes;
    if (sizeInGiB >= 1) {
      size = sizeInGiB;
      units = "GiB";
    } else if (sizeInMiB >= 1) {
      size = sizeInMiB;
      units = "MiB";
    } else if (sizeInKiB >= 1) {
      size = sizeInKiB;
      units = "KiB";
    }
    return { size, units };
  };
  var bytesToSizeString_default = bytesToSizeString;

  // node_modules/js-draw/dist/mjs/toolbar/widgets/InsertImageWidget/ImageWrapper.mjs
  var ImageWrapper = class _ImageWrapper {
    constructor(imageBase64Url, preview, onUrlUpdate) {
      this.imageBase64Url = imageBase64Url;
      this.preview = preview;
      this.onUrlUpdate = onUrlUpdate;
      this.originalSrc = imageBase64Url;
      preview.src = imageBase64Url;
    }
    updateImageData(base64DataUrl) {
      this.preview.src = base64DataUrl;
      this.imageBase64Url = base64DataUrl;
      this.onUrlUpdate();
    }
    decreaseSize(resizeFactor = 3 / 4) {
      const canvas = document.createElement("canvas");
      canvas.width = this.preview.naturalWidth * resizeFactor;
      canvas.height = this.preview.naturalHeight * resizeFactor;
      const ctx = canvas.getContext("2d");
      ctx?.drawImage(this.preview, 0, 0, canvas.width, canvas.height);
      const format = this.originalSrc?.startsWith("data:image/jpeg;") ? "image/jpeg" : "image/png";
      this.updateImageData(canvas.toDataURL(format));
    }
    reset() {
      this.updateImageData(this.originalSrc);
    }
    isChanged() {
      return this.imageBase64Url !== this.originalSrc;
    }
    // Returns true if the current image is large enough to display a "decrease size"
    // option.
    isLarge() {
      const largeImageThreshold = 0.12 * 1024 * 1024;
      return this.getBase64Url().length > largeImageThreshold;
    }
    getBase64Url() {
      return this.imageBase64Url;
    }
    getAltText() {
      return this.altText;
    }
    setAltText(text) {
      this.altText = text;
      this.preview.alt = text;
    }
    static fromSrcAndPreview(initialBase64Src, preview, onUrlUpdate) {
      return new _ImageWrapper(initialBase64Src, preview, onUrlUpdate);
    }
    static fromRenderable(renderable, onUrlUpdate) {
      const preview = new Image();
      preview.src = renderable.base64Url;
      const result = new _ImageWrapper(renderable.base64Url, preview, onUrlUpdate);
      const altText = renderable.label ?? renderable.image.getAttribute("alt");
      if (altText) {
        result.setAltText(altText);
      }
      return { wrapper: result, preview };
    }
  };

  // node_modules/js-draw/dist/mjs/toolbar/widgets/components/makeSnappedList.mjs
  var makeSnappedList = (itemsValue) => {
    const container = document.createElement("div");
    container.classList.add("toolbar-snapped-scroll-list");
    const scroller = document.createElement("div");
    scroller.classList.add("scroller");
    const visibleIndex = MutableReactiveValue.fromInitialValue(0);
    let observer = null;
    const makePageMarkers = () => {
      const markerContainer = document.createElement("div");
      markerContainer.classList.add("page-markers");
      markerContainer.setAttribute("tabindex", "-1");
      const markers = [];
      const pairedItems = ReactiveValue.union([
        visibleIndex,
        itemsValue
      ]);
      pairedItems.onUpdateAndNow(([currentVisibleIndex, items]) => {
        let addedOrRemovedMarkers = false;
        while (items.length < markers.length) {
          markers.pop();
          addedOrRemovedMarkers = true;
        }
        let activeMarker;
        for (let i = 0; i < items.length; i++) {
          let marker;
          if (i >= markers.length) {
            marker = document.createElement("div");
            const content = document.createElement("div");
            content.classList.add("content");
            marker.replaceChildren(content);
            markers.push(marker);
            addedOrRemovedMarkers = true;
          } else {
            marker = markers[i];
          }
          marker.classList.add("marker");
          if (i === currentVisibleIndex) {
            marker.classList.add("-active");
            activeMarker = marker;
          } else {
            marker.classList.remove("-active");
          }
          const markerIndex = i;
          marker.onclick = () => {
            wrappedItems.get()[markerIndex]?.element?.scrollIntoView({ block: "nearest", behavior: "smooth" });
          };
        }
        if (addedOrRemovedMarkers) {
          markerContainer.replaceChildren(...markers);
        }
        if (activeMarker && markerContainer.scrollHeight > container.clientHeight) {
          activeMarker.scrollIntoView({ block: "nearest" });
        }
        if (markers.length === 1) {
          markerContainer.classList.add("-one-element");
        } else {
          markerContainer.classList.remove("-one-element");
        }
      });
      return markerContainer;
    };
    const createObserver = () => {
      observer = new IntersectionObserver((entries) => {
        for (const entry of entries) {
          if (entry.isIntersecting && entry.intersectionRatio > 0.7) {
            const indexString = entry.target.getAttribute("data-item-index");
            if (indexString === null)
              throw new Error("Could not find attribute data-item-index");
            const index = Number(indexString);
            visibleIndex.set(index);
            break;
          }
        }
      }, {
        // Element to use as the boudning box with which to intersect.
        // See https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API
        root: scroller,
        // Fraction of an element that must be visible to trigger the callback:
        threshold: 0.9
      });
    };
    const destroyObserver = () => {
      if (observer) {
        observer.disconnect();
        visibleIndex.set(0);
        observer = null;
      }
    };
    const wrappedItems = ReactiveValue.map(itemsValue, (items) => {
      return items.map((item, index) => {
        const wrapper = document.createElement("div");
        if (item.element.parentElement)
          item.element.remove();
        wrapper.appendChild(item.element);
        wrapper.classList.add("item");
        wrapper.setAttribute("data-item-index", `${index}`);
        return {
          element: wrapper,
          data: item.data
        };
      });
    });
    const lastItems = [];
    wrappedItems.onUpdateAndNow((items) => {
      visibleIndex.set(-1);
      for (const item of lastItems) {
        observer?.unobserve(item.element);
      }
      scroller.replaceChildren();
      if (items.length > 1) {
        createObserver();
      } else {
        destroyObserver();
      }
      if (items.length === 0) {
        container.classList.add("-empty");
      } else {
        container.classList.remove("-empty");
      }
      for (const item of items) {
        scroller.appendChild(item.element);
      }
      visibleIndex.set(0);
      if (observer) {
        for (const item of items) {
          observer.observe(item.element);
        }
      }
    });
    const visibleItem = ReactiveValue.map(visibleIndex, (index) => {
      const values = itemsValue.get();
      if (0 <= index && index < values.length) {
        return values[index].data;
      }
      return null;
    });
    stopPropagationOfScrollingWheelEvents_default(scroller);
    container.replaceChildren(makePageMarkers(), scroller);
    return {
      container,
      visibleItem
    };
  };
  var makeSnappedList_default = makeSnappedList;

  // node_modules/js-draw/dist/mjs/toolbar/widgets/InsertImageWidget/fileToImages.mjs
  var fileToImages = async (imageFile) => {
    const result = [];
    const imageElement = new Image();
    const base64Url = await fileToBase64Url_default(imageFile);
    if (base64Url) {
      result.push({
        image: imageElement,
        base64Url,
        transform: Mat33.identity
      });
    }
    return result;
  };
  var fileToImages_default = fileToImages;

  // node_modules/js-draw/dist/mjs/toolbar/widgets/InsertImageWidget/InsertImageWidget.mjs
  var InsertImageWidget = class _InsertImageWidget extends BaseWidget_default {
    constructor(editor, localization7) {
      localization7 ??= editor.localization;
      super(editor, "insert-image-widget", localization7);
      this.container.classList.add("dropdownShowable");
      editor.notifier.on(EditorEventType.SelectionUpdated, (event) => {
        if (event.kind === EditorEventType.SelectionUpdated && this.isDropdownVisible()) {
          this.updateInputs();
        }
      });
      this.images = MutableReactiveValue.fromInitialValue([]);
      this.images.onUpdateAndNow(() => {
        this.onImageDataUpdate();
      });
    }
    getTitle() {
      return this.localizationTable.image;
    }
    createIcon() {
      return this.editor.icons.makeInsertImageIcon();
    }
    setDropdownVisible(visible) {
      super.setDropdownVisible(visible);
      if (this.isDropdownVisible()) {
        this.updateInputs();
      } else {
        this.selectedFiles?.set([]);
      }
    }
    handleClick() {
      this.setDropdownVisible(!this.isDropdownVisible());
    }
    fillDropdown(dropdown) {
      const container = document.createElement("div");
      container.classList.add("insert-image-widget-dropdown-content", `${toolbarCSSPrefix}spacedList`, `${toolbarCSSPrefix}nonbutton-controls-main-list`);
      const { container: chooseImageRow, selectedFiles } = makeFileInput_default(this.localizationTable.chooseFile, this.editor, {
        accepts: "image/*",
        allowMultiSelect: true,
        customPickerAction: this.editor.getCurrentSettings().image?.showImagePicker
      });
      const altTextRow = document.createElement("div");
      this.imagesPreview = makeSnappedList_default(this.images);
      this.statusView = document.createElement("div");
      const actionButtonRow = document.createElement("div");
      actionButtonRow.classList.add("action-button-row");
      this.statusView.classList.add("insert-image-image-status-view");
      this.submitButton = createButton_default();
      this.selectedFiles = selectedFiles;
      this.imageAltTextInput = document.createElement("input");
      const imageAltTextLabel = document.createElement("label");
      const altTextInputId = `insert-image-alt-text-input-${_InsertImageWidget.nextInputId++}`;
      this.imageAltTextInput.setAttribute("id", altTextInputId);
      imageAltTextLabel.htmlFor = altTextInputId;
      imageAltTextLabel.innerText = this.localizationTable.inputAltText;
      this.imageAltTextInput.type = "text";
      this.imageAltTextInput.placeholder = this.localizationTable.describeTheImage;
      this.statusView.setAttribute("aria-live", "polite");
      this.submitButton.innerText = this.localizationTable.submit;
      this.imagesPreview.visibleItem.onUpdateAndNow(() => this.onImageDataUpdate());
      this.imageAltTextInput.oninput = () => {
        const currentImage = this.imagesPreview.visibleItem.get();
        if (currentImage) {
          currentImage.setAltText(this.imageAltTextInput.value);
          this.submitButton.style.display = "";
        }
      };
      this.selectedFiles.onUpdateAndNow(async (files) => {
        if (files.length === 0) {
          this.images.set([]);
          return;
        }
        const previews = (await Promise.all(files.map(async (imageFile) => {
          let renderableImages;
          try {
            renderableImages = await fileToImages_default(imageFile);
          } catch (error) {
            console.error("Image load error", error);
            const errorMessage = this.localizationTable.imageLoadError(error);
            this.statusView.innerText = errorMessage;
            return [];
          }
          return renderableImages.map((image) => {
            const { wrapper, preview } = ImageWrapper.fromRenderable(image, () => this.onImageDataUpdate());
            return {
              data: wrapper,
              element: preview
            };
          });
        }))).flat();
        this.images.set(previews);
      });
      altTextRow.replaceChildren(imageAltTextLabel, this.imageAltTextInput);
      actionButtonRow.replaceChildren(this.submitButton);
      container.replaceChildren(chooseImageRow, altTextRow, this.imagesPreview.container, this.statusView, actionButtonRow);
      dropdown.replaceChildren(container);
      return true;
    }
    onImageDataUpdate() {
      if (!this.imagesPreview)
        return;
      const currentImage = this.imagesPreview.visibleItem.get();
      const base64Data = currentImage?.getBase64Url();
      this.imageAltTextInput.value = currentImage?.getAltText() ?? "";
      if (base64Data) {
        this.submitButton.disabled = false;
        this.submitButton.style.display = "";
        this.updateImageSizeDisplay();
      } else {
        this.submitButton.disabled = true;
        this.submitButton.style.display = "none";
        this.statusView.innerText = "";
        this.submitButton.disabled = true;
      }
      if (this.images.get().length <= 1) {
        this.submitButton.innerText = this.localizationTable.submit;
      } else {
        this.submitButton.innerText = this.localizationTable.addAll;
      }
    }
    hideDialog() {
      this.setDropdownVisible(false);
    }
    updateImageSizeDisplay() {
      const currentImage = this.imagesPreview.visibleItem.get();
      const imageData = currentImage?.getBase64Url() ?? "";
      const { size, units } = bytesToSizeString_default(imageData.length);
      const sizeText = document.createElement("span");
      sizeText.innerText = this.localizationTable.imageSize(Math.round(size), units);
      const decreaseSizeButton = createButton_default({
        text: this.localizationTable.decreaseImageSize,
        onClick: () => {
          currentImage?.decreaseSize();
        }
      });
      const resetSizeButton = createButton_default({
        text: this.localizationTable.resetImage,
        onClick: () => {
          currentImage?.reset();
        }
      });
      this.statusView.replaceChildren(sizeText);
      if (currentImage?.isLarge()) {
        this.statusView.appendChild(decreaseSizeButton);
      } else if (currentImage?.isChanged()) {
        this.statusView.appendChild(resetSizeButton);
      } else {
        const hasLargeOrChangedImages = this.images.get().some((image) => image.data?.isChanged() || image.data?.isLarge());
        if (hasLargeOrChangedImages) {
          decreaseSizeButton.disabled = true;
          this.statusView.appendChild(decreaseSizeButton);
        }
      }
    }
    updateInputs() {
      const resetInputs = () => {
        this.selectedFiles?.set([]);
        this.imageAltTextInput.value = "";
        this.submitButton.disabled = true;
        this.statusView.innerText = "";
        this.submitButton.style.display = "";
      };
      resetInputs();
      const selectionTools = this.editor.toolController.getMatchingTools(SelectionTool);
      const selectedObjects = selectionTools.map((tool) => tool.getSelectedObjects()).flat();
      let editingImage = null;
      if (selectedObjects.length === 1 && selectedObjects[0] instanceof ImageComponent) {
        editingImage = selectedObjects[0];
        const image = new Image();
        const imageWrapper = ImageWrapper.fromSrcAndPreview(editingImage.getURL(), image, () => this.onImageDataUpdate());
        imageWrapper.setAltText(editingImage.getAltText() ?? "");
        this.images.set([{ data: imageWrapper, element: image }]);
      } else if (selectedObjects.length > 0) {
        selectionTools.forEach((tool) => tool.clearSelection());
      }
      this.submitButton.style.display = "none";
      this.submitButton.onclick = async () => {
        const newComponents = [];
        let transform = Mat33.identity;
        let fullBBox = null;
        for (const { data: imageWrapper } of this.images.get()) {
          if (!imageWrapper) {
            continue;
          }
          const image = new Image();
          image.src = imageWrapper.getBase64Url();
          const altText = imageWrapper.getAltText();
          if (altText) {
            image.setAttribute("alt", altText);
          }
          let component;
          try {
            component = await ImageComponent.fromImage(image, transform);
          } catch (error) {
            console.error("Error loading image", error);
            this.statusView.innerText = this.localizationTable.imageLoadError(error);
            return;
          }
          const componentBBox = component.getBBox();
          if (componentBBox.area === 0) {
            this.statusView.innerText = this.localizationTable.errorImageHasZeroSize;
            return;
          }
          newComponents.push(component);
          fullBBox ??= componentBBox;
          fullBBox.union(componentBBox);
          const shift = Vec2.of(0, componentBBox.height);
          transform = transform.rightMul(Mat33.translation(shift));
        }
        if (newComponents.length) {
          if (!fullBBox) {
            throw new Error("Logic error: Full bounding box must be calculated when components are to be added.");
          }
          this.hideDialog();
          if (editingImage) {
            const eraseCommand = new Erase_default([editingImage]);
            const originalTransform = editingImage.getTransformation();
            const originalWidth = editingImage.getBBox().width || 1;
            const newWidth = fullBBox.transformedBoundingBox(originalTransform).width || 1;
            const widthAdjustTransform = Mat33.scaling2D(originalWidth / newWidth);
            const commands = [];
            for (const component of newComponents) {
              commands.push(EditorImage_default.addComponent(component), component.transformBy(originalTransform.rightMul(widthAdjustTransform)), component.setZIndex(editingImage.getZIndex()));
            }
            this.editor.dispatch(uniteCommands_default([...commands, eraseCommand]));
            selectionTools[0]?.setSelection(newComponents);
          } else {
            await this.editor.addAndCenterComponents(newComponents);
          }
        }
      };
    }
  };
  InsertImageWidget.nextInputId = 0;
  var InsertImageWidget_default = InsertImageWidget;

  // node_modules/js-draw/dist/mjs/toolbar/widgets/DocumentPropertiesWidget.mjs
  var DocumentPropertiesWidget = class _DocumentPropertiesWidget extends BaseWidget_default {
    constructor(editor, localizationTable) {
      super(editor, "document-properties-widget", localizationTable);
      this.updateDropdownContent = () => {
      };
      this.dropdownUpdateQueued = false;
      this.container.classList.add("dropdownShowable");
      this.editor.notifier.on(EditorEventType.UndoRedoStackUpdated, () => {
        this.queueDropdownUpdate();
      });
      this.editor.image.notifier.on(EditorImageEventType.ExportViewportChanged, () => {
        this.queueDropdownUpdate();
      });
    }
    getTitle() {
      return this.localizationTable.documentProperties;
    }
    createIcon() {
      return this.editor.icons.makeConfigureDocumentIcon();
    }
    handleClick() {
      this.setDropdownVisible(!this.isDropdownVisible());
      this.queueDropdownUpdate();
    }
    queueDropdownUpdate() {
      if (!this.dropdownUpdateQueued) {
        requestAnimationFrame(() => this.updateDropdown());
        this.dropdownUpdateQueued = true;
      }
    }
    updateDropdown() {
      this.dropdownUpdateQueued = false;
      if (this.isDropdownVisible()) {
        this.updateDropdownContent();
      }
    }
    setBackgroundColor(color) {
      this.editor.dispatch(this.editor.setBackgroundColor(color));
    }
    getBackgroundColor() {
      return this.editor.estimateBackgroundColor();
    }
    removeBackgroundComponents() {
      const previousBackgrounds = [];
      for (const component of this.editor.image.getBackgroundComponents()) {
        if (component instanceof BackgroundComponent) {
          previousBackgrounds.push(component);
        }
      }
      return new Erase_default(previousBackgrounds);
    }
    /** Replace existing background components with a background of the given type. */
    setBackgroundType(backgroundType) {
      const prevBackgroundColor = this.editor.estimateBackgroundColor();
      const newBackground = new BackgroundComponent(backgroundType, prevBackgroundColor);
      const addBackgroundCommand = this.editor.image.addComponent(newBackground);
      return uniteCommands_default([this.removeBackgroundComponents(), addBackgroundCommand]);
    }
    /** Returns the type of the topmost background component */
    getBackgroundType() {
      const backgroundComponents = this.editor.image.getBackgroundComponents();
      for (let i = backgroundComponents.length - 1; i >= 0; i--) {
        const component = backgroundComponents[i];
        if (component instanceof BackgroundComponent) {
          return component.getBackgroundType();
        }
      }
      return BackgroundType.None;
    }
    updateImportExportRectSize(size) {
      const filterDimension = (dim) => {
        if (dim !== void 0 && (!isFinite(dim) || dim <= 0)) {
          dim = 100;
        }
        return dim;
      };
      const width = filterDimension(size.width);
      const height = filterDimension(size.height);
      const currentRect = this.editor.getImportExportRect();
      const newRect = new Rect2(currentRect.x, currentRect.y, width ?? currentRect.w, height ?? currentRect.h);
      this.editor.dispatch(this.editor.image.setImportExportRect(newRect));
      this.editor.queueRerender();
    }
    getHelpText() {
      return this.localizationTable.pageDropdown__baseHelpText;
    }
    fillDropdown(dropdown, helpDisplay) {
      const container = document.createElement("div");
      container.classList.add(`${toolbarCSSPrefix}spacedList`, `${toolbarCSSPrefix}nonbutton-controls-main-list`, `${toolbarCSSPrefix}document-properties-widget`);
      const makeBackgroundColorInput = () => {
        const backgroundColorRow2 = document.createElement("div");
        const backgroundColorLabel = document.createElement("label");
        backgroundColorLabel.innerText = this.localizationTable.backgroundColor;
        const { input: colorInput, container: backgroundColorInputContainer, setValue: setBgColorInputValue2, registerWithHelpTextDisplay: registerHelpForInputs } = makeColorInput_default(this.editor, (color) => {
          if (!color.eq(this.getBackgroundColor())) {
            this.setBackgroundColor(color);
          }
        });
        colorInput.id = `${toolbarCSSPrefix}docPropertiesColorInput-${_DocumentPropertiesWidget.idCounter++}`;
        backgroundColorLabel.htmlFor = colorInput.id;
        backgroundColorRow2.replaceChildren(backgroundColorLabel, backgroundColorInputContainer);
        const registerWithHelp = (helpDisplay2) => {
          if (!helpDisplay2) {
            return;
          }
          helpDisplay2?.registerTextHelpForElement(backgroundColorRow2, this.localizationTable.pageDropdown__backgroundColorHelpText);
          registerHelpForInputs(helpDisplay2);
        };
        return { setBgColorInputValue: setBgColorInputValue2, backgroundColorRow: backgroundColorRow2, registerWithHelp };
      };
      const { backgroundColorRow, setBgColorInputValue, registerWithHelp: registerBackgroundRowWithHelp } = makeBackgroundColorInput();
      const makeCheckboxRow = (labelText, onChange) => {
        const rowContainer = document.createElement("div");
        const labelElement = document.createElement("label");
        const checkboxElement = document.createElement("input");
        checkboxElement.id = `${toolbarCSSPrefix}docPropertiesCheckbox-${_DocumentPropertiesWidget.idCounter++}`;
        labelElement.htmlFor = checkboxElement.id;
        checkboxElement.type = "checkbox";
        labelElement.innerText = labelText;
        checkboxElement.oninput = () => {
          onChange(checkboxElement.checked);
        };
        rowContainer.replaceChildren(labelElement, checkboxElement);
        return { container: rowContainer, checkbox: checkboxElement };
      };
      const { container: useGridRow, checkbox: useGridCheckbox } = makeCheckboxRow(this.localizationTable.useGridOption, (checked) => {
        const prevBackgroundType = this.getBackgroundType();
        const wasGrid = prevBackgroundType === BackgroundType.Grid;
        if (wasGrid === checked) {
          return;
        }
        let newBackgroundType = BackgroundType.SolidColor;
        if (checked) {
          newBackgroundType = BackgroundType.Grid;
        }
        this.editor.dispatch(this.setBackgroundType(newBackgroundType));
      });
      const addDimensionRow = (labelContent, onChange) => {
        const row = document.createElement("div");
        const label = document.createElement("label");
        const input = document.createElement("input");
        label.innerText = labelContent;
        input.type = "number";
        input.min = "0";
        input.id = `${toolbarCSSPrefix}docPropertiesDimensionRow-${_DocumentPropertiesWidget.idCounter++}`;
        label.htmlFor = input.id;
        input.style.flexGrow = "2";
        input.style.width = "25px";
        input.oninput = () => {
          onChange(parseFloat(input.value));
        };
        row.classList.add("js-draw-size-input-row");
        row.replaceChildren(label, input);
        return {
          setValue: (value) => {
            if (document.activeElement === input && input.value.match(/^0*$/)) {
              const originalValue = input.value;
              input.type = "text";
              input.value = value.toString();
              const lengthToSelect = Math.max(1, input.value.length - originalValue.length);
              input.setSelectionRange(0, lengthToSelect);
              input.type = "number";
            } else {
              input.value = value.toString();
            }
          },
          setIsAutomaticSize: (automatic) => {
            input.disabled = automatic;
            const automaticSizeClass = "size-input-row--automatic-size";
            if (automatic) {
              row.classList.add(automaticSizeClass);
            } else {
              row.classList.remove(automaticSizeClass);
            }
          },
          element: row
        };
      };
      const imageWidthRow = addDimensionRow(this.localizationTable.imageWidthOption, (value) => {
        this.updateImportExportRectSize({ width: value });
      });
      const imageHeightRow = addDimensionRow(this.localizationTable.imageHeightOption, (value) => {
        this.updateImportExportRectSize({ height: value });
      });
      const { container: auroresizeRow, checkbox: autoresizeCheckbox } = makeCheckboxRow(this.localizationTable.enableAutoresizeOption, (checked) => {
        const image = this.editor.image;
        this.editor.dispatch(image.setAutoresizeEnabled(checked));
      });
      const aboutButton = createButton_default({
        classList: ["about-button"],
        text: this.localizationTable.about
      });
      aboutButton.onclick = () => {
        this.editor.showAboutDialog();
      };
      registerBackgroundRowWithHelp(helpDisplay);
      helpDisplay?.registerTextHelpForElement(useGridRow, this.localizationTable.pageDropdown__gridCheckboxHelpText);
      helpDisplay?.registerTextHelpForElement(auroresizeRow, this.localizationTable.pageDropdown__autoresizeCheckboxHelpText);
      helpDisplay?.registerTextHelpForElement(aboutButton, this.localizationTable.pageDropdown__aboutButtonHelpText);
      this.updateDropdownContent = () => {
        setBgColorInputValue(this.getBackgroundColor());
        const autoresize = this.editor.image.getAutoresizeEnabled();
        const importExportRect = this.editor.getImportExportRect();
        imageWidthRow.setValue(importExportRect.width);
        imageHeightRow.setValue(importExportRect.height);
        autoresizeCheckbox.checked = autoresize;
        imageWidthRow.setIsAutomaticSize(autoresize);
        imageHeightRow.setIsAutomaticSize(autoresize);
        useGridCheckbox.checked = this.getBackgroundType() === BackgroundType.Grid;
      };
      this.updateDropdownContent();
      container.replaceChildren(backgroundColorRow, useGridRow, imageWidthRow.element, imageHeightRow.element, auroresizeRow, aboutButton);
      dropdown.replaceChildren(container);
      return true;
    }
  };
  DocumentPropertiesWidget.idCounter = 0;
  var DocumentPropertiesWidget_default = DocumentPropertiesWidget;

  // node_modules/js-draw/dist/mjs/toolbar/widgets/SaveActionWidget.mjs
  var SaveActionWidget = class extends ActionButtonWidget_default {
    constructor(editor, localization7, saveCallback, labelOverride = {}) {
      super(
        editor,
        "save-button",
        // Creates an icon
        () => {
          return labelOverride.icon ?? editor.icons.makeSaveIcon();
        },
        labelOverride.label ?? localization7.save,
        saveCallback
      );
      this.setTags([ToolbarWidgetTag.Save]);
    }
    shouldAutoDisableInReadOnlyEditor() {
      return false;
    }
    onKeyPress(event) {
      if (this.editor.shortcuts.matchesShortcut(saveKeyboardShortcut, event)) {
        this.clickAction();
        return true;
      }
      return super.onKeyPress(event);
    }
    mustBeInToplevelMenu() {
      return true;
    }
  };
  var SaveActionWidget_default = SaveActionWidget;

  // node_modules/js-draw/dist/mjs/toolbar/widgets/ExitActionWidget.mjs
  var ExitActionWidget = class extends ActionButtonWidget_default {
    constructor(editor, localization7, saveCallback, labelOverride = {}) {
      super(
        editor,
        "exit-button",
        // Creates an icon
        () => {
          return labelOverride.icon ?? editor.icons.makeCloseIcon();
        },
        labelOverride.label ?? localization7.exit,
        saveCallback
      );
      this.setTags([ToolbarWidgetTag.Exit]);
    }
    shouldAutoDisableInReadOnlyEditor() {
      return false;
    }
    onKeyPress(event) {
      if (this.editor.shortcuts.matchesShortcut(exitKeyboardShortcut, event)) {
        this.clickAction();
        return true;
      }
      return super.onKeyPress(event);
    }
    mustBeInToplevelMenu() {
      return true;
    }
  };
  var ExitActionWidget_default = ExitActionWidget;

  // node_modules/js-draw/dist/mjs/toolbar/AbstractToolbar.mjs
  var __classPrivateFieldGet14 = function(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var __classPrivateFieldSet12 = function(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var _AbstractToolbar_listeners;
  var _AbstractToolbar_widgetsById;
  var _AbstractToolbar_widgetList;
  var _AbstractToolbar_updateColoris;
  var AbstractToolbar = class _AbstractToolbar {
    /** @internal */
    constructor(editor, localizationTable) {
      this.editor = editor;
      _AbstractToolbar_listeners.set(this, []);
      _AbstractToolbar_widgetsById.set(this, {});
      _AbstractToolbar_widgetList.set(this, []);
      _AbstractToolbar_updateColoris.set(this, null);
      this.closeColorPickerOverlay = null;
      this.localizationTable = localizationTable ?? editor.localization;
      if (!_AbstractToolbar.colorisStarted) {
        _init();
        _AbstractToolbar.colorisStarted = true;
      }
      this.setupColorPickers();
    }
    setupCloseColorPickerOverlay() {
      if (this.closeColorPickerOverlay)
        return;
      this.closeColorPickerOverlay = document.createElement("div");
      this.closeColorPickerOverlay.className = `${toolbarCSSPrefix}closeColorPickerOverlay`;
      this.editor.createHTMLOverlay(this.closeColorPickerOverlay);
      __classPrivateFieldGet14(this, _AbstractToolbar_listeners, "f").push(this.editor.handlePointerEventsExceptClicksFrom(this.closeColorPickerOverlay, (eventName) => {
        if (eventName === "pointerdown") {
          _close();
        }
        if (eventName === "pointerup") {
          this.editor.focus();
        }
        return true;
      }));
    }
    // @internal
    setupColorPickers() {
      if (__classPrivateFieldGet14(this, _AbstractToolbar_updateColoris, "f")) {
        __classPrivateFieldGet14(this, _AbstractToolbar_updateColoris, "f").call(this);
        return;
      }
      this.setupCloseColorPickerOverlay();
      const maxSwatchLen = 12;
      const swatches = [
        Color4.red.toHexString(),
        Color4.purple.toHexString(),
        Color4.blue.toHexString(),
        Color4.clay.toHexString(),
        Color4.black.toHexString(),
        Color4.white.toHexString()
      ];
      const presetColorEnd = swatches.length;
      let colorisInitScheduled = false;
      const initColoris = () => {
        try {
          _coloris({
            el: ".coloris_input",
            format: "hex",
            selectInput: false,
            focusInput: false,
            themeMode: "auto",
            swatches
          });
        } catch (err) {
          console.warn("Failed to initialize Coloris. Error: ", err);
          if (!colorisInitScheduled) {
            colorisInitScheduled = true;
            document.addEventListener("load", () => {
              initColoris();
            }, { once: true });
          }
        }
      };
      initColoris();
      __classPrivateFieldSet12(this, _AbstractToolbar_updateColoris, initColoris, "f");
      const addColorToSwatch = (newColor) => {
        let alreadyPresent = false;
        for (const color of swatches) {
          if (color === newColor) {
            alreadyPresent = true;
          }
        }
        if (!alreadyPresent) {
          swatches.push(newColor);
          if (swatches.length > maxSwatchLen) {
            swatches.splice(presetColorEnd, 1);
          }
          initColoris();
        }
      };
      __classPrivateFieldGet14(this, _AbstractToolbar_listeners, "f").push(this.editor.notifier.on(EditorEventType.ColorPickerToggled, (event) => {
        if (event.kind !== EditorEventType.ColorPickerToggled) {
          return;
        }
        if (this.closeColorPickerOverlay) {
          this.closeColorPickerOverlay.style.display = event.open ? "block" : "none";
        }
      }));
      __classPrivateFieldGet14(this, _AbstractToolbar_listeners, "f").push(this.editor.notifier.on(EditorEventType.ColorPickerColorSelected, (event) => {
        if (event.kind === EditorEventType.ColorPickerColorSelected) {
          addColorToSwatch(event.color.toHexString());
        }
      }));
    }
    closeColorPickers() {
      _close?.();
    }
    getWidgetUniqueId(widget) {
      return widget.getUniqueIdIn(__classPrivateFieldGet14(this, _AbstractToolbar_widgetsById, "f"));
    }
    getWidgetFromId(id) {
      return __classPrivateFieldGet14(this, _AbstractToolbar_widgetsById, "f")[id];
    }
    /** Do **not** modify the return value. */
    getAllWidgets() {
      return __classPrivateFieldGet14(this, _AbstractToolbar_widgetList, "f");
    }
    /**
     * Adds an `ActionButtonWidget` or `BaseToolWidget`. The widget should not have already have a parent
     * (i.e. its `addTo` method should not have been called).
     *
     * @example
     * ```ts
     * const toolbar = editor.addToolbar();
     * const insertImageWidget = new InsertImageWidget(editor);
     * toolbar.addWidget(insertImageWidget);
     * ```
     */
    addWidget(widget) {
      const id = widget.getUniqueIdIn(__classPrivateFieldGet14(this, _AbstractToolbar_widgetsById, "f"));
      __classPrivateFieldGet14(this, _AbstractToolbar_widgetsById, "f")[id] = widget;
      __classPrivateFieldGet14(this, _AbstractToolbar_widgetList, "f").push(widget);
      this.addWidgetInternal(widget);
      this.setupColorPickers();
    }
    /** Removes the given `widget` from this toolbar. */
    removeWidget(widget) {
      const id = widget.getUniqueIdIn(__classPrivateFieldGet14(this, _AbstractToolbar_widgetsById, "f"));
      this.removeWidgetInternal(widget);
      delete __classPrivateFieldGet14(this, _AbstractToolbar_widgetsById, "f")[id];
      __classPrivateFieldSet12(this, _AbstractToolbar_widgetList, __classPrivateFieldGet14(this, _AbstractToolbar_widgetList, "f").filter((otherWidget) => otherWidget !== widget), "f");
    }
    /** Returns a snapshot of the state of widgets in the toolbar. */
    serializeState() {
      const result = {};
      for (const widgetId in __classPrivateFieldGet14(this, _AbstractToolbar_widgetsById, "f")) {
        result[widgetId] = __classPrivateFieldGet14(this, _AbstractToolbar_widgetsById, "f")[widgetId].serializeState();
      }
      result[_AbstractToolbar.rootToolbarId] = this.serializeInternal();
      return JSON.stringify(result);
    }
    /**
     * Deserialize toolbar widgets from the given state.
     * Assumes that toolbar widgets are in the same order as when state was serialized.
     */
    deserializeState(state) {
      const data = JSON.parse(state);
      assertIsObject(data);
      assertTruthy(data);
      const rootId = _AbstractToolbar.rootToolbarId;
      if (rootId in data && typeof data[rootId] !== "undefined") {
        this.deserializeInternal(data[rootId]);
      }
      for (const widgetId in data) {
        if (widgetId === rootId) {
          continue;
        }
        if (!(widgetId in __classPrivateFieldGet14(this, _AbstractToolbar_widgetsById, "f"))) {
          console.warn(`Unable to deserialize widget ${widgetId} \xAD\u2014 no such widget.`);
          continue;
        }
        if (typeof data[widgetId] === "object" && data[widgetId]) {
          __classPrivateFieldGet14(this, _AbstractToolbar_widgetsById, "f")[widgetId].deserializeFrom(data[widgetId]);
        }
      }
    }
    /**
     * Called by `serializeState` to attach any additional JSONifyable data
     * to the serialized result.
     *
     * @returns an object that can be converted to JSON with `JSON.stringify`.
     */
    serializeInternal() {
    }
    /**
     * Called by `deserializeState` with a version of the JSON outputted
     * previously by `serializeInternal`.
     */
    deserializeInternal(_json) {
    }
    /**
     * Creates, but does not add, an action button to this container.
     *
     * @see
     * {@link addActionButton}
     */
    makeActionButton(title, command, options = true) {
      if (typeof options === "boolean") {
        options = {
          mustBeToplevel: options
        };
      }
      const mustBeToplevel = options.mustBeToplevel ?? true;
      const autoDisableInReadOnlyEditors = options.autoDisableInReadOnlyEditors ?? true;
      const titleString = typeof title === "string" ? title : title.label;
      const widgetId = "action-button";
      const makeIcon = () => {
        if (typeof title === "string") {
          return null;
        }
        return title.icon;
      };
      const widget = new ActionButtonWidget_default(this.editor, widgetId, makeIcon, titleString, command, this.editor.localization, mustBeToplevel, autoDisableInReadOnlyEditors);
      return widget;
    }
    /**
     * Adds an action button with `title` to this toolbar (or to the given `parent` element).
     *
     * `options` can either be an object with properties `mustBeToplevel` and/or
     * `autoDisableInReadOnlyEditors` or a boolean value. If a boolean, it is interpreted
     * as being the value of `mustBeToplevel`.
     *
     * @return The added button.
     *
     * **Example**:
     * ```ts,runnable
     * import { Editor } from 'js-draw';
     * const editor = new Editor(document.body);
     * const toolbar = editor.addToolbar();
     *
     * function makeTrashIcon() {
     *   const container = document.createElement('div');
     *   container.textContent = '';
     *   return container;
     * }
     *
     * toolbar.addActionButton({
     *   icon: makeTrashIcon(), // can be any Element not in the DOM
     *   label: 'Delete all',
     * }, () => {
     *   alert('to-do!');
     * });
     */
    addActionButton(title, command, options = true) {
      const widget = this.makeActionButton(title, command, options);
      this.addWidget(widget);
      return widget;
    }
    /**
     * Like {@link addActionButton}, except associates `tags` with the button that allow
     * different toolbar styles to give the button tag-dependent styles.
     */
    addTaggedActionButton(tags, title, command, options = true) {
      const widget = this.makeActionButton(title, command, options);
      widget.setTags(tags);
      this.addWidget(widget);
      return widget;
    }
    /**
     * Adds a save button that, when clicked, calls `saveCallback`.
     *
     * @example
     * ```ts,runnable
     * import { Editor, makeDropdownToolbar } from 'js-draw';
     *
     * const editor = new Editor(document.body);
     * const toolbar = makeDropdownToolbar(editor);
     *
     * toolbar.addDefaults();
     * toolbar.addSaveButton(() => alert('save clicked!'));
     * ```
     *
     * `labelOverride` can optionally be used to change the `label` or `icon` of the button.
     */
    addSaveButton(saveCallback, labelOverride = {}) {
      const widget = new SaveActionWidget_default(this.editor, this.localizationTable, saveCallback, labelOverride);
      this.addWidget(widget);
      return widget;
    }
    /**
     * Adds an "Exit" button that, when clicked, calls `exitCallback`.
     *
     * **Note**: This is *roughly* equivalent to
     * ```ts
     * toolbar.addTaggedActionButton([ ToolbarWidgetTag.Exit ], {
     *   label: this.editor.localization.exit,
     *   icon: this.editor.icons.makeCloseIcon(),
     *
     *   // labelOverride can be used to override label or icon.
     *   ...labelOverride,
     * }, () => {
     *   exitCallback();
     * });
     * ```
     * with some additional configuration.
     *
     * @final
     */
    addExitButton(exitCallback, labelOverride = {}) {
      const widget = new ExitActionWidget_default(this.editor, this.localizationTable, exitCallback, labelOverride);
      this.addWidget(widget);
      return widget;
    }
    /**
     * Adds undo and redo buttons that trigger the editor's built-in undo and redo
     * functionality.
     */
    addUndoRedoButtons(undoFirst = true) {
      const makeUndo = () => {
        return this.addTaggedActionButton([ToolbarWidgetTag.Undo], {
          label: this.localizationTable.undo,
          icon: this.editor.icons.makeUndoIcon()
        }, () => {
          this.editor.history.undo();
        });
      };
      const makeRedo = () => {
        return this.addTaggedActionButton([ToolbarWidgetTag.Redo], {
          label: this.localizationTable.redo,
          icon: this.editor.icons.makeRedoIcon()
        }, () => {
          this.editor.history.redo();
        });
      };
      let undoButton;
      let redoButton;
      if (undoFirst) {
        undoButton = makeUndo();
        redoButton = makeRedo();
      } else {
        redoButton = makeRedo();
        undoButton = makeUndo();
      }
      undoButton.setDisabled(true);
      redoButton.setDisabled(true);
      this.editor.notifier.on(EditorEventType.UndoRedoStackUpdated, (event) => {
        if (event.kind !== EditorEventType.UndoRedoStackUpdated) {
          throw new Error("Wrong event type!");
        }
        undoButton.setDisabled(event.undoStackSize === 0);
        redoButton.setDisabled(event.redoStackSize === 0);
      });
    }
    /**
     * Adds widgets for pen/eraser/selection/text/pan-zoom primary tools.
     *
     * If `filter` returns `false` for a tool, no widget is added for that tool.
     * See {@link addDefaultToolWidgets}
     */
    addWidgetsForPrimaryTools(filter) {
      for (const tool of this.editor.toolController.getPrimaryTools()) {
        if (filter && !filter?.(tool)) {
          continue;
        }
        if (tool instanceof Pen) {
          const widget = new PenToolWidget_default(this.editor, tool, this.localizationTable);
          this.addWidget(widget);
        } else if (tool instanceof Eraser) {
          this.addWidget(new EraserToolWidget_default(this.editor, tool, this.localizationTable));
        } else if (tool instanceof SelectionTool) {
          this.addWidget(new SelectionToolWidget(this.editor, tool, this.localizationTable));
        } else if (tool instanceof TextTool) {
          this.addWidget(new TextToolWidget_default(this.editor, tool, this.localizationTable));
        } else if (tool instanceof PanZoom) {
          this.addWidget(new HandToolWidget(this.editor, tool, this.localizationTable));
        }
      }
    }
    /**
     * Adds toolbar widgets based on the enabled tools, and additional tool-like
     * buttons (e.g. {@link DocumentPropertiesWidget} and {@link InsertImageWidget}).
     */
    addDefaultToolWidgets() {
      this.addWidgetsForPrimaryTools();
      this.addDefaultEditorControlWidgets();
    }
    /**
     * Adds widgets that don't correspond to tools, but do allow the user to control
     * the editor in some way.
     *
     * By default, this includes {@link DocumentPropertiesWidget} and {@link InsertImageWidget}.
     */
    addDefaultEditorControlWidgets() {
      this.addWidget(new DocumentPropertiesWidget_default(this.editor, this.localizationTable));
      this.addWidget(new InsertImageWidget_default(this.editor, this.localizationTable));
    }
    addDefaultActionButtons() {
      this.addUndoRedoButtons();
    }
    /**
     * Remove this toolbar from its container and clean up listeners.
     * This should only be called **once** for a given toolbar.
     */
    remove() {
      this.closeColorPickerOverlay?.remove();
      for (const listener of __classPrivateFieldGet14(this, _AbstractToolbar_listeners, "f")) {
        listener.remove();
      }
      __classPrivateFieldSet12(this, _AbstractToolbar_listeners, [], "f");
      this.onRemove();
      for (const widget of __classPrivateFieldGet14(this, _AbstractToolbar_widgetList, "f")) {
        widget.remove();
      }
    }
    /**
     * Removes `listener` when {@link remove} is called.
     */
    manageListener(listener) {
      __classPrivateFieldGet14(this, _AbstractToolbar_listeners, "f").push(listener);
    }
  };
  _AbstractToolbar_listeners = /* @__PURE__ */ new WeakMap(), _AbstractToolbar_widgetsById = /* @__PURE__ */ new WeakMap(), _AbstractToolbar_widgetList = /* @__PURE__ */ new WeakMap(), _AbstractToolbar_updateColoris = /* @__PURE__ */ new WeakMap();
  AbstractToolbar.colorisStarted = false;
  AbstractToolbar.rootToolbarId = "root-toolbar--";
  var AbstractToolbar_default = AbstractToolbar;

  // node_modules/js-draw/dist/mjs/toolbar/EdgeToolbar.mjs
  var makeEdgeToolbar = (editor) => {
    return new EdgeToolbar(editor, editor.getRootElement(), editor.localization);
  };
  var EdgeToolbar = class extends AbstractToolbar_default {
    /** @internal */
    constructor(editor, parent, localizationTable) {
      super(editor, localizationTable);
      this.clearDragListeners = null;
      this.toolbarContainer = document.createElement("div");
      this.toolbarContainer.classList.add(`${toolbarCSSPrefix}root`);
      this.toolbarContainer.classList.add(`${toolbarCSSPrefix}element`);
      this.toolbarContainer.classList.add(`${toolbarCSSPrefix}edge-toolbar`);
      this.toolbarContainer.setAttribute("role", "toolbar");
      this.toolbarActionRow = document.createElement("div");
      this.toolbarActionRow.classList.add("toolbar-element", "toolbar-action-row");
      this.toolbarToolRow = document.createElement("div");
      this.toolbarToolRow.classList.add("toolbar-element", "toolbar-tool-row");
      stopPropagationOfScrollingWheelEvents_default(this.toolbarToolRow);
      if ("ResizeObserver" in window) {
        this.toolRowResizeObserver = new ResizeObserver((_entries) => {
          this.onToolbarRowResize();
        });
        this.toolRowResizeObserver.observe(this.toolbarToolRow);
      } else {
        console.warn("ResizeObserver not supported. Toolbar will not resize.");
      }
      this.toolbarContainer.replaceChildren(this.toolbarActionRow, this.toolbarToolRow);
      parent.appendChild(this.toolbarContainer);
      this.sidebarVisible = ReactiveValue.fromInitialValue(false);
      this.sidebarY = ReactiveValue.fromInitialValue(0);
      this.menuContainer = document.createElement("div");
      this.menuContainer.classList.add(`${toolbarCSSPrefix}edgemenu-container`);
      this.sidebarContainer = document.createElement("div");
      this.sidebarContainer.classList.add(`${toolbarCSSPrefix}edgemenu`, `${toolbarCSSPrefix}element`);
      this.sidebarContainer.classList.add(`${toolbarCSSPrefix}tool-properties`);
      this.sidebarContent = document.createElement("div");
      this.sidebarY.onUpdateAndNow((y) => {
        const belowEdgeClassName = "dropdown-below-edge";
        if (y > 0) {
          this.sidebarContainer.style.transform = `translate(0, ${y}px)`;
          this.sidebarContainer.style.paddingBottom = "";
          this.menuContainer.classList.add(belowEdgeClassName);
        } else {
          this.sidebarContainer.style.transform = "";
          this.sidebarContainer.style.paddingBottom = `${-y}px`;
          this.menuContainer.classList.remove(belowEdgeClassName);
        }
      });
      this.closeButton = createButton_default();
      this.closeButton.classList.add("drag-elem");
      this.editor.handleKeyEventsFrom(this.closeButton, (event) => {
        return event.code !== "Space" && event.code !== "Enter" && event.code !== "Tab";
      });
      this.sidebarContainer.addEventListener("keyup", (event) => {
        if (!event.defaultPrevented && event.code === "Escape") {
          this.sidebarVisible.set(false);
          event.preventDefault();
        }
      });
      this.initDragListeners();
      const setSidebarContent = (...content) => {
        this.sidebarContent.replaceChildren(...content);
        this.setupColorPickers();
      };
      this.sidebarTitle = MutableReactiveValue.fromInitialValue("");
      this.layoutManager = new EdgeToolbarLayoutManager(setSidebarContent, this.sidebarTitle, this.sidebarVisible, editor.announceForAccessibility.bind(editor), localizationTable);
      this.sidebarTitle.onUpdateAndNow((title) => {
        this.closeButton.setAttribute("aria-label", localizationTable.closeSidebar(title));
      });
      this.listenForVisibilityChanges();
      this.sidebarContainer.replaceChildren(this.closeButton, this.sidebarContent);
      this.menuContainer.replaceChildren(this.sidebarContainer);
      parent.appendChild(this.menuContainer);
    }
    listenForVisibilityChanges() {
      let animationTimeout = null;
      const animationDuration = 170;
      if (!this.sidebarVisible.get()) {
        this.menuContainer.style.display = "none";
        this.menuContainer.style.opacity = "0";
      }
      const prefersReduceMotion = window.matchMedia?.("(prefers-reduced-motion: reduce)") ?? "";
      this.sidebarVisible.onUpdate((visible) => {
        const animationProperties = `${animationDuration}ms ease`;
        const reduceMotion = prefersReduceMotion.matches ? "-reduce-motion" : "";
        if (visible) {
          this.sidebarY.set(this.snappedSidebarY());
          if (animationTimeout) {
            clearTimeout(animationTimeout);
            animationTimeout = null;
          }
          this.menuContainer.style.display = "";
          this.sidebarContainer.style.animation = `${animationProperties} ${toolbarCSSPrefix}-edgemenu-transition-in${reduceMotion}`;
          this.menuContainer.style.animation = `${animationProperties} ${toolbarCSSPrefix}-edgemenu-container-transition-in${reduceMotion}`;
          this.menuContainer.style.opacity = "1";
          this.closeButton.focus({ preventScroll: true });
        } else {
          this.closeColorPickers();
          if (animationTimeout === null) {
            this.sidebarContainer.style.animation = `${animationProperties} ${toolbarCSSPrefix}-edgemenu-transition-out${reduceMotion}`;
            this.menuContainer.style.animation = `${animationProperties} ${toolbarCSSPrefix}-edgemenu-container-transition-out${reduceMotion}`;
            this.menuContainer.style.opacity = "0";
            this.editor.announceForAccessibility(this.localizationTable.dropdownHidden(this.sidebarTitle.get()));
            animationTimeout = setTimeout(() => {
              this.menuContainer.style.display = "none";
              this.menuContainer.style.overflowY = "";
              animationTimeout = null;
            }, animationDuration);
          }
        }
      });
    }
    onToolbarRowResize() {
      const setExtraPadding = () => {
        const visibleWidth = this.toolbarToolRow.clientWidth;
        let currentWidth = 0;
        let extraPadding = 0;
        let numVisibleButtons = 0;
        for (const child of this.toolbarToolRow.children) {
          const buttonBaseSize = child.clientHeight;
          currentWidth += buttonBaseSize;
          numVisibleButtons++;
          if (currentWidth > visibleWidth) {
            extraPadding = visibleWidth - currentWidth + buttonBaseSize / 2;
            if (extraPadding < 0) {
              extraPadding += buttonBaseSize;
            }
            break;
          }
        }
        const perButtonPadding = Math.round(extraPadding / numVisibleButtons * 10) / 10;
        this.toolbarToolRow.style.setProperty("--extra-left-right-padding", `${perButtonPadding}px`);
      };
      const actionRowBBox = this.toolbarActionRow.getBoundingClientRect();
      const toolbarRowBBox = this.toolbarToolRow.getBoundingClientRect();
      const onDifferentRows = actionRowBBox.y + actionRowBBox.height <= toolbarRowBBox.y;
      if (onDifferentRows) {
        this.toolbarContainer.classList.remove("one-row");
      } else {
        this.toolbarContainer.classList.add("one-row");
      }
      if (this.toolbarToolRow.clientWidth < this.toolbarToolRow.scrollWidth) {
        this.toolbarToolRow.classList.add("has-scroll");
        setExtraPadding();
      } else {
        this.toolbarToolRow.classList.remove("has-scroll", "extra-padding");
      }
    }
    addSpacer(_options) {
    }
    addUndoRedoButtons() {
      super.addUndoRedoButtons(false);
    }
    addDefaults() {
      this.addDefaultActionButtons();
      this.addDefaultToolWidgets();
    }
    updateWidgetCSSClasses(widget) {
      const tags = widget.getTags();
      widget.removeCSSClassFromContainer("label-inline");
      widget.removeCSSClassFromContainer("label-left");
      widget.removeCSSClassFromContainer("label-right");
      if (tags.includes(ToolbarWidgetTag.Save)) {
        widget.addCSSClassToContainer("label-inline");
        widget.addCSSClassToContainer("label-left");
      }
      if (tags.includes(ToolbarWidgetTag.Exit)) {
        widget.addCSSClassToContainer("label-inline");
        widget.addCSSClassToContainer("label-right");
      }
    }
    addWidgetInternal(widget) {
      this.updateWidgetCSSClasses(widget);
      widget.setLayoutManager(this.layoutManager);
      if (widget.mustBeInToplevelMenu()) {
        widget.addTo(this.toolbarActionRow);
      } else {
        widget.addTo(this.toolbarToolRow);
      }
    }
    removeWidgetInternal(widget) {
      widget.remove();
    }
    onRemove() {
      this.toolbarContainer.remove();
      this.menuContainer.remove();
      this.toolRowResizeObserver.disconnect();
      this.clearDragListeners?.();
    }
    initDragListeners() {
      const dragElements = [this.closeButton, this.sidebarContainer, this.sidebarContent];
      this.manageListener(this.editor.handlePointerEventsExceptClicksFrom(this.menuContainer, (eventName, event) => {
        if (event.target === this.menuContainer) {
          if (eventName === "pointerdown") {
            this.sidebarVisible.set(false);
            setTimeout(() => this.editor.focus(), 0);
          }
          return true;
        }
        if (!this.sidebarVisible.get()) {
          return true;
        }
        return false;
      }, (_eventName, event) => {
        return event.target === this.menuContainer;
      }));
      let lastGestureWasRoughlyClick = true;
      let gestureEndTimestamp = 0;
      const dragController = makeDraggable_default(this.sidebarContainer, {
        draggableChildElements: dragElements,
        onDrag: (deltaX, deltaY) => this.handleDrag(deltaX, deltaY),
        onDragEnd: (dragStatistics) => {
          gestureEndTimestamp = dragStatistics.endTimestamp;
          lastGestureWasRoughlyClick = dragStatistics.roughlyClick;
          this.finalizeDrag();
        }
      });
      this.clearDragListeners = () => dragController.removeListeners();
      this.closeButton.onclick = () => {
        const wasJustDragging = performance.now() - gestureEndTimestamp < 100;
        if (wasJustDragging && lastGestureWasRoughlyClick || !wasJustDragging) {
          this.sidebarVisible.set(false);
        }
      };
    }
    /**
     * Updates the position of this menu **during** a drag. After a drag ends,
     * {@link finalizeDrag} should be called.
     */
    handleDrag(_deltaX, deltaY) {
      this.sidebarContainer.style.transition = "none";
      this.sidebarY.set(this.sidebarY.get() + deltaY);
    }
    /** Returns `this.sidebarY` rounded to a valid value. */
    snappedSidebarY(sidebarY) {
      const y = sidebarY ?? this.sidebarY.get();
      const snapYs = [-100, 0];
      if (this.sidebarContainer.clientHeight > window.innerHeight) {
        snapYs.push(100);
      }
      let closestSnap = snapYs[0];
      for (const snapY of snapYs) {
        if (Math.abs(snapY - y) < Math.abs(closestSnap - y)) {
          closestSnap = snapY;
        }
      }
      return closestSnap;
    }
    /**
     * Moves the menu to a valid location or closes it, depending on
     * the position set by the drag.
     */
    finalizeDrag() {
      this.sidebarContainer.style.transition = "";
      if (this.sidebarY.get() > this.sidebarContainer.clientHeight / 2) {
        this.sidebarVisible.set(false);
      } else {
        this.sidebarY.set(this.snappedSidebarY());
      }
    }
    serializeInternal() {
      return {
        menuSizeY: this.snappedSidebarY()
      };
    }
    deserializeInternal(json) {
      if (typeof json === "object" && typeof json["menuSizeY"] === "number") {
        this.sidebarY.set(this.snappedSidebarY(json["menuSizeY"]));
      }
    }
  };

  // node_modules/js-draw/dist/mjs/tools/InputFilter/StrokeKeyboardControl.mjs
  var StrokeKeyboardControl = class _StrokeKeyboardControl extends InputMapper_default {
    constructor(shortcuts, viewport) {
      super();
      this.shortcuts = shortcuts;
      this.viewport = viewport;
      this.snapToGridEnabled = false;
      this.angleLockEnabled = false;
      this.startPointCanvas = null;
    }
    // Snap the given pointer to the nearer of the x/y axes.
    xyAxesSnap(pointer) {
      if (!this.startPointCanvas) {
        return pointer;
      }
      const screenPos = this.viewport.canvasToScreen(this.startPointCanvas);
      return pointer.lockedToXYAxesScreen(screenPos, this.viewport);
    }
    mapPointerEvent(event) {
      const mapPointer = (pointer) => {
        if (event.allPointers.length > 1) {
          return pointer;
        }
        if (this.snapToGridEnabled) {
          return pointer.snappedToGrid(this.viewport);
        }
        if (this.angleLockEnabled && this.startPointCanvas) {
          return this.xyAxesSnap(pointer);
        }
        return pointer;
      };
      return {
        kind: event.kind,
        current: mapPointer(event.current),
        allPointers: event.allPointers.map(mapPointer)
      };
    }
    onEvent(event) {
      const shortcuts = this.shortcuts;
      if (event.kind === InputEvtType.PointerDownEvt || event.kind === InputEvtType.PointerMoveEvt || event.kind === InputEvtType.PointerUpEvt) {
        if (event.kind === InputEvtType.PointerDownEvt) {
          this.startPointCanvas = event.current.canvasPos;
        }
        event = this.mapPointerEvent(event);
      }
      let handled = this.emit(event);
      if (
        // Always check keyUpEvents (in case we handled the corresponding keyDown event)
        event.kind === InputEvtType.KeyUpEvent || // Only handle key press events if another tool isn't handling it. We don't want
        // snap to grid/angle lock to conflict with selection/another tool's shortcuts.
        !handled && event.kind === InputEvtType.KeyPressEvent
      ) {
        const isKeyPress = event.kind === InputEvtType.KeyPressEvent;
        if (shortcuts.matchesShortcut(snapToGridKeyboardShortcutId, event)) {
          this.snapToGridEnabled = isKeyPress;
          handled = true;
        }
        if (shortcuts.matchesShortcut(lineLockKeyboardShortcutId, event)) {
          this.angleLockEnabled = isKeyPress;
          handled = true;
        }
      }
      return handled;
    }
    static fromEditor(editor) {
      return new _StrokeKeyboardControl(editor.shortcuts, editor.viewport);
    }
  };

  // node_modules/js-draw/dist/mjs/util/guessKeyCodeFromKey.mjs
  var keyToKeyCode = {
    Control: "ControlLeft",
    "=": "Equal",
    "-": "Minus",
    ";": "Semicolon",
    " ": "Space"
  };
  var guessKeyCodeFromKey = (key) => {
    const upperKey = key.toUpperCase();
    if ("A" <= upperKey && upperKey <= "Z") {
      return `Key${upperKey}`;
    }
    if ("0" <= key && key <= "9") {
      return `Digit${key}`;
    }
    if (key in keyToKeyCode) {
      return keyToKeyCode[key];
    }
    return key;
  };
  var guessKeyCodeFromKey_default = guessKeyCodeFromKey;

  // node_modules/js-draw/dist/mjs/dialogs/makeAboutDialog.mjs
  var makeAboutDialog2 = (editor, entries) => {
    const dialog = makeMessageDialog_default(editor, {
      title: editor.localization.about,
      contentClassNames: ["about-dialog-content"]
    });
    for (const entry of entries) {
      const container = document.createElement(entry.minimized ? "details" : "div");
      container.classList.add("about-entry");
      const header = document.createElement(entry.minimized ? "summary" : "h2");
      if (typeof entry.heading === "string") {
        header.innerText = entry.heading;
      } else {
        const link = document.createElement("a");
        link.href = entry.heading.href.replace(/^javascript:/i, "");
        link.text = entry.heading.text;
        header.appendChild(link);
      }
      container.appendChild(header);
      if (entry.text) {
        const bodyText = document.createElement("div");
        bodyText.innerText = entry.text;
        container.appendChild(bodyText);
      }
      dialog.appendChild(container);
    }
    return {
      close: () => {
        return dialog.close();
      }
    };
  };
  var makeAboutDialog_default = makeAboutDialog2;

  // node_modules/js-draw/dist/mjs/version.mjs
  var version_default = {
    // Note: Auto-updated by prebuild.js:
    number: "1.33.0"
  };

  // node_modules/js-draw/dist/mjs/image/export/adjustExportedSVGSize.mjs
  var adjustExportedSVGSize = (svg, exportRect, options) => {
    let width = exportRect.w;
    let height = exportRect.h;
    if (options?.minDimension && width < options.minDimension) {
      const newWidth = options.minDimension;
      height *= newWidth / (width || 1);
      width = newWidth;
    }
    if (options?.minDimension && height < options.minDimension) {
      const newHeight = options.minDimension;
      width *= newHeight / (height || 1);
      height = newHeight;
    }
    svg.setAttribute("width", toRoundedString(width));
    svg.setAttribute("height", toRoundedString(height));
  };
  var adjustExportedSVGSize_default = adjustExportedSVGSize;

  // node_modules/js-draw/dist/mjs/image/export/editorImageToSVG.mjs
  var toSVGInternal = (image, renderFunction, options) => {
    const importExportViewport = image.getImportExportViewport().getTemporaryClone();
    if (options?.minDimension) {
      const originalRect = importExportViewport.visibleRect;
      let rect = originalRect;
      if (rect.w <= 0) {
        rect = new Rect2(rect.x, rect.y, options.minDimension, rect.h);
      }
      if (rect.h <= 0) {
        rect = new Rect2(rect.x, rect.y, rect.w, options.minDimension);
      }
      if (!rect.eq(originalRect)) {
        importExportViewport.updateScreenSize(rect.size);
      }
    }
    const { element: result, renderer } = SVGRenderer.fromViewport(importExportViewport, {
      sanitize: options.sanitize ?? false,
      useViewBoxForPositioning: true
    });
    renderFunction(renderer, () => {
      if (image.getAutoresizeEnabled()) {
        result.classList.add(svgLoaderAutoresizeClassName);
      } else {
        result.classList.remove(svgLoaderAutoresizeClassName);
      }
      const exportRect = importExportViewport.visibleRect;
      adjustExportedSVGSize_default(result, exportRect, options);
      return result;
    });
    return result;
  };
  var editorImageToSVGSync = (image, options) => {
    return toSVGInternal(image, (renderer, onComplete) => {
      image.renderAll(renderer);
      onComplete();
    }, options);
  };
  var editorImageToSVGAsync = (image, preRenderComponent, options) => {
    return new Promise((resolve) => {
      toSVGInternal(image, async (renderer, onComplete) => {
        await image.renderAllAsync(renderer, preRenderComponent);
        const result = onComplete();
        resolve(result);
      }, options);
    });
  };

  // node_modules/js-draw/dist/mjs/util/dom/listenForKeyboardEventsFrom.mjs
  var listenForKeyboardEventsFrom = (elem, callbacks) => {
    let keysDown = [];
    const keyEventsMatch = (a, b) => {
      return a.key === b.key && a.code === b.code;
    };
    const isKeyDown = (keyEvent) => {
      return keysDown.some((other) => keyEventsMatch(other, keyEvent));
    };
    const keyEventToRecord = (event) => {
      return {
        code: event.code,
        key: event.key,
        ctrlKey: event.ctrlKey,
        altKey: event.altKey,
        shiftKey: event.shiftKey,
        metaKey: event.metaKey
      };
    };
    const handleKeyEvent = (htmlEvent) => {
      if (htmlEvent.type === "keydown") {
        if (!isKeyDown(htmlEvent)) {
          keysDown.push(keyEventToRecord(htmlEvent));
        }
        if (!callbacks.filter(htmlEvent)) {
          return;
        }
        callbacks.handleKeyDown(htmlEvent);
      } else {
        console.assert(htmlEvent.type === "keyup");
        keysDown = keysDown.filter((event) => {
          const matches = keyEventsMatch(event, htmlEvent);
          return !matches;
        });
        if (!callbacks.filter(htmlEvent)) {
          return;
        }
        callbacks.handleKeyUp(htmlEvent);
      }
    };
    elem.addEventListener("keydown", (htmlEvent) => {
      handleKeyEvent(htmlEvent);
    });
    elem.addEventListener("keyup", (htmlEvent) => {
      handleKeyEvent(htmlEvent);
    });
    elem.addEventListener("focusout", (focusEvent) => {
      let stillHasFocus = false;
      if (focusEvent.relatedTarget) {
        const relatedTarget = focusEvent.relatedTarget;
        stillHasFocus = elem.contains(relatedTarget) || callbacks.getHandlesKeyEventsFrom(relatedTarget);
      }
      if (!stillHasFocus) {
        for (const event of keysDown) {
          callbacks.handleKeyUp(new KeyboardEvent("keyup", {
            ...event
          }));
        }
        keysDown = [];
      }
    });
    const fireArtificalEventsBasedOn = (htmlEvent) => {
      let wasShiftDown = false;
      let wasCtrlDown = false;
      let wasAltDown = false;
      let wasMetaDown = false;
      for (const otherEvent of keysDown) {
        const code = otherEvent.code;
        wasShiftDown ||= !!code.match(/^Shift(Left|Right)$/);
        wasCtrlDown ||= !!code.match(/^Control(Left|Right)$/);
        wasAltDown ||= !!code.match(/^Alt(Left|Right)$/);
        wasMetaDown ||= !!code.match(/^Meta(Left|Right)$/);
      }
      const eventName = (isDown) => {
        if (isDown) {
          return "keydown";
        } else {
          return "keyup";
        }
      };
      const eventInitDefaults = {
        shiftKey: htmlEvent.shiftKey,
        altKey: htmlEvent.altKey,
        metaKey: htmlEvent.metaKey,
        ctrlKey: htmlEvent.ctrlKey
      };
      if (htmlEvent.shiftKey !== wasShiftDown) {
        handleKeyEvent(new KeyboardEvent(eventName(htmlEvent.shiftKey), {
          ...eventInitDefaults,
          key: "Shift",
          code: "ShiftLeft"
        }));
      }
      if (htmlEvent.altKey !== wasAltDown) {
        handleKeyEvent(new KeyboardEvent(eventName(htmlEvent.altKey), {
          ...eventInitDefaults,
          key: "Alt",
          code: "AltLeft"
        }));
      }
      if (htmlEvent.ctrlKey !== wasCtrlDown) {
        handleKeyEvent(new KeyboardEvent(eventName(htmlEvent.ctrlKey), {
          ...eventInitDefaults,
          key: "Control",
          code: "ControlLeft"
        }));
      }
      if (htmlEvent.metaKey !== wasMetaDown) {
        handleKeyEvent(new KeyboardEvent(eventName(htmlEvent.metaKey), {
          ...eventInitDefaults,
          key: "Meta",
          code: "MetaLeft"
        }));
      }
    };
    elem.addEventListener("mousedown", (htmlEvent) => {
      fireArtificalEventsBasedOn(htmlEvent);
    });
    elem.addEventListener("mousemove", (htmlEvent) => {
      fireArtificalEventsBasedOn(htmlEvent);
    });
  };
  var listenForKeyboardEventsFrom_default = listenForKeyboardEventsFrom;

  // node_modules/js-draw/dist/mjs/util/mitLicenseAttribution.mjs
  var mitLicenseAttribution = (copyright) => {
    const removeSingleLineBreaks = (text) => text.replace(/([^\n])[\n]([^\n])/g, "$1 $2");
    return removeSingleLineBreaks(`
MIT License

Copyright (c) ${copyright}

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.`);
  };
  var mitLicenseAttribution_default = mitLicenseAttribution;

  // node_modules/js-draw/dist/mjs/tools/InputFilter/ContextMenuRecognizer.mjs
  var ContextMenuRecognizer = class extends InputMapper_default {
    constructor() {
      super();
      this.canShowContextMenu = false;
      this.stationaryDetector = null;
      this.clickTolerance = 12;
    }
    /**
     * In general, only certain events (i.e. touchscreens) are expected to be able to
     * create long-press menus. This method checks whether `event` was generated by
     * one such device.
     */
    canMakeLongPressMenuEvent(event) {
      const allowedDevices = [PointerDevice.Touch];
      return event.allPointers.length === 1 && allowedDevices.includes(event.current.device);
    }
    onEvent(event) {
      const sendContextMenuEvent = () => {
        if (!isPointerEvt(event))
          return false;
        if (this.canShowContextMenu) {
          const eventHandled = this.emit({
            kind: InputEvtType.ContextMenu,
            screenPos: event.current.screenPos,
            canvasPos: event.current.canvasPos
          });
          if (eventHandled) {
            this.emit({
              kind: InputEvtType.GestureCancelEvt
            });
            return true;
          }
        }
        return false;
      };
      if (event.kind === InputEvtType.PointerDownEvt) {
        if (event.allPointers.length === 1) {
          this.canShowContextMenu = true;
          this.contextMenuTriggerPointer = event.current;
          this.contextMenuStartPoint = event.current.screenPos;
          if (this.canMakeLongPressMenuEvent(event)) {
            this.stationaryDetector = new StationaryPenDetector(event.current, defaultStationaryDetectionConfig, sendContextMenuEvent);
          }
        } else {
          this.canShowContextMenu = false;
        }
      } else if (event.kind === InputEvtType.PointerMoveEvt) {
        if (this.canShowContextMenu) {
          this.stationaryDetector?.onPointerMove(event.current);
          const deltaPosition = event.current.screenPos.minus(this.contextMenuStartPoint);
          const threshold = this.clickTolerance;
          if (deltaPosition.length() > threshold) {
            this.canShowContextMenu = false;
          }
        }
      } else if (event.kind === InputEvtType.PointerUpEvt) {
        this.stationaryDetector?.destroy();
        if (this.contextMenuTriggerPointer?.id === event.current.id && this.contextMenuTriggerPointer.device === PointerDevice.RightButtonMouse && sendContextMenuEvent()) {
          return true;
        }
      }
      return this.emit(event);
    }
  };

  // node_modules/js-draw/dist/mjs/Editor.mjs
  var Editor = class {
    /**
     * @example
     * ```ts,runnable
     * import { Editor } from 'js-draw';
     *
     * const container = document.body;
     *
     * // Create an editor
     * const editor = new Editor(container, {
     *   // 2e-10 and 1e12 are the default values for minimum/maximum zoom.
     *   minZoom: 2e-10,
     *   maxZoom: 1e12,
     * });
     *
     * // Add the default toolbar
     * const toolbar = editor.addToolbar();
     *
     * const createCustomIcon = () => {
     *   // Create/return an icon here.
     * };
     *
     * // Add a custom button
     * toolbar.addActionButton({
     *   label: 'Custom Button'
     *   icon: createCustomIcon(),
     * }, () => {
     *   // Do something here
     * });
     * ```
     */
    constructor(parent, settings = {}) {
      this.eventListenerTargets = [];
      this.previousAccessibilityAnnouncement = "";
      this.pointers = {};
      this.announceUndoCallback = (command) => {
        this.announceForAccessibility(this.localization.undoAnnouncement(command.description(this, this.localization)));
      };
      this.announceRedoCallback = (command) => {
        this.announceForAccessibility(this.localization.redoAnnouncement(command.description(this, this.localization)));
      };
      this.nextRerenderListeners = [];
      this.rerenderQueued = false;
      this.closeAboutDialog = null;
      this.localization = {
        ...getLocalizationTable_default(),
        ...settings.localization
      };
      this.settings = {
        wheelEventsEnabled: settings.wheelEventsEnabled ?? true,
        renderingMode: settings.renderingMode ?? RenderingMode.CanvasRenderer,
        localization: this.localization,
        minZoom: settings.minZoom ?? 2e-10,
        maxZoom: settings.maxZoom ?? 1e12,
        keyboardShortcutOverrides: settings.keyboardShortcutOverrides ?? {},
        iconProvider: settings.iconProvider ?? new IconProvider_default(),
        notices: settings.notices ?? [],
        appInfo: settings.appInfo ? { ...settings.appInfo } : null,
        pens: {
          additionalPenTypes: settings.pens?.additionalPenTypes ?? [],
          filterPenTypes: settings.pens?.filterPenTypes ?? (() => true)
        },
        text: {
          fonts: settings.text?.fonts ?? ["sans-serif", "serif", "monospace"]
        },
        image: {
          showImagePicker: settings.image?.showImagePicker ?? void 0
        },
        svg: {
          loaderPlugins: settings.svg?.loaderPlugins ?? []
        },
        clipboardApi: settings.clipboardApi ?? null
      };
      if (this.settings.minZoom > this.settings.maxZoom) {
        throw new Error("Minimum zoom must be lesser than maximum zoom!");
      }
      this.readOnly = MutableReactiveValue.fromInitialValue(false);
      this.icons = this.settings.iconProvider;
      this.shortcuts = new KeyboardShortcutManager_default(this.settings.keyboardShortcutOverrides);
      this.container = document.createElement("div");
      this.renderingRegion = document.createElement("div");
      this.container.appendChild(this.renderingRegion);
      this.container.classList.add("imageEditorContainer", "js-draw");
      this.loadingWarning = document.createElement("div");
      this.loadingWarning.classList.add("loadingMessage");
      this.loadingWarning.ariaLive = "polite";
      this.container.appendChild(this.loadingWarning);
      this.accessibilityControlArea = document.createElement("textarea");
      this.accessibilityControlArea.setAttribute("placeholder", this.localization.accessibilityInputInstructions);
      this.accessibilityControlArea.style.opacity = "0";
      this.accessibilityControlArea.style.width = "0";
      this.accessibilityControlArea.style.height = "0";
      this.accessibilityControlArea.style.position = "absolute";
      this.accessibilityAnnounceArea = document.createElement("div");
      this.accessibilityAnnounceArea.setAttribute("aria-live", "assertive");
      this.accessibilityAnnounceArea.className = "accessibilityAnnouncement";
      this.container.appendChild(this.accessibilityAnnounceArea);
      this.renderingRegion.style.touchAction = "none";
      this.renderingRegion.className = "imageEditorRenderArea";
      this.renderingRegion.appendChild(this.accessibilityControlArea);
      this.renderingRegion.setAttribute("tabIndex", "0");
      this.renderingRegion.setAttribute("alt", "");
      this.notifier = new EventDispatcher();
      this.viewport = new Viewport_default((oldTransform, newTransform) => {
        this.notifier.dispatch(EditorEventType.ViewportChanged, {
          kind: EditorEventType.ViewportChanged,
          newTransform,
          oldTransform
        });
      });
      this.display = new Display(this, this.settings.renderingMode, this.renderingRegion);
      this.image = new EditorImage_default();
      this.history = new UndoRedoHistory_default(this, this.announceRedoCallback, this.announceUndoCallback);
      this.toolController = new ToolController(this, this.localization);
      this.toolController.addInputMapper(StrokeKeyboardControl.fromEditor(this));
      this.toolController.addInputMapper(new ContextMenuRecognizer());
      parent.appendChild(this.container);
      this.viewport.updateScreenSize(Vec2.of(this.display.width, this.display.height));
      this.registerListeners();
      this.queueRerender();
      this.hideLoadingWarning();
      this.notifier.on(EditorEventType.ViewportChanged, (evt) => {
        if (evt.kind !== EditorEventType.ViewportChanged)
          return;
        const getZoom = (mat) => mat.transformVec3(Vec2.unitX).length();
        const zoom = getZoom(evt.newTransform);
        if (zoom > this.settings.maxZoom || zoom < this.settings.minZoom) {
          const oldZoom = getZoom(evt.oldTransform);
          let resetTransform = Mat33.identity;
          if (oldZoom <= this.settings.maxZoom && oldZoom >= this.settings.minZoom) {
            resetTransform = evt.oldTransform;
          } else {
            resetTransform = Mat33.scaling2D((this.settings.minZoom + this.settings.maxZoom) / 2);
          }
          this.viewport.resetTransform(resetTransform);
        } else if (!isFinite(zoom)) {
          console.warn(`Non-finite zoom (${zoom}) detected. Resetting the viewport. This was likely caused by division by zero.`);
          if (isFinite(getZoom(evt.oldTransform))) {
            this.viewport.resetTransform(evt.oldTransform);
          } else {
            this.viewport.resetTransform();
          }
        }
      });
    }
    /**
     * @returns a shallow copy of the current settings of the editor.
     *
     * Do not modify.
     */
    getCurrentSettings() {
      return {
        ...this.settings
      };
    }
    /**
     * @returns a reference to the editor's container.
     *
     * @example
     * ```
     *   // Set the editor's height to 500px
     *   editor.getRootElement().style.height = '500px';
     * ```
     */
    getRootElement() {
      return this.container;
    }
    /**
     * @returns the bounding box of the main rendering region of the editor in the HTML viewport.
     *
     * @internal
     */
    getOutputBBoxInDOM() {
      return Rect2.of(this.renderingRegion.getBoundingClientRect());
    }
    /**
     * Shows a "Loading..." message.
     * @param fractionLoaded - should be a number from 0 to 1, where 1 represents completely loaded.
     */
    showLoadingWarning(fractionLoaded) {
      const loadingPercent = Math.round(fractionLoaded * 100);
      this.loadingWarning.innerText = this.localization.loading(loadingPercent);
      this.loadingWarning.style.display = "block";
    }
    /** @see {@link showLoadingWarning} */
    hideLoadingWarning() {
      this.loadingWarning.style.display = "none";
      this.announceForAccessibility(this.localization.doneLoading);
    }
    /**
     * Announce `message` for screen readers. If `message` is the same as the previous
     * message, it is re-announced.
     */
    announceForAccessibility(message) {
      if (message === this.previousAccessibilityAnnouncement) {
        message = message + ". ";
      }
      this.accessibilityAnnounceArea.innerText = message;
      this.previousAccessibilityAnnouncement = message;
    }
    /**
     * Creates a toolbar. If `defaultLayout` is true, default buttons are used.
     * @returns a reference to the toolbar.
     */
    addToolbar(defaultLayout = true) {
      const toolbar = new EdgeToolbar(this, this.container, this.localization);
      if (defaultLayout) {
        toolbar.addDefaults();
      }
      return toolbar;
    }
    registerListeners() {
      this.handlePointerEventsFrom(this.renderingRegion);
      this.handleKeyEventsFrom(this.renderingRegion);
      this.handlePointerEventsFrom(this.accessibilityAnnounceArea);
      const preventSelectionOf = [
        this.renderingRegion,
        this.accessibilityAnnounceArea,
        this.accessibilityControlArea,
        this.loadingWarning
      ];
      for (const element of preventSelectionOf) {
        element.addEventListener("drag", (event) => {
          event.preventDefault();
          return false;
        });
        element.addEventListener("dragstart", (event) => {
          event.preventDefault();
          return false;
        });
      }
      this.container.addEventListener("wheel", (evt) => {
        this.handleHTMLWheelEvent(evt);
      });
      const handleResize = () => {
        this.viewport.updateScreenSize(Vec2.of(this.display.width, this.display.height));
        this.rerender();
        this.updateEditorSizeVariables();
      };
      if ("ResizeObserver" in window) {
        const resizeObserver = new ResizeObserver(handleResize);
        resizeObserver.observe(this.renderingRegion);
        resizeObserver.observe(this.container);
      } else {
        addEventListener("resize", handleResize);
      }
      this.accessibilityControlArea.addEventListener("input", () => {
        this.accessibilityControlArea.value = "";
      });
      const copyHandler = new ClipboardHandler_default(this);
      document.addEventListener("copy", async (evt) => {
        if (!this.isEventSink(document.querySelector(":focus"))) {
          return;
        }
        copyHandler.copy(evt);
      });
      document.addEventListener("paste", (evt) => {
        this.handlePaste(evt);
      });
    }
    updateEditorSizeVariables() {
      this.container.style.setProperty("--editor-current-width-px", `${this.container.clientWidth}px`);
      this.container.style.setProperty("--editor-current-height-px", `${this.container.clientHeight}px`);
      this.container.style.setProperty("--editor-current-display-width-px", `${this.renderingRegion.clientWidth}px`);
      this.container.style.setProperty("--editor-current-display-height-px", `${this.renderingRegion.clientHeight}px`);
    }
    /** @internal */
    handleHTMLWheelEvent(event) {
      let delta = Vec3.of(event.deltaX, event.deltaY, event.deltaZ);
      if (!event.ctrlKey && !event.metaKey) {
        if (!this.settings.wheelEventsEnabled) {
          return;
        } else if (this.settings.wheelEventsEnabled === "only-if-focused") {
          const focusedChild = this.container.querySelector(":focus");
          if (!focusedChild) {
            return;
          }
        }
      }
      if (event.deltaMode === WheelEvent.DOM_DELTA_LINE) {
        delta = delta.times(15);
      } else if (event.deltaMode === WheelEvent.DOM_DELTA_PAGE) {
        delta = delta.times(100);
      }
      if (event.ctrlKey || event.metaKey) {
        delta = Vec3.of(0, 0, event.deltaY);
      }
      const bbox = this.getOutputBBoxInDOM();
      const pos = Vec2.of(event.clientX, event.clientY).minus(bbox.topLeft);
      if (this.toolController.dispatchInputEvent({
        kind: InputEvtType.WheelEvt,
        delta,
        screenPos: pos
      })) {
        event.preventDefault();
        return true;
      }
      return false;
    }
    getPointerList() {
      const nowTime = performance.now();
      const res = [];
      for (const id in this.pointers) {
        const maxUnupdatedTime = 2e3;
        if (this.pointers[id] && nowTime - this.pointers[id].timeStamp < maxUnupdatedTime) {
          res.push(this.pointers[id]);
        }
      }
      return res;
    }
    /**
     * A protected method that can override setPointerCapture in environments where it may fail
     * (e.g. with synthetic events). @internal
     */
    setPointerCapture(target, pointer) {
      if ("__mockEvent" in pointer)
        return;
      try {
        target.setPointerCapture(pointer.pointerId);
      } catch (error) {
        console.warn("Failed to setPointerCapture", error);
      }
    }
    /** Can be overridden in a testing environment to handle synthetic events. @internal */
    releasePointerCapture(target, pointer) {
      if ("__mockEvent" in pointer)
        return;
      try {
        target.releasePointerCapture(pointer.pointerId);
      } catch (error) {
        console.warn("Failed to releasePointerCapture", error);
      }
    }
    /**
     * Dispatches a `PointerEvent` to the editor. The target element for `evt` must have the same top left
     * as the content of the editor.
     */
    handleHTMLPointerEvent(eventType, evt) {
      const eventsRelativeTo = this.renderingRegion;
      const eventTarget = evt.target ?? this.renderingRegion;
      this.display.onPointerEvent(evt);
      if (eventType === "pointerdown") {
        const pointer = Pointer.ofEvent(evt, true, this.viewport, eventsRelativeTo);
        this.pointers[pointer.id] = pointer;
        this.setPointerCapture(eventTarget, evt);
        const event = {
          kind: InputEvtType.PointerDownEvt,
          current: pointer,
          allPointers: this.getPointerList()
        };
        this.toolController.dispatchInputEvent(event);
        return true;
      } else if (eventType === "pointermove") {
        const pointer = Pointer.ofEvent(evt, this.pointers[evt.pointerId]?.down ?? false, this.viewport, eventsRelativeTo);
        if (pointer.down) {
          const prevData = this.pointers[pointer.id];
          if (prevData) {
            const distanceMoved = pointer.screenPos.distanceTo(prevData.screenPos);
            if (distanceMoved < 2) {
              return false;
            }
          }
          this.pointers[pointer.id] = pointer;
          if (this.toolController.dispatchInputEvent({
            kind: InputEvtType.PointerMoveEvt,
            current: pointer,
            allPointers: this.getPointerList()
          })) {
            evt.preventDefault();
          }
        }
        return true;
      } else if (eventType === "pointercancel" || eventType === "pointerup") {
        const pointer = Pointer.ofEvent(evt, false, this.viewport, eventsRelativeTo);
        if (!this.pointers[pointer.id]) {
          return false;
        }
        this.pointers[pointer.id] = pointer;
        this.releasePointerCapture(eventTarget, evt);
        if (this.toolController.dispatchInputEvent({
          kind: InputEvtType.PointerUpEvt,
          current: pointer,
          allPointers: this.getPointerList()
        })) {
          evt.preventDefault();
        }
        delete this.pointers[pointer.id];
        return true;
      }
      return eventType;
    }
    isEventSink(evtTarget) {
      let currentElem = evtTarget;
      while (currentElem !== null) {
        for (const elem of this.eventListenerTargets) {
          if (elem === currentElem) {
            return true;
          }
        }
        currentElem = currentElem.parentElement;
      }
      return false;
    }
    /** @internal */
    async handleDrop(evt) {
      evt.preventDefault();
      await this.handlePaste(evt);
    }
    /** @internal */
    async handlePaste(evt) {
      const target = document.querySelector(":focus") ?? evt.target;
      if (!this.isEventSink(target)) {
        return;
      }
      return await new ClipboardHandler_default(this).paste(evt);
    }
    /**
     * Forward pointer events from `elem` to this editor. Such that right-click/right-click drag
     * events are also forwarded, `elem`'s contextmenu is disabled.
     *
     * `filter` is called once per pointer event, before doing any other processing. If `filter` returns `true` the event is
     * forwarded to the editor.
     *
     * **Note**: `otherEventsFilter` is like `filter`, but is called for other pointer-related
     * events that could also be forwarded to the editor. To forward just pointer events,
     * for example, `otherEventsFilter` could be given as `()=>false`.
     *
     * @example
     * ```ts
     * const overlay = document.createElement('div');
     * editor.createHTMLOverlay(overlay);
     *
     * // Send all pointer events that don't have the control key pressed
     * // to the editor.
     * editor.handlePointerEventsFrom(overlay, (event) => {
     *   if (event.ctrlKey) {
     *     return false;
     *   }
     *   return true;
     * });
     * ```
     */
    handlePointerEventsFrom(elem, filter, otherEventsFilter) {
      const touchstartListener = (evt) => {
        if (otherEventsFilter && !otherEventsFilter("touchstart", evt)) {
          return;
        }
        evt.preventDefault();
      };
      const contextmenuListener = (evt) => {
        if (otherEventsFilter && !otherEventsFilter("contextmenu", evt)) {
          return;
        }
        evt.preventDefault();
      };
      const listeners = {
        touchstart: touchstartListener,
        contextmenu: contextmenuListener
      };
      const eventNames = [
        "pointerdown",
        "pointermove",
        "pointerup",
        "pointercancel"
      ];
      for (const eventName of eventNames) {
        listeners[eventName] = (evt) => {
          const event = evt;
          if (filter && !filter(eventName, event)) {
            return void 0;
          }
          return this.handleHTMLPointerEvent(eventName, event);
        };
      }
      for (const eventName in listeners) {
        elem.addEventListener(eventName, listeners[eventName]);
      }
      return {
        /** Remove all event listeners registered by this function. */
        remove: () => {
          for (const eventName in listeners) {
            elem.removeEventListener(eventName, listeners[eventName]);
          }
        }
      };
    }
    /**
     * Like {@link handlePointerEventsFrom} except ignores short input gestures like clicks.
     *
     * `filter` is called once per event, before doing any other processing. If `filter` returns `true` the event is
     * forwarded to the editor.
     *
     * `otherEventsFilter` is passed unmodified to `handlePointerEventsFrom`.
     */
    handlePointerEventsExceptClicksFrom(elem, filter, otherEventsFilter) {
      const gestureData = /* @__PURE__ */ Object.create(null);
      return this.handlePointerEventsFrom(elem, (eventName, event) => {
        if (filter && !filter(eventName, event)) {
          return false;
        }
        const currentPos = Vec2.of(event.pageX ?? event.clientX, event.pageY ?? event.clientY);
        const pointerId = event.pointerId ?? 0;
        let sendToEditor = true;
        if (eventName === "pointerdown") {
          gestureData[pointerId] = {
            eventBuffer: [[eventName, event]],
            startPoint: currentPos,
            hasMovedSignificantly: false
          };
          this.setPointerCapture(elem, event);
          sendToEditor = false;
        } else if (eventName === "pointermove" && gestureData[pointerId]) {
          const gestureStartPos = gestureData[pointerId].startPoint;
          const eventBuffer = gestureData[pointerId].eventBuffer;
          const strokeStartThreshold = 10;
          const isWithinClickThreshold = gestureStartPos && currentPos.distanceTo(gestureStartPos) < strokeStartThreshold;
          if (isWithinClickThreshold && !gestureData[pointerId].hasMovedSignificantly) {
            eventBuffer.push([eventName, event]);
            sendToEditor = false;
          } else {
            for (const [eventName2, event2] of eventBuffer) {
              this.handleHTMLPointerEvent(eventName2, event2);
            }
            gestureData[pointerId].eventBuffer = [];
            gestureData[pointerId].hasMovedSignificantly = true;
            sendToEditor = true;
          }
        } else if (eventName === "pointermove") {
          sendToEditor = true;
        } else if ((eventName === "pointerup" || eventName === "pointercancel") && gestureData[pointerId] && gestureData[pointerId].eventBuffer.length > 0) {
          this.releasePointerCapture(elem, event);
          sendToEditor = false;
          delete gestureData[pointerId];
        }
        return sendToEditor;
      }, otherEventsFilter);
    }
    /** @internal */
    handleHTMLKeyDownEvent(htmlEvent) {
      console.assert(htmlEvent.type === "keydown", `handling a keydown event with type ${htmlEvent.type}`);
      const event = keyPressEventFromHTMLEvent(htmlEvent);
      if (this.toolController.dispatchInputEvent(event)) {
        htmlEvent.preventDefault();
        return true;
      } else if (event.key === "t" || event.key === "T") {
        htmlEvent.preventDefault();
        this.display.rerenderAsText();
        return true;
      } else if (event.key === "Escape") {
        this.renderingRegion.blur();
        return true;
      }
      return false;
    }
    /** @internal */
    handleHTMLKeyUpEvent(htmlEvent) {
      console.assert(htmlEvent.type === "keyup", `Handling a keyup event with type ${htmlEvent.type}`);
      const event = keyUpEventFromHTMLEvent(htmlEvent);
      if (this.toolController.dispatchInputEvent(event)) {
        htmlEvent.preventDefault();
        return true;
      }
      return false;
    }
    /**
     * Adds event listners for keypresses (and drop events) on `elem` and forwards those
     * events to the editor.
     *
     * If the given `filter` returns `false` for an event, the event is ignored and not
     * passed to the editor.
     */
    handleKeyEventsFrom(elem, filter = () => true) {
      listenForKeyboardEventsFrom_default(elem, {
        filter,
        handleKeyDown: (htmlEvent) => {
          this.handleHTMLKeyDownEvent(htmlEvent);
        },
        handleKeyUp: (htmlEvent) => {
          this.handleHTMLKeyUpEvent(htmlEvent);
        },
        getHandlesKeyEventsFrom: (element) => {
          return this.eventListenerTargets.includes(element);
        }
      });
      elem.ondragover = (evt) => {
        evt.preventDefault();
      };
      elem.ondrop = (evt) => {
        this.handleDrop(evt);
      };
      this.eventListenerTargets.push(elem);
    }
    /**
     * Attempts to prevent **user-triggered** events from modifying
     * the content of the image.
     */
    setReadOnly(readOnly) {
      if (readOnly !== this.readOnly.get()) {
        this.readOnly.set(readOnly);
        this.notifier.dispatch(EditorEventType.ReadOnlyModeToggled, {
          kind: EditorEventType.ReadOnlyModeToggled,
          editorIsReadOnly: readOnly
        });
      }
    }
    // @internal
    isReadOnlyReactiveValue() {
      return this.readOnly;
    }
    isReadOnly() {
      return this.readOnly;
    }
    /**
     * `apply` a command. `command` will be announced for accessibility.
     *
     * **Example**:
     * [[include:doc-pages/inline-examples/adding-a-stroke.md]]
     */
    dispatch(command, addToHistory = true) {
      const dispatchResult = this.dispatchNoAnnounce(command, addToHistory);
      const commandDescription = command.description(this, this.localization);
      this.announceForAccessibility(commandDescription);
      return dispatchResult;
    }
    /**
     * Dispatches a command without announcing it. By default, does not add to history.
     * Use this to show finalized commands that don't need to have `announceForAccessibility`
     * called.
     *
     * If `addToHistory` is `false`, this is equivalent to `command.apply(editor)`.
     *
     * @example
     * ```
     * const addToHistory = false;
     * editor.dispatchNoAnnounce(editor.viewport.zoomTo(someRectangle), addToHistory);
     * ```
     */
    dispatchNoAnnounce(command, addToHistory = false) {
      const result = command.apply(this);
      if (addToHistory) {
        const apply = false;
        this.history.push(command, apply);
      }
      return result;
    }
    /**
     * Apply a large transformation in chunks.
     * If `apply` is `false`, the commands are unapplied.
     * Triggers a re-render after each `updateChunkSize`-sized group of commands
     * has been applied.
     */
    async asyncApplyOrUnapplyCommands(commands, apply, updateChunkSize2) {
      console.assert(updateChunkSize2 > 0);
      this.display.setDraftMode(true);
      for (let i = 0; i < commands.length; i += updateChunkSize2) {
        this.showLoadingWarning(i / commands.length);
        for (let j = i; j < commands.length && j < i + updateChunkSize2; j++) {
          const cmd = commands[j];
          if (apply) {
            cmd.apply(this);
          } else {
            cmd.unapply(this);
          }
        }
        if (i + updateChunkSize2 < commands.length) {
          await new Promise((resolve) => {
            this.rerender();
            requestAnimationFrame(resolve);
          });
        }
      }
      this.display.setDraftMode(false);
      this.hideLoadingWarning();
    }
    /** @see {@link asyncApplyOrUnapplyCommands } */
    asyncApplyCommands(commands, chunkSize) {
      return this.asyncApplyOrUnapplyCommands(commands, true, chunkSize);
    }
    /**
     * @see {@link asyncApplyOrUnapplyCommands}
     *
     * If `unapplyInReverseOrder`, commands are reversed before unapplying.
     */
    asyncUnapplyCommands(commands, chunkSize, unapplyInReverseOrder = false) {
      if (unapplyInReverseOrder) {
        commands = [...commands];
        commands.reverse();
      }
      return this.asyncApplyOrUnapplyCommands(commands, false, chunkSize);
    }
    /**
     * Schedule a re-render for some time in the near future. Does not schedule an additional
     * re-render if a re-render is already queued.
     *
     * @returns a promise that resolves when re-rendering has completed.
     */
    queueRerender() {
      if (!this.rerenderQueued) {
        this.rerenderQueued = true;
        requestAnimationFrame(() => {
          if (this.rerenderQueued) {
            this.rerender();
            this.rerenderQueued = false;
          }
        });
      }
      return new Promise((resolve) => {
        this.nextRerenderListeners.push(() => resolve());
      });
    }
    // @internal
    isRerenderQueued() {
      return this.rerenderQueued;
    }
    /**
     * Re-renders the entire image.
     *
     * @see {@link Editor.queueRerender}
     */
    rerender(showImageBounds = true) {
      this.display.startRerender();
      if (this.display.width === 0 || this.display.height === 0) {
        return;
      }
      const renderer = this.display.getDryInkRenderer();
      this.image.renderWithCache(renderer, this.display.getCache(), this.viewport);
      if (showImageBounds && !this.image.getAutoresizeEnabled()) {
        const exportRectFill = { fill: Color4.fromHex("#44444455") };
        const exportRectStrokeWidth = 5 * this.viewport.getSizeOfPixelOnCanvas();
        renderer.drawRect(this.getImportExportRect(), exportRectStrokeWidth, exportRectFill);
      }
      this.rerenderQueued = false;
      this.nextRerenderListeners.forEach((listener) => listener());
      this.nextRerenderListeners = [];
    }
    /**
     * Draws the given path onto the wet ink renderer. The given path will
     * be displayed on top of the main image.
     *
     * @see {@link Display.getWetInkRenderer} {@link Display.flatten}
     */
    drawWetInk(...path) {
      for (const part of path) {
        this.display.getWetInkRenderer().drawPath(part);
      }
    }
    /**
     * Clears the wet ink display.
     *
     * The wet ink display can be used by the currently active tool to display a preview
     * of an in-progress action.
     *
     * @see {@link Display.getWetInkRenderer}
     */
    clearWetInk() {
      this.display.getWetInkRenderer().clear();
    }
    /**
     * Focuses the region used for text input/key commands.
     */
    focus() {
      this.renderingRegion.focus();
    }
    /**
     * Creates an element that will be positioned on top of the dry/wet ink
     * renderers.
     *
     * So as not to change the position of other overlays, `overlay` should either
     * be styled to have 0 height or have `position: absolute`.
     *
     * This is useful for displaying content on top of the rendered content
     * (e.g. a selection box).
     */
    createHTMLOverlay(overlay) {
      overlay.classList.add("overlay", "js-draw-editor-overlay");
      this.container.appendChild(overlay);
      return {
        remove: () => overlay.remove()
      };
    }
    /**
     * Anchors the given `element` to the canvas with a given position/transformation in canvas space.
     */
    anchorElementToCanvas(element, canvasTransform) {
      if (canvasTransform instanceof Mat33) {
        canvasTransform = ReactiveValue_default.fromImmutable(canvasTransform);
      }
      const overlay = document.createElement("div");
      overlay.classList.add("anchored-element-overlay");
      const contentWrapper = document.createElement("div");
      contentWrapper.classList.add("content-wrapper");
      element.classList.add("content");
      const updateElementPositioning = () => {
        const transform = canvasTransform.get();
        const canvasRotation = transform.transformVec3(Vec2.unitX).angle();
        const screenRotation = canvasRotation + this.viewport.getRotationAngle();
        const screenTransform = this.viewport.canvasToScreenTransform.rightMul(canvasTransform.get());
        overlay.style.setProperty("--full-transform", screenTransform.toCSSMatrix());
        const translation = screenTransform.transformVec2(Vec2.zero);
        overlay.style.setProperty("--position-x", `${translation.x}px`);
        overlay.style.setProperty("--position-y", `${translation.y}px`);
        overlay.style.setProperty("--rotation", `${screenRotation * 180 / Math.PI}deg`);
        overlay.style.setProperty("--scale", `${screenTransform.getScaleFactor()}`);
      };
      updateElementPositioning();
      const updateListener = canvasTransform.onUpdate(updateElementPositioning);
      const viewportListener = this.notifier.on(EditorEventType.ViewportChanged, updateElementPositioning);
      contentWrapper.appendChild(element);
      overlay.appendChild(contentWrapper);
      overlay.classList.add("overlay", "js-draw-editor-overlay");
      this.renderingRegion.insertAdjacentElement("afterend", overlay);
      return {
        remove: () => {
          overlay.remove();
          updateListener.remove();
          viewportListener.remove();
        }
      };
    }
    /**
     * Creates a CSS stylesheet with `content` and applies it to the document
     * (and thus, to this editor).
     */
    addStyleSheet(content) {
      const styleSheet = document.createElement("style");
      styleSheet.innerText = content;
      this.container.appendChild(styleSheet);
      return styleSheet;
    }
    /**
     * Dispatch a keyboard event to the currently selected tool.
     * Intended for unit testing.
     *
     * If `shiftKey` is undefined, it is guessed from `key`.
     *
     * At present, the **key code** dispatched is guessed from the given key and,
     * while this works for ASCII alphanumeric characters, this does not work for
     * most non-alphanumeric keys.
     *
     * Because guessing the key code from `key` is problematic, **only use this for testing**.
     */
    sendKeyboardEvent(eventType, key, ctrlKey = false, altKey = false, shiftKey = void 0) {
      shiftKey ??= key.toUpperCase() === key && key.toLowerCase() !== key;
      this.toolController.dispatchInputEvent({
        kind: eventType,
        key,
        code: guessKeyCodeFromKey_default(key),
        ctrlKey,
        altKey,
        shiftKey
      });
    }
    /**
     * Dispatch a pen event to the currently selected tool.
     * Intended primarially for unit tests.
     *
     * @deprecated
     * @see {@link sendPenEvent} {@link sendTouchEvent}
     */
    sendPenEvent(eventType, point, allPointers) {
      sendPenEvent_default(this, eventType, point, allPointers);
    }
    /**
     * Adds all components in `components` such that they are in the center of the screen.
     * This is a convenience method that creates **and applies** a single command.
     *
     * If `selectComponents` is true (the default), the components are selected.
     *
     * `actionDescription`, if given, should be a screenreader-friendly description of the
     * reason components were added (e.g. "pasted").
     */
    async addAndCenterComponents(components, selectComponents = true, actionDescription) {
      let bbox = null;
      for (const component of components) {
        if (bbox) {
          bbox = bbox.union(component.getBBox());
        } else {
          bbox = component.getBBox();
        }
      }
      if (!bbox) {
        return;
      }
      const visibleRect = this.viewport.visibleRect;
      const scaleRatioX = visibleRect.width / bbox.width;
      const scaleRatioY = visibleRect.height / bbox.height;
      let scaleRatio = scaleRatioX;
      if (bbox.width * scaleRatio > visibleRect.width || bbox.height * scaleRatio > visibleRect.height) {
        scaleRatio = scaleRatioY;
      }
      scaleRatio *= 2 / 3;
      scaleRatio = Viewport_default.roundScaleRatio(scaleRatio);
      const transfm = Mat33.translation(visibleRect.center.minus(bbox.center)).rightMul(Mat33.scaling2D(scaleRatio, bbox.center));
      const commands = [];
      for (const component of components) {
        commands.push(EditorImage_default.addComponent(component));
        commands.push(component.transformBy(transfm));
      }
      const applyChunkSize = 100;
      await this.dispatch(uniteCommands_default(commands, { applyChunkSize, description: actionDescription }), true);
      if (selectComponents) {
        for (const selectionTool of this.toolController.getMatchingTools(SelectionTool)) {
          selectionTool.setEnabled(true);
          selectionTool.setSelection(components);
        }
      }
    }
    /**
     * Get a data URL (e.g. as produced by `HTMLCanvasElement::toDataURL`).
     * If `format` is not `image/png`, a PNG image URL may still be returned (as in the
     * case of `HTMLCanvasElement::toDataURL`).
     *
     * The export resolution is the same as the size of the drawing canvas, unless `outputSize`
     * is given.
     *
     * **Example**:
     * [[include:doc-pages/inline-examples/adding-an-image-and-data-urls.md]]
     */
    toDataURL(format = "image/png", outputSize) {
      const { element: canvas, renderer } = CanvasRenderer.fromViewport(this.image.getImportExportViewport(), { canvasSize: outputSize });
      this.image.renderAll(renderer);
      const dataURL = canvas.toDataURL(format);
      return dataURL;
    }
    /**
     * Converts the editor's content into an SVG image.
     *
     * If the output SVG has width or height less than `options.minDimension`, its size
     * will be increased.
     *
     * @see
     * {@link SVGRenderer}
     */
    toSVG(options) {
      return editorImageToSVGSync(this.image, options ?? {});
    }
    /**
     * Converts the editor's content into an SVG image in an asynchronous,
     * but **potentially lossy** way.
     *
     * **Warning**: If the image is being edited during an async rendering, edited components
     * may not be rendered.
     *
     * Like {@link toSVG}, but can be configured to briefly pause after processing every
     * `pauseAfterCount` items. This can prevent the editor from becoming unresponsive
     * when saving very large images.
     */
    async toSVGAsync(options = {}) {
      const pauseAfterCount = options.pauseAfterCount ?? 100;
      return await editorImageToSVGAsync(this.image, async (_component, processedCount, totalComponents) => {
        if (options.onProgress) {
          const shouldContinue = await options.onProgress(processedCount, totalComponents);
          if (shouldContinue === false) {
            return false;
          }
        }
        if (processedCount % pauseAfterCount === 0) {
          await untilNextAnimationFrame_default();
        }
        return true;
      }, {
        minDimension: options.minDimension
      });
    }
    /**
     * Load editor data from an `ImageLoader` (e.g. an {@link SVGLoader}).
     *
     * @see loadFromSVG
     */
    async loadFrom(loader) {
      this.showLoadingWarning(0);
      this.display.setDraftMode(true);
      const originalBackgrounds = this.image.getBackgroundComponents();
      const eraseBackgroundCommand = new Erase_default(originalBackgrounds);
      await loader.start(async (component) => {
        await this.dispatchNoAnnounce(EditorImage_default.addComponent(component));
      }, (countProcessed, totalToProcess) => {
        if (countProcessed % 500 === 0) {
          this.showLoadingWarning(countProcessed / totalToProcess);
          this.rerender();
          return untilNextAnimationFrame_default();
        }
        return null;
      }, (importExportRect, options) => {
        this.dispatchNoAnnounce(this.setImportExportRect(importExportRect), false);
        this.dispatchNoAnnounce(this.viewport.zoomTo(importExportRect), false);
        if (options) {
          this.dispatchNoAnnounce(this.image.setAutoresizeEnabled(options.autoresize), false);
        }
      });
      if (this.image.getBackgroundComponents().length !== originalBackgrounds.length) {
        await this.dispatchNoAnnounce(eraseBackgroundCommand);
      }
      this.hideLoadingWarning();
      this.display.setDraftMode(false);
      this.queueRerender();
    }
    getTopmostBackgroundComponent() {
      let background = null;
      for (const component of this.image.getBackgroundComponents()) {
        if (component instanceof BackgroundComponent) {
          background = component;
        }
      }
      return background;
    }
    /**
     * This is a convenience method for adding or updating the {@link BackgroundComponent}
     * and {@link EditorImage.setAutoresizeEnabled} for the current image.
     *
     * If there are multiple {@link BackgroundComponent}s in the image, this only modifies
     * the topmost such element.
     *
     * **Example**:
     * ```ts,runnable
     * import { Editor, Color4, BackgroundComponentBackgroundType } from 'js-draw';
     * const editor = new Editor(document.body);
     * editor.dispatch(editor.setBackgroundStyle({
     *     color: Color4.orange,
     *     type: BackgroundComponentBackgroundType.Grid,
     *     autoresize: true,
     * }));
     * ```
     *
     * To change the background size, see {@link EditorImage.setImportExportRect}.
     */
    setBackgroundStyle(style) {
      const originalBackground = this.getTopmostBackgroundComponent();
      const commands = [];
      if (originalBackground) {
        commands.push(new Erase_default([originalBackground]));
      }
      const originalType = originalBackground?.getBackgroundType?.() ?? BackgroundType.None;
      const originalColor = originalBackground?.getStyle?.().color ?? Color4.transparent;
      const originalFillsScreen = this.image.getAutoresizeEnabled();
      const defaultType = style.color && originalType === BackgroundType.None ? BackgroundType.SolidColor : originalType;
      const backgroundType = style.type ?? defaultType;
      const backgroundColor = style.color ?? originalColor;
      const fillsScreen = style.autoresize ?? originalFillsScreen;
      if (backgroundType !== BackgroundType.None) {
        const newBackground = new BackgroundComponent(backgroundType, backgroundColor);
        commands.push(EditorImage_default.addComponent(newBackground));
      }
      if (fillsScreen !== originalFillsScreen) {
        commands.push(this.image.setAutoresizeEnabled(fillsScreen));
        if (!fillsScreen && this.image.getImportExportRect().maxDimension === 0) {
          commands.push(this.image.setImportExportRect(this.image.getImportExportRect().resizedTo(Vec2.of(500, 500))));
        }
      }
      return uniteCommands_default(commands);
    }
    /**
     * Set the background color of the image.
     *
     * This is a convenience method for adding or updating the {@link BackgroundComponent}
     * for the current image.
     *
     * @see {@link setBackgroundStyle}
     */
    setBackgroundColor(color) {
      let background = this.getTopmostBackgroundComponent();
      if (!background) {
        const backgroundType = color.eq(Color4.transparent) ? BackgroundType.None : BackgroundType.SolidColor;
        background = new BackgroundComponent(backgroundType, color);
        return this.image.addComponent(background);
      } else {
        return background.updateStyle({ color });
      }
    }
    /**
     * @returns the average of the colors of all background components. Use this to get the current background
     * color.
     */
    estimateBackgroundColor() {
      const backgroundColors = [];
      for (const component of this.image.getBackgroundComponents()) {
        if (component instanceof BackgroundComponent) {
          backgroundColors.push(component.getStyle().color ?? Color4.transparent);
        }
      }
      return Color4.average(backgroundColors);
    }
    // Returns the size of the visible region of the output SVG
    getImportExportRect() {
      return this.image.getImportExportViewport().visibleRect;
    }
    // Resize the output SVG to match `imageRect`.
    setImportExportRect(imageRect) {
      return this.image.setImportExportRect(imageRect);
    }
    /**
     * Alias for `loadFrom(SVGLoader.fromString)`.
     *
     * @example
     * ```ts,runnable
     * import {Editor} from 'js-draw';
     * const editor = new Editor(document.body);
     *
     * ---visible---
     * await editor.loadFromSVG(`
     *   <svg viewBox="5 23 52 30" width="52" height="16" version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
     *     <text style="
     *       transform: matrix(0.181846, 0.1, 0, 0.181846, 11.4, 33.2);
     *       font-family: serif;
     *       font-size: 32px;
     *       fill: rgb(100, 140, 61);
     *     ">An SVG image!</text>
     *   </svg>
     * `);
     * ```
     */
    async loadFromSVG(svgData, sanitize = false) {
      const loader = SVGLoader.fromString(svgData, {
        sanitize,
        plugins: this.getCurrentSettings().svg?.loaderPlugins
      });
      await this.loadFrom(loader);
    }
    /**
     * Shows an information dialog with legal notices.
     */
    showAboutDialog() {
      const iconLicenseText = this.icons.licenseInfo();
      const notices = [];
      if (this.settings.appInfo) {
        const descriptionLines = [];
        if (this.settings.appInfo.version) {
          descriptionLines.push(`v${this.settings.appInfo.version}`, "");
        }
        if (this.settings.appInfo.description) {
          descriptionLines.push(this.settings.appInfo.description + "\n");
        } else {
          descriptionLines.push(`js-draw v${version_default.number}`);
        }
        notices.push({
          heading: `${this.settings.appInfo.name}`,
          text: descriptionLines.join("\n")
        });
      } else {
        notices.push({
          heading: "js-draw",
          text: `v${version_default.number}`
        });
      }
      const screenSize = this.viewport.getScreenRectSize();
      notices.push({
        heading: this.localization.developerInformation,
        text: [
          "Image debug information (from when this dialog was opened):",
          `    ${this.viewport.getScaleFactor()}x zoom, ${180 / Math.PI * this.viewport.getRotationAngle()}\xB0 rotation`,
          `    ${this.image.estimateNumElements()} components`,
          `    auto-resize: ${this.image.getAutoresizeEnabled() ? "enabled" : "disabled"}`,
          `    image size: ${this.getImportExportRect().w}x${this.getImportExportRect().h}`,
          `    screen size: ${screenSize.x}x${screenSize.y}`,
          `    device pixel ratio: ${this.display.getDevicePixelRatio()}`,
          "    cache:",
          `        ${this.display.getCache().getDebugInfo().replace(/([\n])/g, "\n        ")}`
        ].join("\n"),
        minimized: true
      });
      notices.push({
        heading: this.localization.softwareLibraries,
        text: [
          `This image editor is powered by js-draw v${version_default.number}.`,
          "",
          "At runtime, js-draw uses",
          " - The Coloris color picker: https://github.com/mdbassit/Coloris",
          " - The bezier.js B\xE9zier curve library: https://github.com/Pomax/bezierjs",
          "",
          "Both are licensed under the MIT license:",
          "",
          "",
          "== Coloris ==",
          mitLicenseAttribution_default("2021 Mohammed Bassit"),
          "",
          "",
          "== Bezier.js ==",
          mitLicenseAttribution_default('2023 Mike "Pomax" Kamermans'),
          "",
          "",
          "== js-draw ==",
          mitLicenseAttribution_default("2023-2025 Henry Heino"),
          ""
        ].join("\n"),
        minimized: true
      });
      if (iconLicenseText) {
        notices.push({
          heading: "Icon Pack",
          text: iconLicenseText,
          minimized: true
        });
      }
      notices.push(...this.settings.notices);
      this.closeAboutDialog?.();
      this.closeAboutDialog = makeAboutDialog_default(this, notices).close;
    }
    /**
     * Removes and **destroys** the editor. The editor cannot be added to a parent
     * again after calling this method.
     */
    remove() {
      this.container.remove();
      this.toolController.onEditorDestroyed();
    }
  };
  var Editor_default = Editor;

  // node_modules/js-draw/dist/mjs/commands/invertCommand.mjs
  var invertCommand = (command) => {
    if (command instanceof SerializableCommand_default) {
      return new class extends SerializableCommand_default {
        constructor() {
          super(...arguments);
          this._command = command;
        }
        serializeToJSON() {
          return command.serialize();
        }
        apply(editor) {
          command.unapply(editor);
        }
        unapply(editor) {
          command.apply(editor);
        }
        onDrop(editor) {
          command.onDrop(editor);
        }
        description(editor, localizationTable) {
          return localizationTable.inverseOf(command.description(editor, localizationTable));
        }
      }("inverse");
    } else {
      const result = new class extends Command_default {
        apply(editor) {
          command.unapply(editor);
        }
        unapply(editor) {
          command.apply(editor);
        }
        onDrop(editor) {
          command.onDrop(editor);
        }
        description(editor, localizationTable) {
          return localizationTable.inverseOf(command.description(editor, localizationTable));
        }
      }();
      return result;
    }
  };
  SerializableCommand_default.register("inverse", (data, editor) => {
    return invertCommand(SerializableCommand_default.deserialize(data, editor));
  });

  // node_modules/js-draw/dist/mjs/toolbar/widgets/OverflowWidget.mjs
  var OverflowWidget = class extends BaseWidget_default {
    constructor(editor, localizationTable) {
      super(editor, "overflow-widget", localizationTable);
      this.overflowChildren = [];
      this.container.classList.add("toolbar-overflow-widget");
      this.container.classList.add("dropdownShowable");
      this.overflowContainer ??= document.createElement("div");
    }
    shouldAutoDisableInReadOnlyEditor() {
      return false;
    }
    getTitle() {
      return this.localizationTable.toggleOverflow;
    }
    createIcon() {
      return this.editor.icons.makeOverflowIcon();
    }
    handleClick() {
      this.setDropdownVisible(!this.isDropdownVisible());
    }
    fillDropdown(dropdown) {
      this.overflowContainer ??= document.createElement("div");
      if (this.overflowContainer.parentElement) {
        this.overflowContainer.remove();
      }
      this.overflowContainer.classList.add("toolbar-overflow-widget-overflow-list");
      dropdown.appendChild(this.overflowContainer);
      return true;
    }
    /**
     * Removes all `BaseWidget`s from this and returns them.
     */
    clearChildren() {
      this.overflowContainer.replaceChildren();
      this.container.classList.remove("horizontal");
      const overflowChildren = this.overflowChildren;
      this.overflowChildren = [];
      return overflowChildren;
    }
    getChildWidgets() {
      return [...this.overflowChildren];
    }
    hasAsChild(widget) {
      for (const otherWidget of this.overflowChildren) {
        if (widget === otherWidget) {
          return true;
        }
      }
      return false;
    }
    /**
     * Adds `widget` to this.
     * `widget`'s previous parent is still responsible
     * for serializing/deserializing its state.
     */
    addToOverflow(widget) {
      this.overflowChildren.push(widget);
      widget.addTo(this.overflowContainer);
      widget.setIsToplevel(false);
      if (this.overflowChildren.length > 2) {
        this.container.classList.add("horizontal");
      }
    }
    // This always returns false.
    // Don't try to move the overflow menu to itself.
    canBeInOverflowMenu() {
      return false;
    }
  };

  // node_modules/js-draw/dist/mjs/toolbar/DropdownToolbar.mjs
  var makeDropdownToolbar = (editor) => {
    return new DropdownToolbar(editor, editor.getRootElement(), editor.localization);
  };
  var DropdownToolbar = class extends AbstractToolbar_default {
    /** @internal */
    constructor(editor, parent, localizationTable) {
      super(editor, localizationTable);
      this.widgetOrderCounter = 0;
      this.overflowWidget = null;
      this.reLayoutQueued = false;
      this.container = document.createElement("div");
      this.container.classList.add(`${toolbarCSSPrefix}root`);
      this.container.classList.add(`${toolbarCSSPrefix}element`);
      this.container.classList.add(`${toolbarCSSPrefix}dropdown-toolbar`);
      this.container.setAttribute("role", "toolbar");
      parent.appendChild(this.container);
      if ("ResizeObserver" in window) {
        this.resizeObserver = new ResizeObserver((_entries) => {
          this.reLayout();
        });
        this.resizeObserver.observe(this.container);
      } else {
        console.warn("ResizeObserver not supported. Toolbar will not resize.");
      }
    }
    queueReLayout() {
      if (!this.reLayoutQueued) {
        this.reLayoutQueued = true;
        requestAnimationFrame(() => this.reLayout());
      }
    }
    reLayout() {
      this.reLayoutQueued = false;
      if (!this.overflowWidget) {
        return;
      }
      const getTotalWidth = (widgetList) => {
        let totalWidth = 0;
        for (const widget of widgetList) {
          if (!widget.isHidden()) {
            totalWidth += widget.getButtonWidth();
          }
        }
        return totalWidth;
      };
      const canRemoveFirstChildFromOverflow = (freeSpaceInMainMenu) => {
        const overflowChildren = this.overflowWidget?.getChildWidgets() ?? [];
        if (overflowChildren.length === 0) {
          return false;
        }
        return overflowChildren[0].getButtonWidth() <= freeSpaceInMainMenu;
      };
      const allWidgets = this.getAllWidgets();
      let overflowWidgetsWidth = getTotalWidth(this.overflowWidget.getChildWidgets());
      let shownWidgetWidth = getTotalWidth(allWidgets) - overflowWidgetsWidth;
      let availableWidth = this.container.clientWidth * 0.87;
      if (window.innerHeight > availableWidth * 1.75) {
        availableWidth *= 1.75;
      }
      let updatedChildren = false;
      if (canRemoveFirstChildFromOverflow(availableWidth - shownWidgetWidth)) {
        const overflowChildren = this.overflowWidget.clearChildren();
        for (const child of overflowChildren) {
          child.addTo(this.container);
          child.setIsToplevel(true);
          if (!child.isHidden()) {
            shownWidgetWidth += child.getButtonWidth();
          }
        }
        overflowWidgetsWidth = 0;
        updatedChildren = true;
      }
      if (shownWidgetWidth >= availableWidth) {
        for (let i = allWidgets.length - 1; i >= 0 && shownWidgetWidth >= availableWidth; i--) {
          const child = allWidgets[i];
          if (this.overflowWidget.hasAsChild(child)) {
            continue;
          }
          if (child.canBeInOverflowMenu()) {
            shownWidgetWidth -= child.getButtonWidth();
            this.overflowWidget.addToOverflow(child);
          }
        }
        updatedChildren = true;
      }
      this.overflowWidget.setHidden(this.overflowWidget.getChildWidgets().length === 0);
      if (updatedChildren) {
        this.setupColorPickers();
      }
    }
    addWidgetInternal(widget) {
      const container = widget.addTo(this.container);
      container.style.order = `${this.widgetOrderCounter++}`;
      this.queueReLayout();
    }
    removeWidgetInternal(widget) {
      widget.remove();
      this.queueReLayout();
    }
    addSpacer(options = {}) {
      const spacer = document.createElement("div");
      spacer.classList.add(`${toolbarCSSPrefix}spacer`);
      if (options.grow) {
        spacer.style.flexGrow = `${options.grow}`;
      }
      if (options.minSize) {
        spacer.style.minWidth = options.minSize;
      }
      if (options.maxSize) {
        spacer.style.maxWidth = options.maxSize;
      }
      spacer.style.order = `${this.widgetOrderCounter++}`;
      this.container.appendChild(spacer);
    }
    /**
     * Adds a widget that toggles the overflow menu. Call `addOverflowWidget` to ensure
     * that this widget is in the correct space (if shown).
     *
     * @example
     * ```ts
     * toolbar.addDefaultToolWidgets();
     * toolbar.addOverflowWidget();
     * toolbar.addDefaultActionButtons();
     * ```
     * shows the overflow widget between the default tool widgets and the default action buttons,
     * if shown.
     */
    addOverflowWidget() {
      this.overflowWidget = new OverflowWidget(this.editor, this.localizationTable);
      this.addWidget(this.overflowWidget);
    }
    /**
     * Adds both the default tool widgets and action buttons. Equivalent to
     * ```ts
     * toolbar.addDefaultToolWidgets();
     * toolbar.addOverflowWidget();
     * toolbar.addDefaultActionButtons();
     * ```
     */
    addDefaults() {
      this.addDefaultToolWidgets();
      this.addOverflowWidget();
      this.addDefaultActionButtons();
    }
    onRemove() {
      this.container.remove();
      this.resizeObserver.disconnect();
    }
  };

  // node_modules/js-draw/dist/mjs/util/adjustEditorThemeForContrast.mjs
  var adjustEditorThemeForContrast = (editor, options) => {
    const editorElem = editor.getRootElement();
    const colorPairs = [
      ["--background-color-1", "--foreground-color-1", true, true],
      ["--background-color-2", "--foreground-color-2", true, true],
      ["--background-color-3", "--foreground-color-3", true, true],
      ["--background-color-2", "--primary-action-foreground-color", false, true],
      ["--selection-background-color", "--selection-foreground-color", false, true]
    ];
    if (!options?.dontClearOverrides) {
      for (const [backgroundVar, foregroundVar] of colorPairs) {
        editorElem.style.setProperty(backgroundVar, null);
        editorElem.style.setProperty(foregroundVar, null);
      }
    }
    const styles = getComputedStyle(editorElem);
    const updatedColors = /* @__PURE__ */ Object.create(null);
    const adjustVariablesForContrast = (var1, var2, minContrast, updateVar1, updateVar2) => {
      let color1 = updatedColors[var1] ? updatedColors[var1] : Color4.fromString(styles.getPropertyValue(var1));
      let color2 = updatedColors[var2] ? updatedColors[var2] : Color4.fromString(styles.getPropertyValue(var2));
      if (color1.relativeLuminance() < color2.relativeLuminance()) {
        const tmp = color1;
        color1 = color2;
        color2 = tmp;
        const oldVar2 = var2;
        var2 = var1;
        var1 = oldVar2;
        const oldUpdateVar1 = updateVar1;
        updateVar1 = updateVar2;
        updateVar2 = oldUpdateVar1;
      }
      let colorsUpdated = false;
      let currentContrast = Color4.contrastRatio(color1, color2);
      let iterations = 0;
      while (currentContrast < minContrast && iterations < 8) {
        const step = Vec3.of(0.1, 0.1, 0.1);
        if (updateVar1) {
          if (color2.eq(Color4.white) && !updateVar2) {
            color2 = Color4.black;
          }
          color1 = Color4.fromRGBVector(color1.rgb.plus(step));
        }
        if (updateVar2) {
          if (color2.eq(Color4.black) && !updateVar1) {
            color2 = Color4.white;
          }
          color2 = Color4.fromRGBVector(color2.rgb.minus(step));
        }
        currentContrast = Color4.contrastRatio(color1, color2);
        colorsUpdated = true;
        iterations++;
      }
      if (colorsUpdated) {
        editorElem.style.setProperty(var1, color1.toHexString());
        editorElem.style.setProperty(var2, color2.toHexString());
        updatedColors[var1] = color1;
        updatedColors[var2] = color2;
      }
    };
    adjustVariablesForContrast("--selection-background-color", "--background-color-2", 1.29, true, false);
    for (const [backgroundVar, foregroundVar, updateBackground, updateForeground] of colorPairs) {
      const minContrast = 4.5;
      adjustVariablesForContrast(backgroundVar, foregroundVar, minContrast, updateBackground, updateForeground);
    }
  };
  var adjustEditorThemeForContrast_default = adjustEditorThemeForContrast;

  // node_modules/@js-draw/material-icons/dist/mjs/icons/README.mjs
  var README_default = '`@js-draw/material-icons`: Material icon integration for `js-draw`.\n\nAll icons in `@js-draw/material-icons` were found using [Google WebFonts search](https://fonts.google.com/icons) and downloaded from there.\n\nA copy of the license for these icons is included below:\n\n```\n\n                                 Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      "License" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      "Licensor" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      "Legal Entity" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      "control" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      "You" (or "Your") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      "Source" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      "Object" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      "Work" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      "Derivative Works" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      "Contribution" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, "submitted"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as "Not a Contribution."\n\n      "Contributor" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a "NOTICE" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an "AS IS" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n\n   APPENDIX: How to apply the Apache License to your work.\n\n      To apply the Apache License to your work, attach the following\n      boilerplate notice, with the fields enclosed by brackets "[]"\n      replaced with your own identifying information. (Don\'t include\n      the brackets!)  The text should be enclosed in the appropriate\n      comment syntax for the file format. We also recommend that a\n      file or class name and description of purpose be included on the\n      same "printed page" as the copyright notice for easier\n      identification within third-party archives.\n\n   Copyright [yyyy] [name of copyright owner]\n\n   Licensed under the Apache License, Version 2.0 (the "License");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an "AS IS" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n```\n';

  // node_modules/@js-draw/material-icons/dist/mjs/icons/ExpandMore.mjs
  var ExpandMore = '<svg xmlns="http://www.w3.org/2000/svg" height="48" viewBox="0 -960 960 960" width="48"><path style="fill: var(--icon-color);" d="M480-339.5 234.261-585.239 283-633.978l197 198 197-197 48.739 48.739L480-339.5Z"/></svg>';
  var ExpandMore_default = ExpandMore;

  // node_modules/@js-draw/material-icons/dist/mjs/icons/Undo.mjs
  var Undo = '<svg xmlns="http://www.w3.org/2000/svg" height="48" viewBox="0 -960 960 960" width="48"><path style="fill: var(--icon-color);" d="M261.152-194.022v-68.13h311.674q67.848 0 116.435-45.783 48.587-45.782 48.587-113.108 0-67.087-48.587-112.99-48.587-45.902-116.435-45.902H283.805l110.173 110.174-47.739 47.739L154.022-614l192.217-192.218 47.739 47.74-110.173 110.413h288.021q96.196 0 165.294 65.674 69.098 65.674 69.098 161.348 0 95.434-69.098 161.228-69.098 65.793-165.294 65.793H261.152Z"/></svg>';
  var Undo_default = Undo;

  // node_modules/@js-draw/material-icons/dist/mjs/icons/Redo.mjs
  var Redo = '<svg xmlns="http://www.w3.org/2000/svg" height="48" viewBox="0 -960 960 960" width="48"><path style="fill: var(--icon-color);" d="M388.174-194.022q-96.196 0-165.174-65.674-68.978-65.674-68.978-161.347 0-95.435 68.978-161.229 68.978-65.793 165.174-65.793h288.261L566.022-758.478l47.739-47.74L806.218-614 613.761-422.022l-47.739-47.739 110.413-110.174H387.174q-67.848 0-116.435 45.783-48.587 45.782-48.587 113.109 0 67.326 48.587 113.108 48.587 45.783 116.435 45.783h311.674v68.13H388.174Z"/></svg>';
  var Redo_default = Redo;

  // node_modules/@js-draw/material-icons/dist/mjs/icons/InkEraser.mjs
  var InkEraser = '<svg xmlns="http://www.w3.org/2000/svg" height="48" viewBox="0 -960 960 960" width="48"><path style="fill: var(--icon-color);" d="M687.805-222.152h203v68.13h-271.37l68.37-68.13Zm-515.501 68.13-81.478-84.239q-20.431-19.622-19.792-47.235.64-27.613 19.031-47.004l456.326-494.413q18.391-19.391 46.314-19.272 27.923.12 47.404 19.511L841.283-615.5q19.63 19.622 20.63 47.855 1 28.232-18.63 47.623l-341.957 366H172.304Zm302.695-68.13 322.305-349.37-203.413-213.413-452.848 499.174 61.37 63.609h272.586ZM480-480Z"/></svg>';
  var InkEraser_default = InkEraser;

  // node_modules/@js-draw/material-icons/dist/mjs/icons/InkEraserOff.mjs
  var InkEraserOff = '<svg xmlns="http://www.w3.org/2000/svg" height="48" viewBox="0 -960 960 960" width="48"><path style="fill: var(--icon-color);" d="M813-61 605-269 503-160H179l-81-84q-18-17-17.5-41.5T97-327l216-234L61-813l43-43 752 752-43 43ZM206-220h274l83-91-209-209-212 234 64 66Zm482-138-42-42 158-172-207-217-161 179-41-41 160-174q16-17 40.567-17 24.566 0 41.433 17l205 215q17 17 18 42t-16 42L688-358ZM541-505Zm-82 89Z"/></svg>';
  var InkEraserOff_default = InkEraserOff;

  // node_modules/@js-draw/material-icons/dist/mjs/icons/PanTool.mjs
  var PanTool = '<svg xmlns="http://www.w3.org/2000/svg" height="48" viewBox="0 -960 960 960" width="48"><path style="fill: var(--icon-color);" d="M402.097-34.022q-27.578 0-52.794-12.858-25.216-12.859-40.216-36.337L53.044-468.24l20.928-16q17.985-15 41.322-19 23.336-4 47.801 14.383l114.514 87.312v-411.804q0-13.641 9.439-23.016 9.439-9.375 23.174-9.375t22.952 9.375q9.217 9.375 9.217 23.016v533.978L172.935-404.022l189.934 284.373q6.805 10.323 16.699 15.584 9.893 5.26 22.432 5.26h291.826q37.1 0 62.355-25.254 25.254-25.254 25.254-62.354v-587.413q0-13.641 9.439-23.016 9.439-9.376 23.174-9.376T837-796.842q9.218 9.375 9.218 23.016v587.413q0 63.957-44.218 108.174-44.217 44.217-108.174 44.217H402.097Zm43.946-443.587v-417.174q0-13.641 9.274-23.016 9.273-9.375 23.008-9.375t22.998 9.375q9.264 9.375 9.264 23.016v417.174h-64.544Zm168.196 0v-376.217q0-13.641 9.426-23.016 9.426-9.376 23.141-9.376 13.614 0 22.795 9.376 9.182 9.375 9.182 23.016v376.217h-64.544ZM477.065-288.326Z"/></svg>';
  var PanTool_default = PanTool;

  // node_modules/@js-draw/material-icons/dist/mjs/icons/TouchApp.mjs
  var TouchApp = '<svg xmlns="http://www.w3.org/2000/svg" height="48" viewBox="0 -960 960 960" width="48"><path style="fill: var(--icon-color);" d="M439.5-74.022q-32.2 0-61.652-13.247-29.452-13.248-49.153-38.535L109.543-404.913l27.218-27.065q15.888-15.545 38.194-18.773 22.306-3.227 42.219 7.49l93.978 49.652v-357.348q0-13.915 9.653-23.512 9.653-9.596 23.66-9.596 14.008 0 23.456 9.596 9.449 9.597 9.449 23.512v467.631l-150.935-80.348 156.478 197.761q10.486 12.622 25.085 19.028 14.599 6.407 31.024 6.407H652.87q36.463 0 61.677-25.04t25.214-61.692v-163.942q0-27.891-19.091-46.815-19.092-18.924-46.888-18.924H457.37v-66.457h216.058q55.15 0 93.97 38.647t38.82 93.549v164.022q0 64.195-44.577 108.652-44.576 44.456-108.664 44.456H439.5ZM191.761-662.609q-11.535-19.444-17.746-41.981-6.211-22.538-6.211-46.401 0-73.357 51.604-124.77 51.603-51.413 124.818-51.413t124.853 51.635q51.638 51.635 51.638 124.895 0 23.799-6.211 46.238t-17.745 41.797l-57.5-33.108q7-12 11-26t4-29.478q0-45.522-32.118-77.522-32.118-32-78-32t-77.882 32.083q-32 32.083-32 77.917 0 15 4 29t11 26l-57.5 33.108Zm291.456 330.696Z"/></svg>';
  var TouchApp_default = TouchApp;

  // node_modules/@js-draw/material-icons/dist/mjs/icons/ScreenLockRotation.mjs
  var ScreenLockRotation = '<svg xmlns="http://www.w3.org/2000/svg" height="48" viewBox="0 -960 960 960" width="48"><path style="fill: var(--icon-color);" d="m724.391-486.891 48.979-48.739 52.521 52.521q21.631 21.746 21.631 52.156t-21.631 52.04L672.087-226.348q-22.746 22.631-52.155 22.631-29.41 0-52.041-22.631L249.587-544.891q-22.391-22.152-22.511-51.739-.119-29.588 22.511-52.218l153.565-152.565q22.63-22.63 52.098-22.63 29.467 0 52.098 22.63l47.282 47.522-47.739 48.5-51.521-51.522L295.087-596.63l325.022 325.782 160.043-160.043-55.761-56ZM533.574-30.761q-98.76 0-186.047-37.5-87.288-37.5-152.168-102.88-64.881-65.381-102.38-152.638-37.5-87.257-37.5-185.982h62.63q0 78.565 28.163 148.75t76.967 124.587q48.804 54.402 115.272 89.663 66.467 35.261 142.554 43.978L355.848-228 401-273.152 631.152-43.053Q608.253-37 585.237-33.88t-51.663 3.12ZM664.63-602.63q-15 0-27.5-12.5t-12.5-27.5v-120q0-15 12.5-27.5t27.5-12.5h1v-42q0-33 22.5-55.5t55.5-22.5q33 0 55.5 22.5t22.5 55.5v42h2q15 0 27.5 12.5t12.5 27.5v120q0 15-12.5 27.5t-27.5 12.5h-159Zm39-200h80v-42.106q0-17.894-11-28.894t-29-11q-18 0-29 11t-11 28.894v42.106ZM540.239-513.761Z"/></svg>';
  var ScreenLockRotation_default = ScreenLockRotation;

  // node_modules/@js-draw/material-icons/dist/mjs/icons/Imagesmode.mjs
  var Imagesmode = '<svg xmlns="http://www.w3.org/2000/svg" height="48" viewBox="0 -960 960 960" width="48"><path style="fill: var(--icon-color);" d="M182.152-114.022q-27.599 0-47.865-20.265-20.265-20.266-20.265-47.865v-595.696q0-27.697 20.265-48.033 20.266-20.337 47.865-20.337h595.696q27.697 0 48.033 20.337 20.337 20.336 20.337 48.033v595.696q0 27.599-20.337 47.865-20.336 20.265-48.033 20.265H182.152Zm0-68.13h595.696v-595.696H182.152v595.696Zm50.739-92.696h495.218L578-476.587l-132 171-93-127-120.109 157.739Zm-50.739 92.696v-595.696 595.696Zm157.966-383.783q22.576 0 38.262-15.803 15.685-15.803 15.685-38.38 0-22.576-15.803-38.262-15.803-15.685-38.38-15.685-22.576 0-38.262 15.803-15.685 15.803-15.685 38.38 0 22.576 15.803 38.262 15.803 15.685 38.38 15.685Z"/></svg>';
  var Imagesmode_default = Imagesmode;

  // node_modules/@js-draw/material-icons/dist/mjs/icons/Title.mjs
  var Title = '<svg xmlns="http://www.w3.org/2000/svg" height="48" viewBox="0 -960 960 960" width="48"><path style="fill: var(--icon-color);" d="M425.935-154.022v-544.065H194.022v-108.131h572.196v108.131H534.304v544.065H425.935Z"/></svg>';
  var Title_default = Title;

  // node_modules/@js-draw/material-icons/dist/mjs/icons/Resize.mjs
  var Resize = '<svg xmlns="http://www.w3.org/2000/svg" height="48" viewBox="0 -960 960 960" width="48"><path style="fill: var(--icon-color);" d="M120-439v-83h60v83h-60Zm0-170v-83h60v83h-60Zm0-171v-60h60v60h-60Zm148 0v-60h83v60h-83Zm171 660v-60h83v60h-83Zm0-660v-60h83v60h-83Zm170 660v-60h83v60h-83Zm171 0v-60h60v60h-60Zm0-148v-83h60v83h-60Zm0-171v-83h60v83h-60Zm0-170v-171H609v-60h231v231h-60ZM120-120v-231h60v171h171v60H120Z"/></svg>';
  var Resize_default = Resize;

  // node_modules/@js-draw/material-icons/dist/mjs/icons/Delete.mjs
  var Delete = '<svg xmlns="http://www.w3.org/2000/svg" height="48" viewBox="0 -960 960 960" width="48"><path style="fill: var(--icon-color);" d="M261-120q-24.75 0-42.375-17.625T201-180v-570h-41v-60h188v-30h264v30h188v60h-41v570q0 24-18 42t-42 18H261Zm438-630H261v570h438v-570ZM367-266h60v-399h-60v399Zm166 0h60v-399h-60v399ZM261-750v570-570Z"/></svg>';
  var Delete_default = Delete;

  // node_modules/@js-draw/material-icons/dist/mjs/icons/ContentCopy.mjs
  var ContentCopy = '<svg xmlns="http://www.w3.org/2000/svg" height="48" viewBox="0 -960 960 960" width="48"><path style="fill: var(--icon-color);" d="M180-81q-24 0-42-18t-18-42v-603h60v603h474v60H180Zm120-120q-24 0-42-18t-18-42v-560q0-24 18-42t42-18h440q24 0 42 18t18 42v560q0 24-18 42t-42 18H300Zm0-60h440v-560H300v560Zm0 0v-560 560Z"/></svg>';
  var ContentCopy_default = ContentCopy;

  // node_modules/@js-draw/material-icons/dist/mjs/icons/EditDocument.mjs
  var EditDocument = '<svg xmlns="http://www.w3.org/2000/svg" height="48" viewBox="0 -960 960 960" width="48"><path style="fill: var(--icon-color);" d="M220-80q-24 0-42-18t-18-42v-680q0-24 18-42t42-18h340l240 240v156h-60v-116H520v-220H220v680h300v60H220Zm0-60v-680 680Zm536-223 28 28-164 164v51h51l164-164 28 28L687-80H580v-107l176-176Zm107 107L756-363l61-61q9-9 21-9t21 9l65 65q9 9 9 21t-9 21l-61 61Z"/></svg>';
  var EditDocument_default = EditDocument;

  // node_modules/@js-draw/material-icons/dist/mjs/icons/Check.mjs
  var Check = '<svg xmlns="http://www.w3.org/2000/svg" height="48" viewBox="0 -960 960 960" width="48"><path style="fill: var(--icon-color);" d="M378-246 154-470l43-43 181 181 384-384 43 43-427 427Z"/></svg>';
  var Check_default = Check;

  // node_modules/@js-draw/material-icons/dist/mjs/icons/InkHighlighter.mjs
  var InkHighlighter = '<svg xmlns="http://www.w3.org/2000/svg" height="48" viewBox="0 -960 960 960" width="48"><path style="fill: var(--icon-color);" d="M545.63-401.022 431.587-515.065 217.478-301.196l114.283 114.283L545.63-401.022Zm-65.304-163.021 114.283 114.282 214.674-214.674-114.044-114.282-214.913 214.674Zm-72.848-23.87 211 211L389.5-147.935q-21.152 21.153-58.359 21.153-37.206 0-58.119-21.153l-10.761-10.521-44.913 44.674h-155L184.26-235.456l-3.761-4q-24.391-24.153-23.891-61.12.5-36.968 24.891-61.359l225.978-225.978Zm0 0 241.783-241.783q19.63-19.63 48.859-19.63 29.228 0 49.098 19.63l111.043 111.283q19.63 19.63 19.13 51.478-.5 31.848-20.13 51.479L618.478-376.913l-211-211Z"/></svg>';
  var InkHighlighter_default = InkHighlighter;

  // node_modules/@js-draw/material-icons/dist/mjs/icons/Edit.mjs
  var Edit = '<svg xmlns="http://www.w3.org/2000/svg" height="48" viewBox="0 -960 960 960" width="48"><path style="fill: var(--icon-color);" d="M180-180h44l443-443-44-44-443 443v44Zm614-486L666-794l42-42q17-17 42-17t42 17l44 44q17 17 17 42t-17 42l-42 42Zm-42 42L248-120H120v-128l504-504 128 128Zm-107-21-22-22 44 44-22-22Z"/></svg>';
  var Edit_default = Edit;

  // node_modules/@js-draw/material-icons/dist/mjs/icons/CloudUpload.mjs
  var CloudUpload = '<svg xmlns="http://www.w3.org/2000/svg" height="48" viewBox="0 -960 960 960" width="48"><path style="fill: var(--icon-color);" d="M250-160q-86 0-148-62T40-370q0-78 49.5-137.5T217-579q20-97 94-158.5T482-799q113 0 189.5 81.5T748-522v24q72-2 122 46.5T920-329q0 69-50 119t-119 50H510q-24 0-42-18t-18-42v-258l-83 83-43-43 156-156 156 156-43 43-83-83v258h241q45 0 77-32t32-77q0-45-32-77t-77-32h-63v-84q0-89-60.5-153T478-739q-89 0-150 64t-61 153h-19q-62 0-105 43.5T100-371q0 62 43.929 106.5Q187.857-220 250-220h140v60H250Zm230-290Z"/></svg>';
  var CloudUpload_default = CloudUpload;

  // node_modules/@js-draw/material-icons/dist/mjs/icons/RotateLeft.mjs
  var RotateLeft = '<svg xmlns="http://www.w3.org/2000/svg" height="48" viewBox="0 -960 960 960" width="48"><path style="fill: var(--icon-color);" d="M435-80q-48-7-93-25t-85-48l43-44q32 24 66 37.5t69 19.5v60Zm90 0v-60q110-21 182.5-103.5T780-443q0-127-86.5-213.5T480-743h-20l79 79-44 44-153-153 153-153 44 44-79 79h20q75 0 140.5 28T735-698q49 49 77 114.5T840-443q0 140-89 241T525-80ZM194-216q-28-38-46.5-84.5T122-398h61q5 38 18.5 73t36.5 65l-44 44Zm-72-272q7-50 25-95.5t47-85.5l44 43q-23 33-36.5 68T183-488h-61Z"/></svg>';
  var RotateLeft_default = RotateLeft;

  // node_modules/@js-draw/material-icons/dist/mjs/icons/Select.mjs
  var Select = '<svg xmlns="http://www.w3.org/2000/svg" height="48" viewBox="0 -960 960 960" width="48"><path style="fill: var(--icon-color);" d="M180-120q-24 0-42-18t-18-42h60v60Zm-60-120v-125h60v125h-60Zm0-185v-111h60v111h-60Zm0-171v-124h60v124h-60Zm0-184q0-24 18-42t42-18v60h-60Zm120 660v-60h125v60H240Zm0-660v-60h125v60H240Zm185 660v-60h111v60H425Zm0-660v-60h111v60H425Zm171 660v-60h124v60H596Zm0-660v-60h124v60H596Zm184 660v-60h60q0 24-18 42t-42 18Zm0-120v-125h60v125h-60Zm0-185v-111h60v111h-60Zm0-171v-124h60v124h-60Zm0-184v-60q24 0 42 18t18 42h-60Z"/></svg>';
  var Select_default = Select;

  // node_modules/@js-draw/material-icons/dist/mjs/icons/Close.mjs
  var Close = '<svg xmlns="http://www.w3.org/2000/svg" height="48" viewBox="0 -960 960 960" width="48"><path style="fill: var(--icon-color);" d="m249-207-42-42 231-231-231-231 42-42 231 231 231-231 42 42-231 231 231 231-42 42-231-231-231 231Z"/></svg>';
  var Close_default = Close;

  // node_modules/@js-draw/material-icons/dist/mjs/icons/Shapes.mjs
  var Shapes = '<svg xmlns="http://www.w3.org/2000/svg" height="48" viewBox="0 -960 960 960" width="48"><path style="fill: var(--icon-color);" d="M600-360Zm-280 98q10 2 19.5 2H360q5.5 0 10.25-.25T380-261v121h440v-440H699q.5-5 .75-9.75T700-600v-20.5q0-9.5-2-19.5h122q24.75 0 42.375 17.625T880-580v440q0 24.75-17.625 42.375T820-80H380q-24.75 0-42.375-17.625T320-140v-122Zm40-58q-117 0-198.5-81.5T80-600q0-117 81.5-198.5T360-880q117 0 198.5 81.5T640-600q0 117-81.5 198.5T360-320Zm-.212-60Q451-380 515.5-444.288q64.5-64.288 64.5-155.5T515.712-755.5q-64.288-64.5-155.5-64.5T204.5-755.712q-64.5 64.288-64.5 155.5T204.288-444.5q64.288 64.5 155.5 64.5ZM360-600Z"/></svg>';
  var Shapes_default = Shapes;

  // node_modules/@js-draw/material-icons/dist/mjs/icons/Draw.mjs
  var Draw = '<svg xmlns="http://www.w3.org/2000/svg" height="48" viewBox="0 -960 960 960" width="48"><path style="fill: var(--icon-color);" d="M560-120q-12 0-21-9t-9-21q0-13 9-21.5t21-8.5q59 0 99.5-24t40.5-56q0-23-29.5-45T591-339l47-47q63 19 92.5 52.5T760-260q0 67-61 103.5T560-120ZM240-414q-64-14-92-44t-28-62q0-35 26-63t120-62q66-24 85-39t19-35q0-25-22-43t-68-18q-27 0-46 7t-34 22q-8 8-20.5 9.5T157-748q-11-8-11.5-20t7.5-21q17-22 51-36.5t76-14.5q68 0 109 32.5t41 88.5q0 41-28.5 69.5T290-590q-67 25-88.5 39.5T180-520q0 16 27 30.5t81 27.5l-48 48Zm496-154L608-696l45-45q18-18 40-18t40 18l48 48q18 18 18 40t-18 40l-45 45ZM220-180h42l345-345-42-42-345 345v42Zm-60 60v-128l405-405 128 128-405 405H160Zm405-447 42 42-42-42Z"/></svg>';
  var Draw_default = Draw;

  // node_modules/@js-draw/material-icons/dist/mjs/icons/InkPen.mjs
  var InkPen = '<svg xmlns="http://www.w3.org/2000/svg" height="48" viewBox="0 -960 960 960" width="48"><path style="fill: var(--icon-color);" d="m480-522 42 42 249-249-42-42-249 249ZM180-180h42l258-258-42-42-258 258v42Zm362-238L418-542l198-198-30-30-234 234-43-43 228-228q25-25 49.5-25.5T637-807l23 23 45-45q11-11 25-11t25 11l73 73q11 11 11 26t-11 26L542-418ZM244-120H120v-124l298-298 124 124-298 298Z"/></svg>';
  var InkPen_default = InkPen;

  // node_modules/@js-draw/material-icons/dist/mjs/icons/ContentPaste.mjs
  var ContentPaste = '<svg xmlns="http://www.w3.org/2000/svg" height="48" viewBox="0 0 24 24" width="48"><path style="fill: var(--icon-color);" d="M19 2h-4.18C14.4.84 13.3 0 12 0S9.6.84 9.18 2H5c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-7 0c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm7 18H5V4h2v3h10V4h2v16z"/></svg>';
  var ContentPaste_default = ContentPaste;

  // node_modules/@js-draw/material-icons/dist/mjs/icons/LassoSelect.mjs
  var LassoSelect = '<svg xmlns="http://www.w3.org/2000/svg" height="48" viewBox="0 -960 960 960" width="48"><path style="fill: var(--icon-color);" d="m141-518-60-6q5-46 20-90t40-82l51 33q-19 34-32 70.5T141-518Zm55 317q-32-31-56.5-69T101-353l58-19q13 37 33 69t47 59l-43 43Zm102-568-33-51q40-25 82.5-39.5T438-880l6 60q-41 5-75.5 17.5T298-769ZM488-82q-38 0-74-6t-68-17l22-58q27 10 59 15t61 6v60Zm232-635q-29-29-62-50.5T587-802l21-57q47 16 85.5 41.5T763-760l-43 43Zm93 600L682-248v130h-60v-232h232v60H724l131 131-42 42Zm6-367q-1-29-5.5-59T797-600l58-18q12 32 18 65.5t6 68.5h-60Z"/></svg>';
  var LassoSelect_default = LassoSelect;

  // node_modules/@js-draw/material-icons/dist/mjs/icons/LineWeight.mjs
  var LineWeight = '<svg xmlns="http://www.w3.org/2000/svg" height="48px" viewBox="0 0 24 24" width="48px"><path style="fill: var(--icon-color);" d="M3 17h18v-2H3v2zm0 3h18v-1H3v1zm0-7h18v-3H3v3zm0-9v4h18V4H3z"/></svg>\n';
  var LineWeight_default = LineWeight;

  // node_modules/@js-draw/material-icons/dist/mjs/makeMaterialIconProvider.mjs
  var icon = (data) => {
    const icon2 = document.createElement("div");
    icon2.innerHTML = data;
    return icon2.childNodes[0];
  };
  var makeMaterialIconProviderClass = ({ IconProvider: IconProvider2, EraserMode: EraserMode2 }) => class extends IconProvider2 {
    makeUndoIcon() {
      return icon(Undo_default);
    }
    makeRedoIcon() {
      return icon(Redo_default);
    }
    makeDropdownIcon() {
      return icon(ExpandMore_default);
    }
    makeEraserIcon(_eraserSize, mode) {
      return icon(mode === EraserMode2.PartialStroke ? InkEraserOff_default : InkEraser_default);
    }
    makeSelectionIcon(mode) {
      return icon(mode === SelectionMode.Lasso ? LassoSelect_default : Select_default);
    }
    makeRotateIcon() {
      return icon(RotateLeft_default);
    }
    makeHandToolIcon() {
      return icon(PanTool_default);
    }
    makeTouchPanningIcon() {
      return icon(TouchApp_default);
    }
    // makeAllDevicePanningIcon(): IconElemType;
    // makeZoomIcon(): IconElemType;
    makeRotationLockIcon() {
      return icon(ScreenLockRotation_default);
    }
    makeInsertImageIcon() {
      return icon(Imagesmode_default);
    }
    makeUploadFileIcon() {
      return icon(CloudUpload_default);
    }
    makeTextIcon(_textStyle) {
      return icon(Title_default);
    }
    makePenIcon(style) {
      let baseIcon = this.isRoundedTipPen(style) ? Edit_default : InkHighlighter_default;
      if (this.isPolylinePen(style)) {
        baseIcon = InkPen_default;
      }
      const svg = icon(baseIcon);
      svg.setAttribute("viewBox", "0 -880 960 1000");
      const line = document.createElementNS("http://www.w3.org/2000/svg", "path");
      line.setAttribute("d", `
			M110,-25 L850,-25
		`);
      line.style.stroke = style.color.toHexString();
      line.style.strokeWidth = `${Math.sqrt(style.thickness) * 20}`;
      if (!this.isRoundedTipPen(style)) {
        line.style.strokeLinecap = "square";
      } else {
        line.style.strokeLinecap = "round";
      }
      svg.insertAdjacentElement("afterbegin", line);
      if (style.color.a < 1) {
        const checkerboard = this.makeCheckerboardPattern();
        const defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
        defs.appendChild(checkerboard.patternDefElement);
        svg.appendChild(defs);
        const lineBackground = line.cloneNode();
        lineBackground.style.stroke = checkerboard.patternRef;
        svg.insertAdjacentElement("afterbegin", lineBackground);
      }
      return svg;
    }
    // makeIconFromFactory(pen: Pen, factory: ComponentBuilderFactory, includeTransparencyGrid?: boolean): IconElemType;
    // makePipetteIcon(color?: Color4): IconElemType;
    // makeFormatSelectionIcon(): IconElemType;
    makeShapeAutocorrectIcon() {
      return icon(Shapes_default);
    }
    makeStrokeSmoothingIcon() {
      return icon(Draw_default);
    }
    makePressureSensitivityIcon() {
      return icon(LineWeight_default);
    }
    makeResizeImageToSelectionIcon() {
      return icon(Resize_default);
    }
    makeDuplicateSelectionIcon() {
      return icon(ContentCopy_default);
    }
    makeCopyIcon() {
      return icon(ContentCopy_default);
    }
    makePasteIcon() {
      return icon(ContentPaste_default);
    }
    makeDeleteSelectionIcon() {
      return icon(Delete_default);
    }
    makeCloseIcon() {
      return icon(Close_default);
    }
    makeSaveIcon() {
      return icon(Check_default);
    }
    makeConfigureDocumentIcon() {
      return icon(EditDocument_default);
    }
    // makeOverflowIcon(): IconElemType;
    licenseInfo() {
      return README_default;
    }
  };
  var makeMaterialIconProvider_default = makeMaterialIconProviderClass;

  // node_modules/@js-draw/material-icons/dist/mjs/lib.mjs
  var MaterialIconProvider = makeMaterialIconProvider_default({
    IconProvider: IconProvider_default,
    EraserMode,
    SelectionMode
  });

  // src/dialog/webview/template/constants.ts
  var templateKey = "jsdraw-image-template";
  var defaultTemplate = {
    imageSize: [500, 500],
    autoresize: true,
    backgroundData: {
      name: "image-background",
      zIndex: 0,
      data: {
        mainColor: "#ffffff",
        backgroundType: BackgroundType.SolidColor
      }
    }
  };

  // src/dialog/webview/template/loadTemplate.ts
  var loadTemplate = async (editor, settings) => {
    try {
      const savedTemplateString = settings.getSetting(templateKey);
      const data = savedTemplateString ? JSON.parse(savedTemplateString) : defaultTemplate;
      if ("imageSize" in data && typeof data["imageSize"][0] === "number" && typeof data["imageSize"][1] === "number" && isFinite(data["imageSize"][0]) && isFinite(data["imageSize"][1])) {
        let width = data.imageSize[0];
        let height = data.imageSize[1];
        const minDimension = 50;
        const maxDimension = 5e3;
        width = Math.min(maxDimension, Math.max(minDimension, width));
        height = Math.min(maxDimension, Math.max(minDimension, height));
        const imageSize = Vec2.of(width, height);
        const importExportRect = new Rect2(0, 0, imageSize.x, imageSize.y);
        const addToHistory = false;
        await editor.dispatchNoAnnounce(editor.setImportExportRect(importExportRect), addToHistory);
      }
      if ("backgroundData" in data) {
        const background = AbstractComponent_default.deserialize(data.backgroundData);
        const addToHistory = false;
        await editor.dispatchNoAnnounce(editor.image.addElement(background), addToHistory);
      }
      if ("autoresize" in data && typeof data.autoresize === "boolean") {
        await editor.dispatchNoAnnounce(editor.image.setAutoresizeEnabled(data.autoresize), false);
      }
    } catch (e) {
      console.warn("Error initializing js-draw from template: ", e);
    }
  };
  var loadTemplate_default = loadTemplate;

  // src/dialog/webview/setupToolbar.ts
  var setupToolbar = (editor, callbacks, settings) => {
    let toolbar = null;
    let saveButton;
    let isSaveUpToDate = false;
    let isLoading = false;
    const updateSaveButtonDisabled = () => {
      saveButton.setDisabled(isSaveUpToDate || isLoading);
    };
    const toolbarStateKey = "jsdraw-toolbarState";
    editor.notifier.on(EditorEventType.ToolUpdated, () => {
      if (toolbar) {
        settings.updateSetting(toolbarStateKey, toolbar.serializeState());
      }
    });
    let lastKind = null;
    const changeToolbarType = (kind) => {
      if (kind === lastKind) {
        return;
      }
      lastKind = kind;
      toolbar?.remove();
      const isEdgeToolbar = kind === 0 /* Default */ || kind === 1 /* Sidebar */;
      toolbar = isEdgeToolbar ? makeEdgeToolbar(editor) : makeDropdownToolbar(editor);
      toolbar.addDefaults();
      toolbar.addSpacer({ grow: 1, maxSize: "15px" });
      toolbar.addExitButton(callbacks.onExitPress);
      toolbar.addSpacer({ grow: 1, maxSize: "15px" });
      saveButton = toolbar.addSaveButton(callbacks.onSavePress);
      try {
        const toolbarState = settings.getSetting(toolbarStateKey);
        if (toolbarState) {
          toolbar.deserializeState(toolbarState);
        }
      } catch (e) {
        console.warn("Error restoring toolbar state!", e);
      }
      updateSaveButtonDisabled();
    };
    changeToolbarType(0 /* Default */);
    editor.notifier.on(EditorEventType.UndoRedoStackUpdated, () => {
      isSaveUpToDate = false;
      updateSaveButtonDisabled();
    });
    return {
      setToolbarMode: changeToolbarType,
      setSaved: () => {
        isSaveUpToDate = true;
        updateSaveButtonDisabled();
      },
      setLoading: (loading) => {
        isLoading = loading;
        updateSaveButtonDisabled();
      },
      hasUnsavedChanges: () => !isSaveUpToDate
    };
  };
  var setupToolbar_default = setupToolbar;

  // src/dialog/webview/template/saveStateAsTemplate.ts
  var saveStateAsTemplate = (editor, settings) => {
    let topmostBackgroundComponent = null;
    for (const elem of editor.image.getBackgroundComponents()) {
      if (elem instanceof BackgroundComponent) {
        topmostBackgroundComponent = elem;
      }
    }
    let editorBackgroundData = {};
    if (topmostBackgroundComponent) {
      editorBackgroundData = topmostBackgroundComponent.serialize();
    }
    const imageSize = editor.getImportExportRect().size;
    const template = JSON.stringify({
      backgroundData: editorBackgroundData,
      imageSize: [imageSize.x, imageSize.y],
      autoresize: editor.image.getAutoresizeEnabled()
    });
    settings.updateSetting(templateKey, template);
  };
  var saveStateAsTemplate_default = saveStateAsTemplate;

  // src/dialog/webview/applyShortcutOverrides.ts
  var applyShortcutOverrides = (editor, shortcuts) => {
    for (const id in shortcuts) {
      try {
        console.log("apply shortcut override", id, shortcuts[id]);
        const keybindings = shortcuts[id].map(
          (keybindingString) => KeyBinding.fromString(keybindingString)
        );
        editor.shortcuts.overrideShortcut(id, keybindings);
      } catch (error) {
        console.error("Invalid keybinding for id", id, ". Error: ", error);
      }
    }
  };
  var applyShortcutOverrides_default = applyShortcutOverrides;

  // src/dialog/webview/makeJsDrawEditor.ts
  var makeJsDrawEditor = async (settingControl, callbacks, disableRenderer) => {
    const editor = new Editor_default(document.body, {
      iconProvider: new MaterialIconProvider(),
      // Disable the renderer to hide jsdom warnings when testing.
      renderingMode: disableRenderer ? RenderingMode.DummyRenderer : void 0,
      image: {
        showImagePicker: async ({ setOnCancelCallback }) => {
          const imageTask = await callbacks.showImagePicker();
          setOnCancelCallback(() => {
            imageTask.cancel();
            imageTask.cleanUp();
          });
          const images = await imageTask.images;
          if (!images) return null;
          const files = [];
          for (const image of images) {
            const data = await fetch(image.path);
            const buffer = await data.arrayBuffer();
            files.push(
              new File([buffer], image.name, {
                type: image.mime
              })
            );
          }
          imageTask.cleanUp();
          return files;
        }
      },
      localization: getLocalizationTable_default(getLocales())
    });
    editor.focus();
    await loadTemplate_default(editor, settingControl);
    const addToHistory = false;
    await editor.dispatchNoAnnounce(
      editor.viewport.zoomTo(editor.getImportExportRect()),
      addToHistory
    );
    let prevStyle = null;
    const applyStyle = (styleName) => {
      const editorRoot = editor.getRootElement();
      if (prevStyle) {
        editorRoot.classList.remove(styleName);
      }
      editorRoot.classList.add(styleName);
      prevStyle = styleName;
      adjustEditorThemeForContrast_default(editor);
    };
    let toolbarControl;
    const saveDrawing = async () => {
      saveStateAsTemplate_default(editor, settingControl);
      callbacks.onSave();
    };
    const exitEditor = () => {
      callbacks.onExit();
    };
    toolbarControl = setupToolbar_default(
      editor,
      {
        onSavePress: saveDrawing,
        onExitPress: exitEditor
      },
      settingControl
    );
    return {
      editor,
      applyStyle,
      setToolbarMode: toolbarControl.setToolbarMode,
      applyShortcutOverrides: (overrides) => {
        applyShortcutOverrides_default(editor, overrides);
      },
      loadInitialImage: async (svgData) => {
        toolbarControl.setLoading(true);
        const addToHistory2 = false;
        await editor.dispatchNoAnnounce(
          new Erase_default(editor.image.getBackgroundComponents()),
          addToHistory2
        );
        await editor.loadFromSVG(svgData);
        toolbarControl.setLoading(false);
        toolbarControl.setSaved();
      },
      hasUnsavedChanges: () => toolbarControl.hasUnsavedChanges(),
      onSaved: () => toolbarControl.setSaved()
    };
  };
  var makeJsDrawEditor_default = makeJsDrawEditor;

  // src/dialog/webview/settings/localStorageSettingControl.ts
  var localStorageSettingControl = {
    updateSetting(key, value) {
      localStorage.setItem(key, value);
    },
    getSetting(key) {
      return localStorage.getItem(key);
    }
  };
  var localStorageSettingControl_default = localStorageSettingControl;

  // src/dialog/webview/screens/showSaveScreen.ts
  var showSaveScreen = async (editorControl2, postMessageCallback2) => {
    if (!editorControl2) {
      return;
    }
    const editor = editorControl2.editor;
    const saveMessage = {
      type: "saveSVG" /* SaveSVG */,
      data: svgElementToString_default(editor.toSVG())
    };
    const response = await postMessageCallback2({ ...saveMessage });
    if (response !== true && response.type === "saveResponse" /* SaveResponse */) {
      if (!response.waitingForSaveType) {
        return true;
      }
    } else {
      throw new Error("Invalid response " + response);
    }
    editor.getRootElement().style.display = "none";
    const dialogContainer = document.createElement("form");
    dialogContainer.className = "save-or-exit-dialog";
    dialogContainer.name = "saveOptions";
    const hideSaveScreen = async () => {
      editor.getRootElement().style.display = "";
      dialogContainer.remove();
      await postMessageCallback2({ type: "removeButtons" /* HideButtons */ });
    };
    const resumeEditingButton = document.createElement("button");
    resumeEditingButton.innerText = localization_default.saveAndResumeEditing;
    resumeEditingButton.onclick = async () => {
      await hideSaveScreen();
      await postMessageCallback2({ ...saveMessage });
      editor.focus();
    };
    const saveOptionsContainer = document.createElement("div");
    let idCounter5 = 0;
    const addSaveOption = (label, value, checked = false) => {
      const saveOptionRow = document.createElement("div");
      const labelElem = document.createElement("label");
      const inputElem = document.createElement("input");
      inputElem.name = "saveOption";
      inputElem.value = value;
      inputElem.type = "radio";
      inputElem.id = `saveOption-${idCounter5++}`;
      labelElem.setAttribute("for", inputElem.id);
      inputElem.checked = checked;
      labelElem.innerText = label;
      saveOptionRow.replaceChildren(inputElem, labelElem);
      saveOptionsContainer.appendChild(saveOptionRow);
      const onUpdate = async () => {
        if (inputElem.checked) {
          await postMessageCallback2({
            type: "setSaveMethod" /* SetSaveMethod */,
            method: value
          });
        }
      };
      onUpdate();
      inputElem.oninput = onUpdate;
    };
    addSaveOption(localization_default.overwriteExisting, "overwrite" /* Overwrite */, true);
    addSaveOption(localization_default.saveAsNewDrawing, "saveAsNew" /* SaveAsNew */);
    const messageElem = document.createElement("div");
    messageElem.innerText = localization_default.clickBelowToContinue;
    const buttonContainer = document.createElement("div");
    buttonContainer.classList.add("button-container");
    buttonContainer.replaceChildren(resumeEditingButton);
    dialogContainer.replaceChildren(messageElem, saveOptionsContainer, buttonContainer);
    document.body.appendChild(dialogContainer);
    return false;
  };
  var showSaveScreen_default = showSaveScreen;

  // src/dialog/webview/screens/showCloseScreen.ts
  var showCloseScreen = (editorControl2, postMessageCallback2, addSaveCompletedListener2) => {
    if (!editorControl2) {
      return;
    }
    const editor = editorControl2.editor;
    postMessageCallback2({
      type: "showCloseButton" /* ShowCloseButton */,
      isSaved: !editorControl2.hasUnsavedChanges()
    });
    editor.getRootElement().style.display = "none";
    const dialogContainer = document.createElement("div");
    dialogContainer.classList.add("save-or-exit-dialog");
    const hideExitScreen = async () => {
      editor.getRootElement().style.display = "";
      dialogContainer.remove();
      await postMessageCallback2({ type: "removeButtons" /* HideButtons */ });
    };
    const message = document.createElement("div");
    if (editorControl2.hasUnsavedChanges()) {
      dialogContainer.classList.add("has-unsaved-changes");
      message.innerText = localization_default.discardUnsavedChanges;
    } else {
      message.innerText = localization_default.exitInstructions;
    }
    const resumeEditingBtn = document.createElement("button");
    resumeEditingBtn.innerText = localization_default.resumeEditing;
    resumeEditingBtn.onclick = async () => {
      await hideExitScreen();
      editor.focus();
    };
    const saveChangesButton = document.createElement("button");
    saveChangesButton.innerText = localization_default.saveChanges;
    saveChangesButton.classList.add("save-changes-button");
    saveChangesButton.onclick = async () => {
      await hideExitScreen();
      const saveCompletedListener = new Promise((resolve) => {
        addSaveCompletedListener2(() => resolve());
      });
      const saved = await showSaveScreen_default(editorControl2, postMessageCallback2);
      if (saved) {
        await saveCompletedListener;
        showCloseScreen(editorControl2, postMessageCallback2, addSaveCompletedListener2);
      }
    };
    const buttonContainer = document.createElement("div");
    buttonContainer.classList.add("button-container");
    buttonContainer.replaceChildren(resumeEditingBtn, saveChangesButton);
    dialogContainer.replaceChildren(message, buttonContainer);
    document.body.appendChild(dialogContainer);
    saveChangesButton.focus();
  };
  var showCloseScreen_default = showCloseScreen;

  // src/dialog/webview/webview.ts
  var postMessageCallback = (message) => webviewApi.postMessage(message);
  var haveLoadedFromSvg = false;
  var saveCompletedListeners = [];
  var editorControl = null;
  var editorInitializationData = null;
  var initializeEditor = (editorControl2, initializationData) => {
    editorControl2.setToolbarMode(initializationData.toolbarType);
    editorControl2.applyStyle(initializationData.styleMode);
    editorControl2.applyShortcutOverrides(initializationData.keyboardShortcuts);
    if (initializationData.initialData) {
      haveLoadedFromSvg = true;
      editorControl2.loadInitialImage(initializationData.initialData);
    }
    startAutosaveLoop_default(
      editorControl2.editor,
      initializationData.autosaveIntervalMS,
      (message) => webviewApi.postMessage(message)
    );
  };
  var addSaveCompletedListener = (listener) => {
    saveCompletedListeners.push(listener);
  };
  var showImagePicker = async () => {
    const response = await webviewApi.postMessage({ type: "showImagePicker" /* ShowImagePicker */ });
    if (typeof response !== "object" || response.type !== "imagePickerStartedResponse" /* ImagePickerTaskResponse */) {
      throw new Error(`Invalid response or type ${response}`);
    }
    const images = (async () => {
      const imagePickerResponse = await webviewApi.postMessage({
        type: "getImagePicker" /* GetImagePickerResult */,
        taskId: response.taskId
      });
      if (typeof imagePickerResponse !== "object" || imagePickerResponse.type !== "imagePickerResponse" /* ImagePickerResponse */) {
        throw new Error(`Invalid response or type ${imagePickerResponse}`);
      }
      return imagePickerResponse.images;
    })();
    return {
      images,
      cancel: () => {
        webviewApi.postMessage({ type: "cancelImagePicker" /* CancelImagePicker */, taskId: response.taskId });
      },
      cleanUp: () => {
        webviewApi.postMessage({
          type: "cleanUpImagePicker" /* CleanUpImagePickerResult */,
          taskId: response.taskId
        });
      }
    };
  };
  void (async () => {
    editorControl = await makeJsDrawEditor_default(localStorageSettingControl_default, {
      onSave: () => showSaveScreen_default(editorControl, postMessageCallback),
      onExit: () => showCloseScreen_default(editorControl, postMessageCallback, addSaveCompletedListener),
      showImagePicker
    });
    if (editorInitializationData) {
      initializeEditor(editorControl, editorInitializationData);
    }
  })();
  webviewApi.onMessage(async ({ message }) => {
    if (message.type === "saveCompleted" /* SaveCompleted */) {
      editorControl?.onSaved();
      webviewApi.postMessage({
        type: "setSaveMethod" /* SetSaveMethod */,
        method: "overwrite" /* Overwrite */
      });
      for (const listener of saveCompletedListeners) {
        listener();
      }
      saveCompletedListeners = [];
      return true;
    } else {
      console.log("unknown message", message);
      throw new Error(`Unknown message: ${message}`);
    }
  });
  var loadedMessage = {
    type: "getInitialData" /* GetInitialData */
  };
  webviewApi.postMessage(loadedMessage).then(async (result) => {
    if (result !== true && result.type === "initialDataResponse" /* InitialDataResponse */ && !haveLoadedFromSvg) {
      if (editorControl) {
        initializeEditor(editorControl, result);
      } else {
        editorInitializationData = result;
      }
    }
  });
})();
/*! Bundled license information:

@melloware/coloris/dist/esm/coloris.js:
  (*!
  * Copyright (c) 2021-2023 Momo Bassit.
  * Licensed under the MIT License (MIT)
  * https://github.com/mdbassit/Coloris
  * Version: 0.21.1
  * NPM: https://github.com/melloware/coloris-npm
  *)
*/
